// RuntimeModeInline.cpp - Inline runtime mode implementation
// Story #116: Implement Inline Runtime Mode
//
// TDD GREEN Phase: Full implementation
//
// This implementation embeds runtime code directly into generated C files
// for zero-dependency, self-contained output suitable for embedded systems
// and safety-critical applications.

#include "RuntimeModeInline.h"
#include <fstream>
#include <sstream>

// Constructor - minimal initialization
RuntimeModeInline::RuntimeModeInline() {
  // Empty for now - will populate used features based on AST analysis
}

// Check if inline mode is active
bool RuntimeModeInline::isInlineMode() const {
  return true; // GREEN: Always true for inline mode
}

// Mark a runtime feature as used
void RuntimeModeInline::markFeatureUsed(RuntimeFeature feature) {
  usedFeatures_.insert(feature); // GREEN: Add feature to set
}

// Embed exception handling runtime code
std::string RuntimeModeInline::embedExceptionRuntime() const {
  // GREEN: Read exception runtime and wrap with guards
  return readRuntimeFile("runtime/exception_runtime.h",
                          "__EXCEPTION_RUNTIME_INLINE_H__");
}

// Embed RTTI (Runtime Type Information) code
std::string RuntimeModeInline::embedRTTIRuntime() const {
  // GREEN: Read RTTI runtime and wrap with guards
  return readRuntimeFile("runtime/rtti_runtime.h",
                          "__RTTI_RUNTIME_INLINE_H__");
}

// Embed memory management runtime code
std::string RuntimeModeInline::embedMemoryRuntime() const {
  // GREEN: Read memory runtime and wrap with guards
  return readRuntimeFile("runtime/memory_runtime.h",
                          "__MEMORY_RUNTIME_INLINE_H__");
}

// Embed virtual inheritance runtime code
std::string RuntimeModeInline::embedVInheritRuntime() const {
  // GREEN: Read virtual inheritance runtime and wrap with guards
  return readRuntimeFile("runtime/vinherit_runtime.h",
                          "__VINHERIT_RUNTIME_INLINE_H__");
}

// Generate complete inline runtime for all used features
std::string RuntimeModeInline::generateInlineRuntime() const {
  // GREEN: Combine runtime code for all marked features
  std::stringstream result;

  // Add header comment
  result << "// Inline Runtime Code - Generated by cpptoc\n";
  result << "// Only includes runtime features used in this translation unit\n\n";

  // Include standard library headers needed by runtime
  result << "#include <setjmp.h>\n";
  result << "#include <stddef.h>\n";
  result << "#include <stdlib.h>\n";
  result << "#include <string.h>\n\n";

  // Embed each used feature's runtime code
  if (usedFeatures_.count(RuntimeFeature::Exceptions) > 0) {
    result << embedExceptionRuntime() << "\n\n";
  }

  if (usedFeatures_.count(RuntimeFeature::RTTI) > 0) {
    result << embedRTTIRuntime() << "\n\n";
  }

  if (usedFeatures_.count(RuntimeFeature::Memory) > 0) {
    result << embedMemoryRuntime() << "\n\n";
  }

  if (usedFeatures_.count(RuntimeFeature::VInherit) > 0) {
    result << embedVInheritRuntime() << "\n\n";
  }

  return result.str();
}

// Read runtime source file and wrap with guards
std::string RuntimeModeInline::readRuntimeFile(const std::string &filename,
                                                const std::string &guardName) const {
  // GREEN: Read file and wrap with include guards
  std::ifstream file(filename);
  if (!file.is_open()) {
    // Return empty if file doesn't exist (graceful degradation)
    return "";
  }

  // Read entire file content
  std::stringstream buffer;
  buffer << file.rdbuf();
  std::string content = buffer.str();

  // Wrap with preprocessor guards
  std::stringstream result;
  result << "#ifndef " << guardName << "\n";
  result << "#define " << guardName << "\n\n";
  result << content;
  result << "\n#endif // " << guardName << "\n";

  return result.str();
}
