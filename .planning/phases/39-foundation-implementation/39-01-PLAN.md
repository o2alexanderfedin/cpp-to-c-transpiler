# Phase 39-01: Foundation Implementation - Phase 1 (Basic Functions & Arithmetic)

## Objective

Implement the complete transpiler foundation by building test infrastructure and 4 core handlers (FunctionHandler, VariableHandler, ExpressionHandler, StatementHandler) using TDD methodology. This establishes the end-to-end pipeline for basic C++ programs.

**Goal:** Transpile simple C++ programs (functions, local variables, arithmetic) to working C code.

**Reference:** This plan executes the detailed implementation steps in `@docs/architecture/10-phase1-detailed-plan.md`

## Context

**Architecture Foundation (Phase 36-38):**
@docs/architecture/feature-node-mapping.json - Phase 1 specification
@docs/architecture/05-implementation-phases.md - Phase 1 details
@docs/architecture/06-handler-implementation-order.md - Handler order
@docs/architecture/07-test-plan.md - Phase 1 test plan
@docs/architecture/08-test-fixtures-design.md - Test infrastructure design
@docs/architecture/10-phase1-detailed-plan.md - 98 TDD steps

**Handler Specifications:**
@docs/architecture/handlers/FunctionHandler.md
@docs/architecture/handlers/VariableHandler.md
@docs/architecture/handlers/ExpressionHandler.md
@docs/architecture/handlers/StatementHandler.md

**Core Architecture:**
@docs/architecture/01-pipeline-architecture.md - 3-stage pipeline
@docs/architecture/02-handler-chain-pattern.md - Handler interfaces
@docs/architecture/03-test-strategy.md - TDD approach
@docs/architecture/04-code-generator.md - Stage 3 spec

**Existing Codebase:**
@include/CNodeBuilder.h - Existing C AST builder
@src/CppToCVisitor.cpp - Current implementation (to be replaced)
@CMakeLists.txt - Build configuration

## Tasks

### Task 1: Setup Test Infrastructure
**Type**: auto
**Estimated**: 8-10 hours

**Action**: Create test infrastructure following `@docs/architecture/08-test-fixtures-design.md`

**Subtasks:**
1. Create `tests/fixtures/MockASTContext.h` and `.cpp`:
   - Constructor/destructor with AST context ownership
   - `createFunction()` - create FunctionDecl nodes
   - `createVariable()` - create VarDecl nodes
   - `createParameter()` - create ParmVarDecl nodes
   - `createIntLiteral()` - create IntegerLiteral nodes
   - `createFloatLiteral()` - create FloatingLiteral nodes
   - `createBinaryOp()` - create BinaryOperator nodes
   - `createUnaryOp()` - create UnaryOperator nodes
   - `createVarRef()` - create DeclRefExpr nodes
   - `createReturnStmt()` - create ReturnStmt nodes
   - `createCompoundStmt()` - create CompoundStmt nodes
   - `parseType()` - parse type strings to QualType

2. Create `tests/fixtures/HandlerTestFixture.h` and `.cpp`:
   - Base class for all handler tests
   - Setup MockASTContext for C++ and C
   - Create HandlerContext
   - Helper methods for common assertions
   - Memory management

3. Create `tests/fixtures/IntegrationTestHarness.h` and `.cpp`:
   - Full transpilation pipeline tester
   - Compile generated C code with gcc
   - Execute and capture output
   - Compare with expected output

4. Update `CMakeLists.txt`:
   - Add test fixture library
   - Link with Google Test
   - Configure test discovery

**Verification:**
- [ ] All fixture files compile without errors
- [ ] Can create basic C++ AST nodes
- [ ] HandlerTestFixture reduces test boilerplate
- [ ] Integration harness can compile and run C code
- [ ] CMake properly configures tests

---

### Task 2: Implement Handler Infrastructure
**Type**: auto
**Estimated**: 4-6 hours

**Action**: Create base handler interfaces and context following `@docs/architecture/02-handler-chain-pattern.md`

**Subtasks:**
1. Create `include/handlers/ASTHandler.h`:
   ```cpp
   class ASTHandler {
   public:
       virtual ~ASTHandler() = default;
       virtual bool canHandle(const clang::Decl* D) const { return false; }
       virtual bool canHandle(const clang::Stmt* S) const { return false; }
       virtual bool canHandle(const clang::Expr* E) const { return false; }

       virtual clang::Decl* handleDecl(const clang::Decl* D, HandlerContext& ctx) { return nullptr; }
       virtual clang::Stmt* handleStmt(const clang::Stmt* S, HandlerContext& ctx) { return nullptr; }
       virtual clang::Expr* handleExpr(const clang::Expr* E, HandlerContext& ctx) { return nullptr; }
   };
   ```

2. Create `include/handlers/HandlerContext.h`:
   - `ASTContext& cppContext` - C++ AST context
   - `ASTContext& cContext` - C AST context
   - `CNodeBuilder& builder` - C AST builder
   - `std::map<const Decl*, Decl*> declMap` - Symbol mappings
   - `std::map<QualType, QualType> typeMap` - Type mappings
   - Registration and lookup methods

3. Create `include/handlers/HandlerRegistry.h`:
   - `std::vector<std::unique_ptr<ASTHandler>> handlers`
   - `registerHandler(std::unique_ptr<ASTHandler>)`
   - `ASTHandler* getHandler(const Decl*)`
   - `ASTHandler* getHandler(const Stmt*)`
   - `ASTHandler* getHandler(const Expr*)`

4. Create `include/handlers/TranslationOrchestrator.h`:
   - Coordinates handler chain
   - Dispatches to appropriate handlers
   - Manages translation flow

**Verification:**
- [ ] All infrastructure files compile
- [ ] Interfaces follow SOLID principles
- [ ] HandlerContext properly manages state
- [ ] Registry can dispatch to handlers

---

### Task 3: Implement FunctionHandler with TDD
**Type**: auto
**Estimated**: 4-6 hours

**Action**: Implement FunctionHandler following TDD for simple functions

**TDD Cycles (from detailed plan):**

**Cycle 1: Empty Function**
1. Write failing test `EmptyFunction`:
   ```cpp
   TEST_F(FunctionHandlerTest, EmptyFunction) {
       FunctionDecl* cppFunc = mockCpp.createFunction("void", "foo", {}, nullptr);
       FunctionHandler handler;
       Decl* cDecl = handler.handleDecl(cppFunc, context);

       ASSERT_NE(cDecl, nullptr);
       FunctionDecl* cFunc = dyn_cast<FunctionDecl>(cDecl);
       EXPECT_EQ(cFunc->getNameAsString(), "foo");
       EXPECT_TRUE(cFunc->getReturnType()->isVoidType());
       EXPECT_EQ(cFunc->getNumParams(), 0);
   }
   ```

2. Implement minimal FunctionHandler to pass
3. Refactor

**Cycle 2-10:** (Continue following detailed plan steps 1-10)
- FunctionWithIntReturn
- FunctionWithParams
- FunctionWithLocalVars
- FunctionCallSimple
- ArithmeticInReturn
- etc.

**Implementation:**
Create `include/handlers/FunctionHandler.h` and `src/handlers/FunctionHandler.cpp`

**Verification:**
- [ ] 20+ unit tests pass for FunctionHandler
- [ ] Simple functions translate correctly
- [ ] Parameters handled properly
- [ ] Return types correct

---

### Task 4: Implement VariableHandler with TDD
**Type**: auto
**Estimated**: 3-4 hours

**Action**: Implement VariableHandler for local variables

**TDD Cycles:**
- LocalVariableNoInit
- LocalVariableWithInit
- LocalVariableUsedInExpr
- MultipleLocalVariables
- etc.

**Implementation:**
Create `include/handlers/VariableHandler.h` and `src/handlers/VariableHandler.cpp`

**Verification:**
- [ ] 15+ unit tests pass
- [ ] Local variables translate correctly
- [ ] Initialization handled
- [ ] Variable references work

---

### Task 5: Implement ExpressionHandler with TDD
**Type**: auto
**Estimated**: 5-7 hours

**Action**: Implement ExpressionHandler for arithmetic and literals

**TDD Cycles:**
- IntegerLiteral
- FloatingLiteral
- BinaryAddition
- BinarySubtraction
- BinaryMultiplication
- BinaryDivision
- BinaryModulo
- DeclRefExpr
- NestedArithmetic
- etc.

**Implementation:**
Create `include/handlers/ExpressionHandler.h` and `src/handlers/ExpressionHandler.cpp`

**Verification:**
- [ ] 30+ unit tests pass
- [ ] All arithmetic operators work
- [ ] Literals translate correctly
- [ ] Variable references work
- [ ] Nested expressions handled

---

### Task 6: Implement StatementHandler with TDD
**Type**: auto
**Estimated**: 2-3 hours

**Action**: Implement StatementHandler for return and compound statements

**TDD Cycles:**
- ReturnVoid
- ReturnInt
- ReturnExpression
- CompoundStmtEmpty
- CompoundStmtWithStatements
- etc.

**Implementation:**
Create `include/handlers/StatementHandler.h` and `src/handlers/StatementHandler.cpp`

**Verification:**
- [ ] 10+ unit tests pass
- [ ] Return statements work
- [ ] Compound statements work
- [ ] Statement sequences handled

---

### Task 7: Integration Tests - Handler Cooperation
**Type**: auto
**Estimated**: 3-4 hours

**Action**: Write integration tests combining multiple handlers

**Test Cases:**
1. FunctionWithArithmetic - FunctionHandler + ExpressionHandler
2. FunctionWithLocalVarAndArithmetic - All 4 handlers
3. FunctionCallingFunction - Function references
4. ComplexArithmetic - Nested expressions
5. MultipleParameters - Parameter handling
... (20-25 total from test plan)

**Location:** `tests/integration/handlers/`

**Verification:**
- [ ] 25+ integration tests pass
- [ ] Handlers cooperate correctly
- [ ] C AST structure is correct
- [ ] No handler conflicts

---

### Task 8: E2E Integration Tests - Full Transpilation
**Type**: auto
**Estimated**: 2-3 hours

**Action**: Write end-to-end tests with full C compilation and execution

**Test Cases:**
1. SimpleProgram.cpp:
   ```cpp
   int add(int a, int b) {
       return a + b;
   }
   int main() {
       return add(3, 4);  // Should return 7
   }
   ```

2. LocalVariables.cpp
3. ArithmeticExpressions.cpp
4. FunctionCalls.cpp
5. ComplexCalculation.cpp
... (10 total from test plan)

**Location:** `tests/e2e/phase1/`

**Each test:**
- Transpile C++ → C AST
- Emit C code (Stage 3)
- Compile with gcc
- Execute and verify exit code/output

**Verification:**
- [ ] 10+ E2E tests pass
- [ ] Generated C code compiles
- [ ] Generated C code produces correct output
- [ ] No memory leaks (valgrind)

---

### Task 9: Implement Code Generator (Stage 3)
**Type**: auto
**Estimated**: 3-4 hours

**Action**: Implement CodeGenerator to emit C code from C AST (following `@docs/architecture/04-code-generator.md`)

**Implementation:**
Create `include/CodeGenerator.h` and `src/CodeGenerator.cpp`:
- `visitTranslationUnit()`
- `visitFunctionDecl()`
- `visitVarDecl()`
- `visitCompoundStmt()`
- `visitReturnStmt()`
- `visitBinaryOperator()`
- `visitUnaryOperator()`
- `visitDeclRefExpr()`
- `visitIntegerLiteral()`
- `visitFloatingLiteral()`
- `emitType()`
- `emitIndent()`
- Header vs implementation split

**Verification:**
- [ ] Code generator compiles
- [ ] Emits valid C syntax
- [ ] Proper indentation
- [ ] Header/implementation separation works

---

### Task 10: Full Pipeline Integration
**Type**: auto
**Estimated**: 2-3 hours

**Action**: Connect all 3 stages into working pipeline

**Implementation:**
1. Update `src/main.cpp` or create `src/Transpiler.cpp`:
   - Stage 1: Clang parses C++ → C++ AST
   - Stage 2: TranslationOrchestrator → C AST
   - Stage 3: CodeGenerator → C files

2. Wire up all handlers:
   ```cpp
   HandlerRegistry registry;
   registry.registerHandler(std::make_unique<FunctionHandler>());
   registry.registerHandler(std::make_unique<VariableHandler>());
   registry.registerHandler(std::make_unique<ExpressionHandler>());
   registry.registerHandler(std::make_unique<StatementHandler>());

   TranslationOrchestrator orchestrator(registry, context);
   TranslationUnitDecl* cTU = orchestrator.translate(cppTU);

   CodeGenerator generator(headerOS, implOS, cContext);
   generator.generate(cTU);
   ```

3. Run all E2E tests to verify pipeline

**Verification:**
- [ ] Full pipeline works end-to-end
- [ ] All 115 tests pass (80 unit + 25 integration + 10 E2E)
- [ ] Can transpile simple C++ programs
- [ ] Generated C compiles and runs correctly

---

### Task 11: Documentation and Cleanup
**Type**: auto
**Estimated**: 1-2 hours

**Action**: Document implementation and clean up code

**Subtasks:**
1. Add code comments to all handlers
2. Document handler interfaces
3. Create usage examples
4. Update README if needed
5. Remove any debug code
6. Ensure all code follows style guidelines

**Verification:**
- [ ] All public APIs documented
- [ ] Code is clean and readable
- [ ] No debug printfs or TODOs
- [ ] Follows project conventions

---

### Task 12: Code Review and Refactoring
**Type**: auto
**Estimated**: 2-3 hours

**Action**: Self-review and refactor for quality

**Subtasks:**
1. Run static analysis (clang-tidy, cppcheck)
2. Check for code duplication (DRY)
3. Verify SOLID principles
4. Refactor any complex methods
5. Ensure test coverage is 100%
6. Performance check (no obvious bottlenecks)

**Verification:**
- [ ] No static analysis warnings
- [ ] Code follows SOLID principles
- [ ] No duplicated logic
- [ ] 100% test coverage confirmed
- [ ] Performance is acceptable

---

## Verification

**Overall Phase 1 Completion Criteria:**

1. **Test Success:**
   - [ ] All 80 unit tests pass
   - [ ] All 25 integration tests pass
   - [ ] All 10 E2E tests pass
   - [ ] Total: 115 tests passing (100%)

2. **Code Quality:**
   - [ ] All handlers implemented following SOLID
   - [ ] Test infrastructure complete and reusable
   - [ ] Code generator emits valid C
   - [ ] No compiler warnings
   - [ ] No static analysis issues

3. **Functionality:**
   - [ ] Can transpile basic C++ functions to C
   - [ ] Generated C code compiles with gcc
   - [ ] Generated C code produces correct output
   - [ ] No memory leaks (valgrind clean)

4. **Documentation:**
   - [ ] All public APIs documented
   - [ ] Code is readable and maintainable
   - [ ] Examples provided

5. **Pipeline:**
   - [ ] Stage 1 (Clang) works
   - [ ] Stage 2 (Handlers) works
   - [ ] Stage 3 (CodeGen) works
   - [ ] Full pipeline integrated

## Success Criteria

✅ Complete transpiler foundation established
✅ 4 core handlers implemented with TDD
✅ Test infrastructure complete and reusable
✅ 115 tests passing (100%)
✅ Can transpile simple C++ programs to working C code
✅ Code quality excellent (SOLID, DRY, clean)
✅ Ready for Phase 2 (Control Flow)

**Estimated Total:** 21-29 hours as per Phase 38 timeline

## Output

Create `.planning/phases/39-foundation-implementation/39-01-SUMMARY.md` with:

**Deliverables:**
- Test infrastructure files created
- Handler infrastructure files created
- 4 handlers implemented (Function, Variable, Expression, Statement)
- CodeGenerator implemented
- 115 tests written and passing
- Full pipeline integrated

**Statistics:**
- Files created count
- LOC implementation
- LOC tests
- Test count breakdown (unit/integration/E2E)
- All tests passing confirmation

**Key Achievements:**
- Which TDD cycles completed
- Handler cooperation validated
- Pipeline end-to-end validated
- Code quality metrics

**Next Steps:**
- Ready for Phase 2 implementation (Control Flow)
- Foundation established for all future phases
- Test infrastructure reusable

**Commit:**
Format: `feat(phase1): Implement foundation - basic functions and arithmetic`
