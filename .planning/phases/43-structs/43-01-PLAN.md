# Phase 43-01: Structs (C-style) Implementation

**Phase**: 43 (Structs - C-style)
**Goal**: Add support for C-style structs without methods, field access, struct initialization, and passing structs
**Approach**: Test-Driven Development (TDD) with extensive parallelization
**Duration**: Est. 10-12 hours

---

## Objective

Extend the transpiler to handle C-style struct declarations (without methods), field access, struct initialization, and struct parameters/return values. This establishes the foundation for class translation in later phases with direct 1:1 C mapping.

## Context

**Previous Phases:**
- Phase 39 (Phase 1): Basic functions, arithmetic, local variables ✅
- Phase 40 (Phase 2): Control flow (if/while/for/switch) ✅
- Phase 41 (Phase 3): Global variables, arrays, literals, casts ✅
- Phase 42 (Phase 4): Pointers and references ✅

**Current State:**
- Handlers exist: FunctionHandler, VariableHandler, ExpressionHandler, StatementHandler
- Test infrastructure: Unit, integration, E2E test frameworks in place
- 340+ tests passing (98%+ pass rate)

**Phase 43 Scope:**
- Struct declarations (C-style, no methods)
- Field declarations
- Field access (. operator)
- Struct pointer access (-> operator)
- Struct initialization (brace-init with InitListExpr)
- Passing structs to functions (by value and by pointer)
- Returning structs from functions
- Nested structs (struct as field type)
- Forward struct declarations

**Architecture:**
- 1:1 C mapping for all constructs (no transformations)
- Direct syntax preservation
- Opcode preservation where applicable
- Struct keyword required in C (struct Point vs Point in C++)

---

## Tasks

### Group 1: Struct Declarations (Parallel Execution)

**Task 1: Basic Struct Declarations** (Est. 2-3 hours)
- **Handler**: RecordHandler (NEW)
- **Method**: `handleRecordDecl()` - translate C-style struct declarations
- **Implementation**:
  - Create new RecordHandler class
  - Detect RecordDecl in C++ AST
  - Create C RecordDecl with identical structure
  - Translate field declarations
  - Handle struct/class keyword (normalize to struct in C)
  - Register in HandlerContext symbol table
- **Tests** (10-12 tests):
  - Empty struct
  - Simple struct with fields
  - Struct with multiple fields of different types
  - Struct with const fields
  - Struct with static fields (document as unsupported for C-style)
  - Struct with array fields
  - Struct with pointer fields
  - Forward struct declaration
  - Typedef struct
  - Anonymous struct (document limitations)

**Task 2: Nested Struct Handling** (Est. 1-2 hours)
- **Handler**: RecordHandler
- **Method**: Extend `handleRecordDecl()` for nested structs
- **Implementation**:
  - Detect nested RecordDecl within RecordDecl
  - Option 1: Lift nested struct to global scope
  - Option 2: Keep nested (C supports nested struct declarations)
  - Handle nested struct field types
  - Handle circular dependencies (forward declarations)
- **Tests** (6-8 tests):
  - Struct with nested struct definition
  - Struct with nested struct field
  - Multiple level nesting
  - Nested struct used in multiple parent structs
  - Forward declaration for circular dependency
  - Anonymous nested struct

### Group 2: Field Access (Parallel Execution)

**Task 3: Member Expression (. operator)** (Est. 2-3 hours)
- **Handler**: ExpressionHandler
- **Method**: `handleMemberExpr()` - translate field access
- **Implementation**:
  - Detect MemberExpr in C++ AST
  - Create C MemberExpr with same structure
  - Translate base expression (the struct variable)
  - Translate member declaration reference
  - Handle lvalue vs rvalue context
  - Handle nested member access (struct.field1.field2)
- **Tests** (10-12 tests):
  - Simple field access (s.x)
  - Field access in expression (s.x + 1)
  - Field access as lvalue (s.x = 10)
  - Nested field access (rect.topLeft.x)
  - Field access in function call (func(s.x))
  - Field access in array subscript (arr[s.index])
  - Field access of array field (s.arr[0])
  - Field access of pointer field (s.ptr->value)

**Task 4: Pointer Member Expression (-> operator)** (Est. 1-2 hours)
- **Handler**: ExpressionHandler
- **Method**: Extend `handleMemberExpr()` for pointer access
- **Implementation**:
  - Detect MemberExpr with arrow operator
  - Create C MemberExpr with arrow operator preserved
  - Handle base expression (pointer to struct)
  - Handle nested pointer access (ptr->field->subfield)
- **Tests** (6-8 tests):
  - Simple pointer field access (ptr->x)
  - Pointer field access in expression (ptr->x + 1)
  - Pointer field access as lvalue (ptr->x = 10)
  - Nested pointer field access (ptr->next->value)
  - Pointer field access in function call (func(ptr->x))
  - Null pointer dereference (ptr->x where ptr could be NULL)

### Group 3: Struct Initialization and Usage (Parallel Execution)

**Task 5: Struct Initialization** (Est. 2-3 hours)
- **Handler**: ExpressionHandler
- **Method**: Extend `handleInitListExpr()` for struct initialization
- **Implementation**:
  - Already have InitListExpr from Phase 41 (arrays)
  - Extend to detect struct type initialization
  - Create C InitListExpr for struct
  - Handle field initialization order
  - Handle partial initialization (uninitialized fields get zero)
  - Handle designated initializers (C99 extension)
  - Handle nested struct initialization
- **Tests** (10-12 tests):
  - Full struct initialization ({1, 2})
  - Partial struct initialization ({1})
  - Empty initializer ({})
  - Nested struct initialization ({{1, 2}, {3, 4}})
  - Designated initializer ({.x = 1, .y = 2})
  - Mixed initialization
  - Initialization with expressions ({a+1, b*2})
  - Array field initialization ({.arr = {1, 2, 3}})

**Task 6: Struct Parameters and Return Values** (Est. 1-2 hours)
- **Handler**: FunctionHandler, VariableHandler
- **Method**: Extend type translation for struct types
- **Implementation**:
  - Detect RecordType in function parameters
  - Create C parameter with "struct StructName" type
  - Handle return type with RecordType
  - Handle pass-by-value vs pass-by-pointer
  - Handle struct return (may need temp variable)
- **Tests** (8-10 tests):
  - Function with struct parameter by value
  - Function with struct parameter by pointer
  - Function returning struct by value
  - Function returning struct pointer
  - Function with multiple struct parameters
  - Function with struct parameter and return
  - Struct parameter with field access in body

### Group 4: Type System Integration (Sequential)

**Task 7: Struct Type References** (Est. 1-2 hours)
- **Handler**: VariableHandler, ExpressionHandler
- **Method**: Handle ElaboratedType and RecordType
- **Implementation**:
  - Detect RecordType in variable declarations
  - Ensure "struct" keyword is prepended in C
  - Handle typedef structs
  - Handle struct in array types (struct Point arr[10])
  - Handle struct in pointer types (struct Point*)
- **Tests** (6-8 tests):
  - Local variable with struct type
  - Global variable with struct type
  - Struct array
  - Struct pointer
  - Typedef struct variable
  - Const struct variable
  - Static struct variable

**Task 8: Struct Forward Declarations** (Est. 1 hour)
- **Handler**: RecordHandler
- **Method**: Extend `handleRecordDecl()` for forward declarations
- **Implementation**:
  - Detect RecordDecl without definition
  - Create C forward declaration (struct Name;)
  - Handle circular dependencies
  - Ensure definition comes after forward declaration
- **Tests** (4-6 tests):
  - Simple forward declaration
  - Forward declaration with pointer usage
  - Circular struct dependency (A contains B*, B contains A*)
  - Multiple forward declarations

### Group 5: Integration and E2E Tests (Sequential)

**Task 9: Integration Tests** (Est. 2 hours)
- **File**: `tests/integration/handlers/StructsIntegrationTest.cpp`
- **Tests** (20-25 tests):
  - Functions creating and returning structs
  - Functions modifying struct fields
  - Linked list operations (struct with next pointer)
  - Struct arrays with iteration
  - Nested struct access in complex expressions
  - Struct initialization in loops
  - Multiple struct types in same function
  - Struct passed by value vs by pointer
  - Struct with all primitive types
  - Struct with mixed types (primitives, arrays, pointers)

**Task 10: E2E Tests** (Est. 1-2 hours)
- **File**: `tests/e2e/phase5/StructsE2ETest.cpp`
- **Tests** (10-12 tests):
  - 1 active sanity test (simple struct creation and usage)
  - 1-2 active tests (struct-based algorithms)
  - 8-10 disabled algorithm tests:
    - Linked list implementation
    - Binary tree operations
    - Point/Rectangle geometry calculations
    - Color manipulation
    - Student record management
    - 2D vector operations
    - Stack implementation with struct
    - Queue implementation with struct

---

## Execution Strategy

### Parallel Execution Groups

**Group 1 (Tasks 1-2): Struct Declarations** - 2 parallel subtasks
- Independent: Basic declarations and nested struct handling
- Duration: ~3 hours parallel (vs ~5 hours sequential)

**Group 2 (Tasks 3-4): Field Access** - 2 parallel subtasks
- Independent: Dot operator and arrow operator are separate
- Duration: ~3 hours parallel (vs ~5 hours sequential)

**Group 3 (Tasks 5-6): Initialization and Parameters** - 2 parallel subtasks
- Independent: Initialization and parameter handling are orthogonal
- Duration: ~2 hours parallel (vs ~4 hours sequential)

**Group 4 (Tasks 7-8): Type System** - Sequential
- Some dependency on previous tasks
- Duration: ~2 hours sequential

**Group 5 (Tasks 9-10): Integration/E2E** - Sequential
- Depends on all previous tasks completing
- Duration: ~3 hours sequential

**Total Estimated Time:**
- Parallel: ~13 hours (3+3+2+2+3)
- Sequential: ~21 hours
- **Time Savings: ~38%**

### Deviation Rules

1. **Nested Struct Complexity**: If nested structs prove complex, lift all to global scope initially
2. **Anonymous Structs**: May skip or document as unsupported if encountered
3. **Bitfields**: Skip bitfield support initially (defer to later phase)
4. **Struct Alignment**: Trust compiler, document any alignment issues
5. **Designated Initializers**: C99 feature, test but document as optional

---

## Success Criteria

- [ ] All 70+ unit tests pass (100%)
- [ ] All 20-25 integration tests pass (100%)
- [ ] 1-2 E2E sanity tests pass (100%)
- [ ] Struct declarations work correctly
- [ ] Field access (. and ->) works correctly
- [ ] Struct initialization works correctly
- [ ] Structs can be passed to and returned from functions
- [ ] Nested structs work correctly
- [ ] Forward declarations work correctly
- [ ] No compiler warnings
- [ ] Code follows SOLID principles
- [ ] TDD followed throughout (tests before implementation)
- [ ] Documentation complete (this plan + SUMMARY.md)

---

## Verification

After implementation:

1. **Build and Test:**
   ```bash
   cd build
   cmake ..
   make -j$(nproc)
   ctest --output-on-failure
   ```

2. **Run specific test suites:**
   ```bash
   ./tests/unit/handlers/RecordHandlerTest  # Struct declarations
   ./tests/unit/handlers/ExpressionHandlerTest  # Field access
   ./tests/integration/handlers/StructsIntegrationTest
   ./tests/e2e/phase5/StructsE2ETest
   ```

3. **Verify pass rates:**
   - Total Phase 43 tests: ~80
   - Combined project tests: ~420 (340 previous + 80 new)
   - Expected pass rate: 99%+

4. **Code review:**
   - Check SOLID compliance
   - Verify 1:1 C mapping
   - No over-engineering
   - Clean separation of concerns

---

## Deliverables

1. **New Handler:**
   - `include/handlers/RecordHandler.h` - Struct declaration handler interface
   - `src/handlers/RecordHandler.cpp` - Implementation

2. **Handler Extensions:**
   - `include/handlers/ExpressionHandler.h` - Add handleMemberExpr()
   - `src/handlers/ExpressionHandler.cpp` - Implement field access
   - `include/handlers/VariableHandler.h` - Extend for struct types
   - `src/handlers/VariableHandler.cpp` - Handle struct variables
   - `include/handlers/FunctionHandler.h` - Extend for struct params/return
   - `src/handlers/FunctionHandler.cpp` - Handle struct in signatures

3. **Unit Tests:**
   - `tests/unit/handlers/RecordHandlerTest.cpp` - ~20 new tests (NEW)
   - `tests/unit/handlers/ExpressionHandlerTest.cpp` - ~20 new tests
   - `tests/unit/handlers/VariableHandlerTest.cpp` - ~10 new tests
   - `tests/unit/handlers/FunctionHandlerTest.cpp` - ~10 new tests

4. **Integration Tests:**
   - `tests/integration/handlers/StructsIntegrationTest.cpp` - ~25 tests (NEW)

5. **E2E Tests:**
   - `tests/e2e/phase5/StructsE2ETest.cpp` - ~12 tests (NEW)

6. **Documentation:**
   - `.planning/phases/43-structs/43-01-PLAN.md` - This file
   - `.planning/phases/43-structs/43-01-SUMMARY.md` - Execution summary
   - `.planning/phases/43-structs/PHASE5-COMPLETE.md` - Completion doc

7. **Build Configuration:**
   - `CMakeLists.txt` - Updated with new test executables

---

## Dependencies

**Phase 1 (Complete):**
- FunctionHandler, VariableHandler infrastructure

**Phase 2 (Complete):**
- Control flow for testing struct operations

**Phase 3 (Complete):**
- Global variables for struct declarations
- Arrays for struct arrays
- Type casting infrastructure
- InitListExpr infrastructure (will extend for structs)

**Phase 4 (Complete):**
- Pointers for struct pointers (->)
- Pointer operations for linked lists

**External Dependencies:**
- Clang/LLVM AST API
- Google Test framework
- CMake build system

---

## Implementation Notes

### 1:1 C Mapping Examples

**Basic Struct:**
```cpp
// C++ Input
struct Point {
    int x;
    int y;
};

// C Output (identical)
struct Point {
    int x;
    int y;
};
```

**Struct Keyword Required in C:**
```cpp
// C++ Input
Point p = {1, 2};

// C Output
struct Point p = {1, 2};
```

**Field Access:**
```cpp
// C++ Input
Point p;
p.x = 10;
int val = p.y;

// C Output (identical)
struct Point p;
p.x = 10;
int val = p.y;
```

**Pointer Field Access:**
```cpp
// C++ Input
Point* ptr = &p;
ptr->x = 20;

// C Output (identical)
struct Point* ptr = &p;
ptr->x = 20;
```

**Struct Initialization:**
```cpp
// C++ Input
Point p = {10, 20};

// C Output (identical)
struct Point p = {10, 20};
```

**Struct in Function:**
```cpp
// C++ Input
Point add_points(Point a, Point b) {
    Point result = {a.x + b.x, a.y + b.y};
    return result;
}

// C Output
struct Point add_points(struct Point a, struct Point b) {
    struct Point result = {a.x + b.x, a.y + b.y};
    return result;
}
```

**Nested Struct:**
```cpp
// C++ Input
struct Rectangle {
    Point topLeft;
    Point bottomRight;
};

// C Output
struct Rectangle {
    struct Point topLeft;
    struct Point bottomRight;
};
```

### Handler Architecture

**RecordHandler (NEW):**
- Responsibility: Translate struct/class declarations (C-style only, no methods)
- Methods:
  - `canHandle(const clang::Decl*)` - Check if RecordDecl
  - `handleRecordDecl(const clang::RecordDecl*, HandlerContext&)` - Translate struct
  - `translateFields(...)` - Translate field declarations
  - `handleForwardDecl(...)` - Handle forward declarations

**ExpressionHandler Extensions:**
- Add `handleMemberExpr()` for field access
- Already has `handleInitListExpr()` from Phase 41, extend for struct types

**VariableHandler Extensions:**
- Extend type translation to handle RecordType
- Ensure "struct" keyword prepended in C

**FunctionHandler Extensions:**
- Extend parameter type translation for struct types
- Extend return type translation for struct types

---

## Risk Mitigation

**Risk 1: Nested Struct Complexity**
- Mitigation: Start with simple nested structs, then add complex cases
- Fallback: Lift all nested structs to global scope if needed
- Document any limitations

**Risk 2: Struct Keyword Insertion**
- Mitigation: Ensure all RecordType references prepend "struct"
- Test with typedef structs to verify correct handling
- Document any edge cases

**Risk 3: Struct Initialization Edge Cases**
- Mitigation: Start with full initialization, then partial, then designated
- Test each initialization style separately
- Document C99 vs C89 differences

**Risk 4: Circular Dependencies**
- Mitigation: Implement forward declaration support early
- Test circular pointer dependencies (A → B → A)
- Document any limitations

---

## Next Steps After Completion

**Phase 44: Classes (Simple)** - Est. 15-20 hours
- Class → struct transformation
- Member functions → functions with this parameter
- Constructors → init functions
- Destructors → cleanup functions
- Method calls
- Access specifiers (public/private/protected) → name mangling

**Phase 45: Inheritance (Single)** - Est. 15-20 hours
- Single inheritance → struct composition
- Base class field access
- Virtual methods → function pointers
- Vtable generation

---

## TDD Workflow (Per Task)

1. **Write failing test** - Create test that exercises new functionality
2. **Run test** - Verify it fails (red)
3. **Implement minimal code** - Make test pass with simplest solution
4. **Run test** - Verify it passes (green)
5. **Refactor** - Clean up while keeping tests green
6. **Commit** - Commit working code with tests

**Example for Task 1 (Basic Struct Declarations):**
```cpp
// 1. Write failing test
TEST_F(RecordHandlerTest, SimpleStructDeclaration) {
    auto testAST = buildASTFromCode(R"(
        struct Point {
            int x;
            int y;
        };
    )");
    // ... assertion that will fail initially
}

// 2. Run test → RED
// 3. Implement RecordHandler::handleRecordDecl() → GREEN
// 4. Refactor if needed → GREEN
// 5. Commit
```

---

## Communication

**Updates:**
- Create summary after each group completes
- Report any deviations from plan
- Document any Clang API discoveries

**Final Summary:**
- Total tests added
- Pass rate
- Code volume (LOC)
- Time spent vs estimate
- Lessons learned
- Issues encountered and resolutions

---

**Plan Status**: Ready for execution
**Next Action**: Execute Group 1 (Tasks 1-2) in parallel - Basic and Nested Struct Declarations
