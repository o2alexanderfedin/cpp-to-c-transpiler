# Phase 44-01: Classes (Simple) Implementation

**Phase**: 44 (Classes - Simple, without inheritance)
**Goal**: Translate C++ classes to C structs, methods to functions with explicit `this` parameter
**Approach**: Test-Driven Development (TDD) with extensive parallelization
**Duration**: Est. 24-33 hours

---

## Objective

Extend the transpiler to handle C++ classes (without inheritance) by transforming them to C structs and translating member functions to regular functions with explicit `this` parameter. This is the first major transformation phase beyond 1:1 mapping.

## Context

**Previous Phases:**
- Phase 39 (Phase 1): Basic functions, arithmetic, local variables ✅
- Phase 40 (Phase 2): Control flow (if/while/for/switch) ✅
- Phase 41 (Phase 3): Global variables, arrays, literals, casts ✅
- Phase 42 (Phase 4): Pointers and references ✅
- Phase 43 (Phase 5): Structs (C-style) ✅

**Current State:**
- Handlers exist: FunctionHandler, VariableHandler, ExpressionHandler, StatementHandler, RecordHandler
- Test infrastructure: Unit, integration, E2E test frameworks in place
- 410+ tests passing (98%+ pass rate)
- RecordHandler supports C-style structs (no methods)

**Phase 44 Scope:**
- Class declarations → struct declarations
- Member variables (all access specifiers treated equally in C)
- Member functions → functions with `this` parameter
- Constructors → init functions
- Destructors → cleanup/destroy functions
- `this` pointer translation
- Method name mangling (ClassName_methodName)
- Member access via `this->` in method bodies
- Method calls → function calls with `&object` as first argument

**Architecture:**
- **Transformation Required** (not 1:1 mapping)
- Class → Struct transformation
- Method → Function transformation
- Access specifiers stripped (C has no access control)
- `this` pointer made explicit

---

## Tasks

### Group 1: Class to Struct Transformation (Parallel Execution)

**Task 1: CXXRecordDecl Translation** (Est. 3-4 hours)
- **Handler**: RecordHandler (extend)
- **Method**: Extend `handleRecordDecl()` to handle CXXRecordDecl
- **Implementation**:
  - Detect CXXRecordDecl (class declarations)
  - Extract member variables only (ignore methods for now)
  - Strip access specifiers (public/private/protected)
  - Create C RecordDecl with struct tag
  - Register class name for method name mangling
- **Tests** (12-15 tests):
  - Empty class
  - Class with public fields
  - Class with private fields
  - Class with mixed access specifiers
  - Class with all primitive types
  - Class with pointers
  - Class with arrays
  - Class with struct members
  - Forward class declaration
  - Multiple classes

**Task 2: Access Specifier Handling** (Est. 1-2 hours)
- **Handler**: RecordHandler
- **Method**: `stripAccessSpecifiers()` helper
- **Implementation**:
  - Iterate through all members
  - Ignore AccessSpecDecl nodes
  - Treat all fields equally (C has no access control)
  - Document that access control is lost in translation
- **Tests** (6-8 tests):
  - Class with only public members
  - Class with only private members
  - Class with only protected members
  - Class with mixed access (public/private)
  - Class with default access (private for class, public for struct)
  - Access specifier interleaved with members

### Group 2: Method Translation (Parallel Execution - 3 tasks)

**Task 3: Method Handler Creation** (Est. 4-5 hours)
- **Handler**: MethodHandler (NEW)
- **Method**: `handleCXXMethodDecl()`
- **Implementation**:
  - Create new MethodHandler class
  - Detect CXXMethodDecl in C++ AST
  - Extract method signature (return type, parameters)
  - Add explicit `this` parameter as first parameter (struct ClassName* this)
  - Mangle method name (ClassName_methodName)
  - Translate method body (member access → this->member)
  - Create C FunctionDecl
- **Tests** (15-18 tests):
  - Simple method with no parameters
  - Method with parameters
  - Method returning value
  - Method returning void
  - Const method
  - Method accessing member variables
  - Method calling other methods
  - Static method (no this parameter)
  - Method with same name in different classes
  - Overloaded methods (same name, different params)

**Task 4: Constructor Handler** (Est. 3-4 hours)
- **Handler**: ConstructorHandler (NEW)
- **Method**: `handleCXXConstructorDecl()`
- **Implementation**:
  - Create new ConstructorHandler class
  - Detect CXXConstructorDecl in C++ AST
  - Translate to `ClassName_init()` function
  - Add `this` parameter (struct ClassName* this)
  - Handle constructor parameters
  - Translate constructor body (member initialization)
  - Handle member initializer lists (if simple)
- **Tests** (12-15 tests):
  - Default constructor (no parameters)
  - Constructor with parameters
  - Constructor with member initialization in body
  - Constructor with member initializer list (: field(value))
  - Multiple constructors (overloading)
  - Constructor calling other methods
  - Delegating constructor (calls another constructor)
  - Constructor with all types of initialization

**Task 5: Destructor Handler** (Est. 2-3 hours)
- **Handler**: DestructorHandler (NEW)
- **Method**: `handleCXXDestructorDecl()`
- **Implementation**:
  - Create new DestructorHandler class
  - Detect CXXDestructorDecl in C++ AST
  - Translate to `ClassName_destroy()` function
  - Add `this` parameter (struct ClassName* this)
  - Translate destructor body (cleanup code)
  - No parameters (destructor never has parameters)
- **Tests** (8-10 tests):
  - Empty destructor
  - Destructor with cleanup code
  - Destructor calling methods
  - Destructor accessing member variables
  - Destructor with resource cleanup (close, free, etc.)
  - Virtual destructor (treat as regular for now, no virtual table)

### Group 3: This Pointer and Member Access (Parallel Execution - 2 tasks)

**Task 6: This Expression Handler** (Est. 2-3 hours)
- **Handler**: ExpressionHandler (extend)
- **Method**: `handleCXXThisExpr()`
- **Implementation**:
  - Detect CXXThisExpr in C++ AST
  - Create C DeclRefExpr referring to `this` parameter
  - Ensure correct type (struct ClassName* this)
  - Handle in both method bodies and constructor/destructor bodies
- **Tests** (8-10 tests):
  - `this` in method body
  - `this->field` access
  - `this->method()` call
  - Return `this` from method (for chaining)
  - `this` in constructor
  - `this` in destructor
  - `this` in const method
  - `this` pointer arithmetic (if applicable)

**Task 7: Member Access Translation** (Est. 2-3 hours)
- **Handler**: ExpressionHandler (extend)
- **Method**: Extend `handleMemberExpr()` for implicit object access
- **Implementation**:
  - Detect implicit `this->` in member access
  - Convert `field` to `this->field` in method bodies
  - Convert `method()` to `ClassName_method(this)` calls
  - Handle explicit `this->field` (already works from Phase 43)
  - Handle chained member access
- **Tests** (10-12 tests):
  - Implicit field access in method (field = 10)
  - Implicit field read in method (return field)
  - Explicit this->field access
  - Field access in constructor
  - Field access in destructor
  - Field access in expression (field + 1)
  - Multiple field accesses
  - Nested field access (if struct member)

### Group 4: Method Calls and Object Usage (Parallel Execution - 2 tasks)

**Task 8: Method Call Translation** (Est. 3-4 hours)
- **Handler**: ExpressionHandler (extend)
- **Method**: `handleCXXMemberCallExpr()`
- **Implementation**:
  - Detect CXXMemberCallExpr in C++ AST
  - Extract object expression (the object being called on)
  - Extract method being called
  - Translate to function call: `ClassName_methodName(&object, args...)`
  - Handle `this->method()` calls (pass `this` as first argument)
  - Handle `object.method()` calls (pass `&object` as first argument)
  - Handle `ptr->method()` calls (pass `ptr` as first argument)
- **Tests** (12-15 tests):
  - Simple method call (obj.method())
  - Method call with arguments (obj.method(1, 2))
  - Method call on pointer (ptr->method())
  - Method call on this (this->method())
  - Chained method calls (obj.m1().m2())
  - Method call returning value used in expression
  - Method call in if condition
  - Method call in loop
  - Method call as function argument

**Task 9: Object Construction and Destruction** (Est. 2-3 hours)
- **Handler**: StatementHandler, ExpressionHandler (extend)
- **Method**: Handle object declaration, automatic destructor injection
- **Implementation**:
  - Detect variable declaration with class type
  - Insert constructor call after declaration
  - Insert destructor call at end of scope (RAII)
  - Handle object initialization with constructor arguments
  - Handle object arrays (call constructor for each element)
- **Tests** (10-12 tests):
  - Simple object declaration (MyClass obj)
  - Object with constructor arguments (MyClass obj(1, 2))
  - Object in if block (destructor at end of block)
  - Object in loop (destructor each iteration)
  - Multiple objects in same scope
  - Object as function parameter
  - Object as return value
  - Object array (MyClass arr[10])

### Group 5: Integration and E2E Tests (Sequential)

**Task 10: Integration Tests** (Est. 4-5 hours)
- **File**: `tests/integration/handlers/ClassesIntegrationTest.cpp`
- **Tests** (30-35 tests):
  - Complete class with methods
  - Class with constructor and destructor
  - Class with multiple methods calling each other
  - Class with member variables of various types
  - Multiple classes interacting
  - Class with static methods
  - Class with overloaded methods
  - Class objects used in functions
  - Class arrays
  - Complex object lifecycle

**Task 11: E2E Tests** (Est. 2-3 hours)
- **File**: `tests/e2e/phase6/ClassesE2ETest.cpp`
- **Tests** (12-15 tests):
  - 1 active sanity test (simple class usage)
  - 2-3 active tests (class-based algorithms)
  - 10-12 disabled algorithm tests:
    - Counter class
    - Point/Vector class
    - Stack class implementation
    - Queue class implementation
    - String class (simple)
    - List class (simple)
    - Calculator class
    - Shape hierarchy (no inheritance, just separate classes)
    - Bank account class
    - Student record class

---

## Execution Strategy

### Parallel Execution Groups

**Group 1 (Tasks 1-2): Class to Struct** - 2 parallel subtasks
- Independent: CXXRecordDecl translation and access specifier handling
- Duration: ~4 hours parallel (vs ~6 hours sequential)

**Group 2 (Tasks 3-5): Method/Constructor/Destructor** - 3 parallel subtasks
- Independent: Three separate handler creations
- Duration: ~5 hours parallel (vs ~11 hours sequential)

**Group 3 (Tasks 6-7): This Pointer & Member Access** - 2 parallel subtasks
- Independent: This expression and member access are orthogonal
- Duration: ~3 hours parallel (vs ~6 hours sequential)

**Group 4 (Tasks 8-9): Method Calls & Object Usage** - 2 parallel subtasks
- Slight dependency but can be developed in parallel
- Duration: ~4 hours parallel (vs ~7 hours sequential)

**Group 5 (Tasks 10-11): Integration/E2E** - Sequential
- Depends on all previous tasks completing
- Duration: ~6 hours sequential

**Total Estimated Time:**
- Parallel: ~22 hours (4+5+3+4+6)
- Sequential: ~36 hours
- **Time Savings: ~39%**

### Deviation Rules

1. **Member Initializer Lists**: If complex, document limitations and defer to later phase
2. **Overloaded Methods**: Basic name mangling with parameter types (ClassName_method_int_int)
3. **Static Methods**: No `this` parameter, direct function translation
4. **Const Methods**: Document that const is advisory only in C
5. **Constructor Delegation**: May simplify or inline if complex
6. **Virtual Methods**: Ignore virtual keyword for now (Phase 7 will handle vtables)

---

## Success Criteria

- [ ] All 90+ unit tests pass (100%)
- [ ] All 30-35 integration tests pass (100%)
- [ ] 1-3 E2E sanity tests pass (100%)
- [ ] Classes correctly translated to structs
- [ ] Methods correctly translated to functions with `this`
- [ ] Constructors create valid init functions
- [ ] Destructors create valid cleanup functions
- [ ] Method calls work correctly
- [ ] Object lifecycle managed correctly (construction + destruction)
- [ ] No compiler warnings
- [ ] Code follows SOLID principles
- [ ] TDD followed throughout (tests before implementation)
- [ ] Documentation complete (this plan + SUMMARY.md)

---

## Verification

After implementation:

1. **Build and Test:**
   ```bash
   cd build
   cmake ..
   make -j$(nproc)
   ctest --output-on-failure
   ```

2. **Run specific test suites:**
   ```bash
   ./tests/unit/handlers/RecordHandlerTest  # Class to struct
   ./tests/unit/handlers/MethodHandlerTest  # Method translation
   ./tests/unit/handlers/ConstructorHandlerTest  # Constructor translation
   ./tests/unit/handlers/DestructorHandlerTest  # Destructor translation
   ./tests/unit/handlers/ExpressionHandlerTest  # This pointer, method calls
   ./tests/integration/handlers/ClassesIntegrationTest
   ./tests/e2e/phase6/ClassesE2ETest
   ```

3. **Verify pass rates:**
   - Total Phase 44 tests: ~100
   - Combined project tests: ~510 (410 previous + 100 new)
   - Expected pass rate: 98%+

4. **Code review:**
   - Check SOLID compliance
   - Verify transformation correctness
   - No over-engineering
   - Clean separation of concerns

---

## Deliverables

1. **New Handlers:**
   - `include/handlers/MethodHandler.h` - Method translation interface
   - `src/handlers/MethodHandler.cpp` - Implementation (~350 LOC)
   - `include/handlers/ConstructorHandler.h` - Constructor translation interface
   - `src/handlers/ConstructorHandler.cpp` - Implementation (~250 LOC)
   - `include/handlers/DestructorHandler.h` - Destructor translation interface
   - `src/handlers/DestructorHandler.cpp` - Implementation (~150 LOC)

2. **Handler Extensions:**
   - `include/handlers/RecordHandler.h` - Extend for CXXRecordDecl
   - `src/handlers/RecordHandler.cpp` - Add class handling (~150 LOC)
   - `include/handlers/ExpressionHandler.h` - Add handleCXXThisExpr, handleCXXMemberCallExpr
   - `src/handlers/ExpressionHandler.cpp` - Implementation (~200 LOC)
   - `include/handlers/StatementHandler.h` - Extend for object lifecycle
   - `src/handlers/StatementHandler.cpp` - Add constructor/destructor injection (~100 LOC)

3. **Unit Tests:**
   - `tests/unit/handlers/RecordHandlerTest.cpp` - ~20 new tests
   - `tests/unit/handlers/MethodHandlerTest.cpp` - ~18 new tests (NEW)
   - `tests/unit/handlers/ConstructorHandlerTest.cpp` - ~15 new tests (NEW)
   - `tests/unit/handlers/DestructorHandlerTest.cpp` - ~10 new tests (NEW)
   - `tests/unit/handlers/ExpressionHandlerTest.cpp` - ~30 new tests

4. **Integration Tests:**
   - `tests/integration/handlers/ClassesIntegrationTest.cpp` - ~35 tests (NEW)

5. **E2E Tests:**
   - `tests/e2e/phase6/ClassesE2ETest.cpp` - ~15 tests (NEW)

6. **Documentation:**
   - `.planning/phases/44-classes-simple/44-01-PLAN.md` - This file
   - `.planning/phases/44-classes-simple/44-01-SUMMARY.md` - Execution summary
   - `.planning/phases/44-classes-simple/PHASE6-COMPLETE.md` - Completion doc

7. **Build Configuration:**
   - `CMakeLists.txt` - Updated with new handlers and test executables

---

## Dependencies

**Phase 43 (Complete):**
- RecordHandler infrastructure
- Struct handling
- Member access (. and ->)

**Phase 42 (Complete):**
- Pointer handling for `this` parameter

**Phase 40 (Complete):**
- Control flow for object lifecycle

**External Dependencies:**
- Clang/LLVM AST API
- Google Test framework
- CMake build system

---

## Implementation Notes

### Class to Struct Transformation

**C++ Input:**
```cpp
class Counter {
private:
    int count;
public:
    Counter() : count(0) {}
    void increment() { count++; }
    int getCount() { return count; }
    ~Counter() {}
};
```

**C Output (Header):**
```c
struct Counter {
    int count;  // Access specifiers removed
};

void Counter_init(struct Counter* this);
void Counter_increment(struct Counter* this);
int Counter_getCount(struct Counter* this);
void Counter_destroy(struct Counter* this);
```

**C Output (Implementation):**
```c
void Counter_init(struct Counter* this) {
    this->count = 0;
}

void Counter_increment(struct Counter* this) {
    this->count++;
}

int Counter_getCount(struct Counter* this) {
    return this->count;
}

void Counter_destroy(struct Counter* this) {
    // Empty destructor body
}
```

### Method Name Mangling

**Simple Mangling:**
- `ClassName::method()` → `ClassName_method()`
- `ClassName::method(int)` → `ClassName_method()` (parameter types not in name yet)

**Overload Mangling (if needed):**
- `ClassName::method(int)` → `ClassName_method_int()`
- `ClassName::method(int, int)` → `ClassName_method_int_int()`

### This Pointer Translation

**Implicit this:**
```cpp
// C++ (in method body)
count = 10;

// C (in function body)
this->count = 10;
```

**Explicit this:**
```cpp
// C++ (in method body)
this->count = 10;

// C (in function body)
this->count = 10;  // Already correct
```

### Method Call Translation

**Object member call:**
```cpp
// C++ Input
Counter c;
c.increment();

// C Output
struct Counter c;
Counter_init(&c);
Counter_increment(&c);
Counter_destroy(&c);  // Auto-injected at scope end
```

**Pointer member call:**
```cpp
// C++ Input
Counter* ptr = &c;
ptr->increment();

// C Output
struct Counter* ptr = &c;
Counter_increment(ptr);
```

### Constructor/Destructor Injection

**Automatic RAII:**
```cpp
// C++ Input
void test() {
    Counter c;  // Constructor called here
    c.increment();
    // Destructor called here (at end of scope)
}

// C Output
void test(void) {
    struct Counter c;
    Counter_init(&c);  // Explicit constructor call
    Counter_increment(&c);
    Counter_destroy(&c);  // Explicit destructor call before return
}
```

---

## Risk Mitigation

**Risk 1: Member Initializer List Complexity**
- Mitigation: Start with simple initializers (: field(value))
- Fallback: Convert to assignment in constructor body
- Document any limitations

**Risk 2: Constructor Overloading**
- Mitigation: Use name mangling with parameter types
- Fallback: Document that only one constructor supported initially
- Later: Full overload resolution

**Risk 3: Destructor Call Injection Complexity**
- Mitigation: Insert destructor call before each return statement
- Fallback: Insert at end of function only (may leak in early returns)
- Document: Use of goto for cleanup if needed

**Risk 4: Method Overloading**
- Mitigation: Implement basic name mangling
- Fallback: Error on overloaded methods initially
- Later: Full mangling with type signatures

**Risk 5: Static vs Instance Methods**
- Mitigation: Detect static keyword, don't add `this` parameter
- Clear distinction in handler logic

---

## Next Steps After Completion

**Phase 45: Inheritance (Single)** - Est. 20-25 hours
- Single inheritance → struct composition
- Base class field access
- Virtual methods → function pointers
- Vtable generation
- Constructor chaining (base constructor calls)

**Phase 46: Method Overloading** - Est. 10-15 hours
- Full name mangling with parameter types
- Overload resolution
- Type-based dispatch

---

## TDD Workflow (Per Task)

1. **Write failing test** - Create test that exercises new functionality
2. **Run test** - Verify it fails (red)
3. **Implement minimal code** - Make test pass with simplest solution
4. **Run test** - Verify it passes (green)
5. **Refactor** - Clean up while keeping tests green
6. **Commit** - Commit working code with tests

**Example for Task 3 (Method Handler):**
```cpp
// 1. Write failing test
TEST_F(MethodHandlerTest, SimpleMethod) {
    auto testAST = buildASTFromCode(R"(
        class Counter {
            int count;
        public:
            int getCount() { return count; }
        };
    )");
    // ... assertion that will fail initially
}

// 2. Run test → RED
// 3. Implement MethodHandler::handleCXXMethodDecl() → GREEN
// 4. Refactor if needed → GREEN
// 5. Commit
```

---

## Communication

**Updates:**
- Create summary after each group completes
- Report any deviations from plan
- Document any Clang API discoveries

**Final Summary:**
- Total tests added
- Pass rate
- Code volume (LOC)
- Time spent vs estimate
- Lessons learned
- Issues encountered and resolutions

---

**Plan Status**: Ready for execution
**Next Action**: Execute Group 1 (Tasks 1-2) in parallel - Class to Struct Transformation
