# Phase 31-03: Extend COM-Style Pattern to All Methods

## Objective

Extend COM-style static declarations from virtual methods to ALL methods (virtual and non-virtual) for consistency and comprehensive type safety across the entire codebase.

**Why**: After proving the COM-style pattern works for virtual methods (Phase 31-02), extending it to all methods provides:
1. **Consistent code style** - All methods follow same pattern
2. **Universal type safety** - All method signatures verified at compile time
3. **Complete debugging support** - All functions have names in stack traces
4. **No special cases** - Generator logic simplified (one pattern for everything)

## Context

**Completed**: Phase 31-02 (v2.2.0)
- Static declarations for virtual methods âœ…
- VtableGenerator::generateStaticDeclarations() âœ…
- Test suite proving correctness âœ…

**Current State**:
- Virtual methods: Have static declarations (COM-style)
- Non-virtual methods: No static declarations (implicit signatures)
- Constructors/destructors: Mix of explicit/implicit

**Target State**:
- ALL methods: Static declarations
- ALL constructors: Static declarations
- ALL destructors: Static declarations
- Uniform code style throughout

**Example**:
```cpp
class Widget {
    int value;
public:
    // Constructor (non-virtual)
    Widget(int v);

    // Regular method (non-virtual)
    int getValue() const;

    // Virtual method (already has declaration from Phase 31-02)
    virtual void update(int v);
};
```

**Current output** (after Phase 31-02):
```c
// Virtual method declaration (âœ… exists)
static void Widget_update(struct Widget *this, int v);

// Non-virtual methods (âŒ no declarations)
void Widget__ctor(struct Widget *this, int v) { ... }
int Widget_getValue(const struct Widget *this) { ... }
```

**Target output** (after Phase 31-03):
```c
// ALL method declarations (âœ… consistent)
static void Widget__ctor(struct Widget *this, int v);
static int Widget_getValue(const struct Widget *this);
static void Widget_update(struct Widget *this, int v);

// Implementations
static void Widget__ctor(struct Widget *this, int v) { ... }
static int Widget_getValue(const struct Widget *this) { ... }
static void Widget_update(struct Widget *this, int v) { ... }
```

## Tasks

### Task 1: Extend declaration generation to non-virtual methods
**Type**: Implementation
**Files**: `src/CppToCVisitor.cpp`, `include/CppToCVisitor.h`
**Action**:
- Create new method: `std::string generateAllMethodDeclarations(CXXRecordDecl* RD)`
- Collect ALL methods (virtual + non-virtual)
- For each method, generate static declaration
- Include constructors and destructors
- Reuse signature generation logic from VtableGenerator

**Implementation**:
```cpp
// CppToCVisitor.h
class CppToCVisitor {
    // ... existing members ...

    std::string generateAllMethodDeclarations(CXXRecordDecl* RD);
};

// CppToCVisitor.cpp
std::string CppToCVisitor::generateAllMethodDeclarations(CXXRecordDecl* RD) {
    std::ostringstream decls;
    std::string className = RD->getNameAsString();

    decls << "// Static declarations for all " << className << " methods\n";

    // Constructors
    for (auto* ctor : RD->ctors()) {
        if (!ctor->isImplicit()) {  // Skip compiler-generated
            decls << getMethodSignature(ctor, className) << ";\n";
        }
    }

    // Destructor
    if (CXXDestructorDecl* dtor = RD->getDestructor()) {
        if (!dtor->isImplicit()) {
            decls << getMethodSignature(dtor, className) << ";\n";
        }
    }

    // All methods (virtual and non-virtual)
    for (auto* method : RD->methods()) {
        if (!method->isImplicit() &&
            !isa<CXXConstructorDecl>(method) &&
            !isa<CXXDestructorDecl>(method)) {
            decls << getMethodSignature(method, className) << ";\n";
        }
    }

    return decls.str();
}

std::string CppToCVisitor::getMethodSignature(const CXXMethodDecl* Method,
                                               const std::string& ClassName) {
    // Reuse logic from VtableGenerator or create shared helper
    std::ostringstream sig;

    sig << "static ";

    // Return type
    if (isa<CXXConstructorDecl>(Method)) {
        sig << "void";  // Constructors return void in C
    } else if (isa<CXXDestructorDecl>(Method)) {
        sig << "void";  // Destructors return void
    } else {
        sig << getTypeString(Method->getReturnType());
    }

    sig << " ";

    // Method name
    if (isa<CXXConstructorDecl>(Method)) {
        sig << ClassName << "__ctor";
        // Append parameter count for overloads
        if (Method->getNumParams() > 0) {
            sig << "_" << Method->getNumParams();
        }
    } else if (isa<CXXDestructorDecl>(Method)) {
        sig << ClassName << "__dtor";
    } else {
        sig << ClassName << "_" << Method->getNameAsString();
        // Handle overloads (use name mangler)
    }

    // Parameters
    sig << "(struct " << ClassName << " *this";
    for (unsigned i = 0; i < Method->getNumParams(); ++i) {
        const ParmVarDecl* param = Method->getParamDecl(i);
        sig << ", " << getTypeString(param->getType());
        if (!param->getName().empty()) {
            sig << " " << param->getName().str();
        }
    }
    sig << ")";

    return sig.str();
}
```

**Verify**:
- âœ… `generateAllMethodDeclarations()` method exists
- âœ… Generates declarations for constructors
- âœ… Generates declarations for destructor
- âœ… Generates declarations for all methods (virtual + non-virtual)
- âœ… Skips compiler-generated implicit methods
- âœ… Handles method overloading correctly
- âœ… Compiles without errors

**Done**: Declaration generation extended to all methods

---

### Task 2: Refactor to share code with VtableGenerator
**Type**: Refactoring
**Files**: `src/VtableGenerator.cpp`, `src/CppToCVisitor.cpp`, `include/MethodSignatureHelper.h` (new)
**Action**:
- Extract common signature generation logic into shared helper class
- Create `MethodSignatureHelper` to avoid code duplication
- Both VtableGenerator and CppToCVisitor use the helper
- Follow DRY principle

**Implementation**:
```cpp
// include/MethodSignatureHelper.h (new file)
#ifndef METHOD_SIGNATURE_HELPER_H
#define METHOD_SIGNATURE_HELPER_H

#include "clang/AST/DeclCXX.h"
#include <string>

/**
 * Helper class for generating C function signatures from C++ methods.
 * Used by both VtableGenerator and CppToCVisitor to ensure consistency.
 *
 * SOLID Principles:
 * - Single Responsibility: Only generates signatures
 * - Open/Closed: Extensible for new method types
 * - Dependency Inversion: Depends on Clang abstractions
 */
class MethodSignatureHelper {
public:
    /**
     * Generate complete static function signature.
     * Example: "static int Circle_getArea(struct Circle *this, int param)"
     */
    static std::string generateSignature(const clang::CXXMethodDecl* Method,
                                         const std::string& ClassName);

    /**
     * Get C type string from Clang QualType.
     */
    static std::string getTypeString(clang::QualType Type);

    /**
     * Get mangled method name for C.
     * Handles overloading, special methods (ctor/dtor).
     */
    static std::string getMangledName(const clang::CXXMethodDecl* Method,
                                      const std::string& ClassName);
};

#endif
```

```cpp
// src/MethodSignatureHelper.cpp (new file)
#include "../include/MethodSignatureHelper.h"
#include <sstream>

std::string MethodSignatureHelper::generateSignature(
    const clang::CXXMethodDecl* Method,
    const std::string& ClassName) {

    std::ostringstream sig;

    // static keyword
    sig << "static ";

    // Return type
    if (isa<clang::CXXConstructorDecl>(Method)) {
        sig << "void";
    } else if (isa<clang::CXXDestructorDecl>(Method)) {
        sig << "void";
    } else {
        sig << getTypeString(Method->getReturnType());
    }

    sig << " ";

    // Method name
    sig << getMangledName(Method, ClassName);

    // Parameters
    sig << "(struct " << ClassName << " *this";
    for (unsigned i = 0; i < Method->getNumParams(); ++i) {
        const clang::ParmVarDecl* param = Method->getParamDecl(i);
        sig << ", " << getTypeString(param->getType());
        if (!param->getName().empty()) {
            sig << " " << param->getName().str();
        }
    }
    sig << ")";

    return sig.str();
}

std::string MethodSignatureHelper::getTypeString(clang::QualType Type) {
    // Implementation from existing code
    // Handle pointers, const, references, etc.
    return Type.getAsString();
}

std::string MethodSignatureHelper::getMangledName(
    const clang::CXXMethodDecl* Method,
    const std::string& ClassName) {

    if (isa<clang::CXXConstructorDecl>(Method)) {
        std::string name = ClassName + "__ctor";
        if (Method->getNumParams() > 0) {
            name += "_" + std::to_string(Method->getNumParams());
        }
        return name;
    }

    if (isa<clang::CXXDestructorDecl>(Method)) {
        return ClassName + "__dtor";
    }

    // Regular method
    std::string name = ClassName + "_" + Method->getNameAsString().str();

    // Handle overloads (use NameMangler if needed)
    return name;
}
```

**Update VtableGenerator**:
```cpp
// VtableGenerator.cpp
#include "../include/MethodSignatureHelper.h"

std::string VtableGenerator::getMethodSignature(
    const CXXMethodDecl* Method,
    const std::string& ClassName) {
    // Delegate to helper
    return MethodSignatureHelper::generateSignature(Method, ClassName);
}
```

**Update CppToCVisitor**:
```cpp
// CppToCVisitor.cpp
#include "../include/MethodSignatureHelper.h"

std::string CppToCVisitor::getMethodSignature(
    const CXXMethodDecl* Method,
    const std::string& ClassName) {
    // Delegate to helper
    return MethodSignatureHelper::generateSignature(Method, ClassName);
}
```

**Verify**:
- âœ… MethodSignatureHelper class created
- âœ… Code duplication eliminated
- âœ… Both VtableGenerator and CppToCVisitor use helper
- âœ… All existing tests still pass
- âœ… No behavior changes (pure refactoring)

**Done**: Code refactored to share signature generation logic

---

### Task 3: Update header generation to include all declarations
**Type**: Implementation
**Files**: `src/CppToCVisitor.cpp`
**Action**:
- Modify header generation to call `generateAllMethodDeclarations()`
- Place declarations in appropriate section (after vtable structs)
- Ensure declarations for all classes, not just polymorphic ones

**Code changes**:
```cpp
// CppToCVisitor.cpp
std::string CppToCVisitor::generateClassHeader(CXXRecordDecl* RD) {
    std::ostringstream header;

    // ... existing forward declarations ...

    // Vtable struct (if polymorphic)
    if (VtableGen && VirtualAnalyzer.isPolymorphic(RD)) {
        std::string vtableStruct = VtableGen->generateVtableStruct(RD);
        header << vtableStruct << "\n";
    }

    // Class struct definition
    header << "struct " << RD->getNameAsString() << " {\n";
    // ... field generation ...
    header << "};\n\n";

    // NEW: Generate ALL static method declarations
    std::string allDecls = generateAllMethodDeclarations(RD);
    if (!allDecls.empty()) {
        header << allDecls << "\n";
    }

    return header.str();
}
```

**Verify**:
- âœ… All method declarations appear in generated headers
- âœ… Declarations appear after struct definitions
- âœ… Applies to all classes (polymorphic and non-polymorphic)
- âœ… Output compiles successfully
- âœ… No duplicate declarations

**Done**: Header generation updated

---

### Task 4: Write comprehensive test suite
**Type**: Testing
**Files**: `tests/ComStyleAllMethodsTest.cpp` (new)
**Action**:
- Create test suite specifically for non-virtual method declarations
- Verify declarations for constructors, destructors, regular methods
- Test overloading, const methods, reference parameters

**Test cases**:

**Test 1: Non-virtual methods**
```cpp
TEST(ComStyleAllMethodsTest, NonVirtualMethods) {
    const char* code = R"(
        class Counter {
            int value;
        public:
            Counter(int v) : value(v) {}
            int getValue() const { return value; }
            void increment() { value++; }
        };
    )";

    std::string header = transpileToHeader(code);

    // Verify constructor declaration
    EXPECT_THAT(header, HasSubstr("static void Counter__ctor_1(struct Counter *this, int v)"));

    // Verify method declarations
    EXPECT_THAT(header, HasSubstr("static int Counter_getValue(const struct Counter *this)"));
    EXPECT_THAT(header, HasSubstr("static void Counter_increment(struct Counter *this)"));
}
```

**Test 2: Overloaded constructors**
```cpp
TEST(ComStyleAllMethodsTest, OverloadedConstructors) {
    const char* code = R"(
        class Point {
            int x, y;
        public:
            Point() : x(0), y(0) {}
            Point(int v) : x(v), y(v) {}
            Point(int x_, int y_) : x(x_), y(y_) {}
        };
    )";

    std::string header = transpileToHeader(code);

    // Verify all constructor overloads have declarations
    EXPECT_THAT(header, HasSubstr("static void Point__ctor(struct Point *this)"));
    EXPECT_THAT(header, HasSubstr("static void Point__ctor_1(struct Point *this, int v)"));
    EXPECT_THAT(header, HasSubstr("static void Point__ctor_2(struct Point *this, int x_, int y_)"));
}
```

**Test 3: Overloaded methods**
```cpp
TEST(ComStyleAllMethodsTest, OverloadedMethods) {
    const char* code = R"(
        class Printer {
        public:
            void print(int n) { }
            void print(double d) { }
            void print(const char* s) { }
        };
    )";

    std::string header = transpileToHeader(code);

    EXPECT_THAT(header, HasSubstr("static void Printer_print_int(struct Printer *this, int n)"));
    EXPECT_THAT(header, HasSubstr("static void Printer_print_float(struct Printer *this, double d)"));
    EXPECT_THAT(header, HasSubstr("static void Printer_print(struct Printer *this, const char* s)"));
}
```

**Test 4: Const methods**
```cpp
TEST(ComStyleAllMethodsTest, ConstMethods) {
    const char* code = R"(
        class DataHolder {
            int data;
        public:
            int getData() const { return data; }
            void setData(int d) { data = d; }
        };
    )";

    std::string header = transpileToHeader(code);

    EXPECT_THAT(header, HasSubstr("static int DataHolder_getData(const struct DataHolder *this)"));
    EXPECT_THAT(header, HasSubstr("static void DataHolder_setData(struct DataHolder *this, int d)"));
}
```

**Test 5: Reference parameters**
```cpp
TEST(ComStyleAllMethodsTest, ReferenceParameters) {
    const char* code = R"(
        class Swapper {
        public:
            void swap(int& a, int& b) {
                int temp = a;
                a = b;
                b = temp;
            }
        };
    )";

    std::string header = transpileToHeader(code);

    EXPECT_THAT(header, HasSubstr("static void Swapper_swap(struct Swapper *this, int* a, int* b)"));
}
```

**Verify**:
- âœ… All tests compile
- âœ… All tests pass
- âœ… Test coverage >= 90%
- âœ… Edge cases covered (overloads, const, references)

**Done**: Test suite complete and passing

---

### Task 5: Run full regression test suite
**Type**: Testing
**Files**: All existing test files
**Action**:
- Run complete existing test suite
- Verify 100% pass rate (no regressions)
- Check that generated code compiles without warnings
- Verify no performance degradation

**Test execution**:
```bash
# Build all tests
cd build_working && make -j4

# Run ALL tests
ctest --output-on-failure

# Expected output:
# 100% tests passed, 0 tests failed
```

**Verify**:
- âœ… All existing tests pass (100%)
- âœ… New tests pass (100%)
- âœ… No compiler warnings in generated code
- âœ… Performance unchanged (<1% difference)
- âœ… Memory usage unchanged

**Done**: Full regression suite passes

---

### Task 6: Update documentation
**Type**: Documentation
**Files**: `docs/VTABLE_IMPLEMENTATION.md`, `docs/METHOD_GENERATION.md` (new)
**Action**:
- Update vtable docs to reflect all methods now use COM-style
- Create new document explaining method generation comprehensively
- Update code examples to show all declarations

**METHOD_GENERATION.md structure**:
```markdown
# Method Generation in C

## Overview
All C++ methods (virtual and non-virtual) are translated to C with explicit static function declarations for compile-time type safety.

## Pattern

### C++ Input
```cpp
class Widget {
    int value;
public:
    Widget(int v);
    int getValue() const;
    virtual void update(int v);
};
```

### Generated C Output
```c
// All method declarations (static)
static void Widget__ctor_1(struct Widget *this, int v);
static int Widget_getValue(const struct Widget *this);
static void Widget_update(struct Widget *this, int v);

// Implementations
static void Widget__ctor_1(struct Widget *this, int v) { ... }
static int Widget_getValue(const struct Widget *this) { ... }
static void Widget_update(struct Widget *this, int v) { ... }
```

## Benefits
1. Compile-time signature verification
2. Better debugging (function names visible)
3. Self-documenting code
4. Consistent code style

## Special Cases
- Constructors: `ClassName__ctor[_N]`
- Destructors: `ClassName__dtor`
- Overloaded methods: Append parameter types
- Const methods: `const struct ClassName *this`
```

**Verify**:
- âœ… Documentation comprehensive and accurate
- âœ… Examples compile and run
- âœ… All edge cases documented

**Done**: Documentation complete

---

### Task 7: Commit and release
**Type**: Release
**Files**: All modified files
**Action**:
- Run linters (zero errors/warnings)
- Run full test suite (100% pass)
- Commit with descriptive message
- Tag release: `v2.3.0`
- Push to repository

**Commit message**:
```
feat(methods): extend COM-style declarations to all methods

Extend compile-time type safety pattern from virtual methods (v2.2.0)
to ALL methods for consistency and universal type verification.

Changes:
- CppToCVisitor: Add generateAllMethodDeclarations() for all methods
- MethodSignatureHelper: Extract shared signature generation logic
- VtableGenerator: Refactored to use shared helper (DRY)
- Tests: Add ComStyleAllMethodsTest suite with 5 test cases
- Docs: Add METHOD_GENERATION.md, update VTABLE_IMPLEMENTATION.md

Benefits:
- Universal compile-time type safety (all methods verified)
- Consistent code style (one pattern for everything)
- Simplified generator logic (no special cases)
- Better debugging (all functions have names)

See: .planning/phases/31-com-vmt-architecture/31-01-FINDINGS.md

Closes: Phase 31-03
Version: v2.3.0

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

**Verify**:
- âœ… All linters pass
- âœ… All tests pass (100%)
- âœ… Code compiles without warnings
- âœ… Commit message follows conventions
- âœ… Version tag created
- âœ… Changes pushed

**Done**: Phase 31-03 complete, v2.3.0 released

## Verification Criteria

Phase succeeds when:
- âœ… Static declarations for ALL methods (virtual + non-virtual)
- âœ… Shared signature generation logic (no code duplication)
- âœ… All existing tests pass (no regressions)
- âœ… New test suite >= 90% coverage
- âœ… Documentation complete
- âœ… Code committed and tagged as v2.3.0

## Success Metrics

**Consistency**: 100% of methods use COM-style declarations
**Code Quality**: Zero linter errors/warnings
**Regression**: 100% existing test pass rate
**Performance**: <1% difference from previous version

## Dependencies

**Requires**:
- Completed Phase 31-02 (v2.2.0) - Virtual methods with declarations

**Blocks**:
- Phase 31-04 (cleanup and optimization)
