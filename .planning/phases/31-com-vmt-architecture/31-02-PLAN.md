# Phase 31-02: COM-Style Vtable with Static Declarations (Virtual Methods)

## Objective

Implement COM-style strongly-typed vtables for virtual methods by adding explicit static function declarations, providing compile-time type safety and better debugging.

**Why**: Current vtable implementation lacks compile-time verification that generated function signatures match vtable function pointer types. COM-style static declarations create a safety net that catches generator bugs at compile time instead of runtime.

## Context

**Current Implementation**:
- `src/VtableGenerator.cpp` - Generates vtable structs with function pointers
- `src/VtableInitializer.cpp` - Initializes vtables with function references
- Virtual methods have implicit signatures (no declarations)
- Type checking relies on generator correctness (no safety net)

**COM-Style Pattern**:
```c
// Current (works if generator is perfect)
int Circle_getArea(Circle* this) { ... }
Circle_vtbl.getArea = Circle_getArea;

// COM-style (compiler verifies signatures)
static int Circle_getArea(Circle* this);  // âœ… Declaration
static int Circle_getArea(Circle* this) { ... }  // âœ… Implementation
Circle_vtbl.getArea = Circle_getArea;  // âœ… Compile error if mismatch!
```

**Benefits**:
- âœ… Compile-time type safety (catches signature mismatches)
- âœ… Better debugging (function names in stack traces)
- âœ… Zero runtime overhead
- âœ… Self-documenting code

**Research**: See `.planning/phases/31-com-vmt-architecture/31-01-FINDINGS.md`

**Recent Work**:
- Just completed pointer recursion fix (commit df8e4b9)
- Strong emphasis on type safety throughout project

## Tasks

### Task 1: Add static declaration generation to VtableGenerator
**Type**: Implementation
**Files**: `src/VtableGenerator.cpp`, `include/VtableGenerator.h`
**Action**:
- Add new method: `std::string generateStaticDeclarations(const CXXRecordDecl* Record)`
- For each virtual method in vtable layout:
  - Generate signature: `static ReturnType ClassName_methodName(ClassName* this, params);`
  - Handle special cases: destructors, const methods, reference parameters
  - Use existing `generateFunctionPointer()` logic for signature extraction
- Return formatted string with all declarations
- Add helper: `std::string getMethodSignature(const CXXMethodDecl* Method, const std::string& ClassName)`
  - Extract return type, method name, parameters
  - Build declaration string
  - Handle name mangling for overloaded methods

**Implementation details**:
```cpp
// VtableGenerator.h
class VtableGenerator {
public:
    // Existing methods...
    std::string generateStaticDeclarations(const CXXRecordDecl* Record);

private:
    std::string getMethodSignature(const CXXMethodDecl* Method,
                                   const std::string& ClassName);
};

// VtableGenerator.cpp
std::string VtableGenerator::generateStaticDeclarations(const CXXRecordDecl* Record) {
    if (!Record || !Analyzer.isPolymorphic(Record)) {
        return "";
    }

    std::ostringstream decls;
    std::string className = Record->getNameAsString();
    auto methods = getVtableMethodOrder(Record);

    decls << "// Static declarations for " << className << " virtual methods\n";

    for (auto* method : methods) {
        decls << getMethodSignature(method, className) << ";\n";
    }

    return decls.str();
}

std::string VtableGenerator::getMethodSignature(const CXXMethodDecl* Method,
                                                 const std::string& ClassName) {
    std::ostringstream sig;

    // static keyword
    sig << "static ";

    // Return type
    QualType returnType = Method->getReturnType();
    sig << getTypeString(returnType) << " ";

    // Function name (use name mangler for correct C name)
    if (isa<CXXDestructorDecl>(Method)) {
        sig << ClassName << "__dtor";
    } else {
        // Use existing name mangling logic
        sig << ClassName << "_" << Method->getNameAsString();
        // Handle overloads (append parameter types if needed)
    }

    // Parameters: always starts with 'this' pointer
    sig << "(struct " << ClassName << " *this";

    // Add method parameters
    for (unsigned i = 0; i < Method->getNumParams(); ++i) {
        const ParmVarDecl* param = Method->getParamDecl(i);
        sig << ", ";
        sig << getTypeString(param->getType());
        if (!param->getName().empty()) {
            sig << " " << param->getName().str();
        }
    }

    sig << ")";

    return sig.str();
}
```

**Verify**:
- âœ… `generateStaticDeclarations()` method exists in VtableGenerator
- âœ… Generates declarations for all virtual methods in class
- âœ… Signatures match vtable function pointer types exactly
- âœ… Handles destructors correctly (`ClassName__dtor`)
- âœ… Handles overloaded methods with mangled names
- âœ… Compiles without errors

**Done**: Static declaration generation implemented and tested

---

### Task 2: Integrate declarations into header generation
**Type**: Implementation
**Files**: `src/CppToCVisitor.cpp`, `include/CppToCVisitor.h`
**Action**:
- Locate where vtable structs are generated in header output
- Call `VtableGenerator::generateStaticDeclarations()` BEFORE vtable struct definition
- Insert declarations in appropriate location (after forward declarations, before vtable)
- Ensure declarations appear in generated header file (`.h` output)

**Code changes in CppToCVisitor.cpp**:
```cpp
// Around line where vtable structs are generated
std::string CppToCVisitor::generateClassHeader(CXXRecordDecl* RD) {
    std::ostringstream header;

    // ... existing forward declarations ...

    // NEW: Generate static declarations for virtual methods
    if (VtableGen && VirtualAnalyzer.isPolymorphic(RD)) {
        std::string staticDecls = VtableGen->generateStaticDeclarations(RD);
        if (!staticDecls.empty()) {
            header << "\n" << staticDecls << "\n";
        }
    }

    // ... existing vtable struct generation ...
    if (VtableGen) {
        std::string vtableStruct = VtableGen->generateVtableStruct(RD);
        header << vtableStruct << "\n";
    }

    // ... rest of header generation ...
    return header.str();
}
```

**Verify**:
- âœ… Static declarations appear in generated `.h` files
- âœ… Declarations come BEFORE vtable struct definitions
- âœ… Declarations come AFTER forward declarations
- âœ… Output compiles successfully
- âœ… No duplicate declarations

**Done**: Declarations integrated into header generation

---

### Task 3: Write test suite for signature verification
**Type**: Testing
**Files**: `tests/ComStyleVtableTest.cpp` (new)
**Action**:
- Create new test file for COM-style vtable testing
- Follow TDD: write tests BEFORE modifying existing code
- Test cases:

**Test 1: Simple virtual method**
```cpp
TEST(ComStyleVtableTest, SimpleVirtualMethod) {
    const char* code = R"(
        class Shape {
        public:
            virtual int getArea() = 0;
            virtual ~Shape() {}
        };
    )";

    // Transpile
    std::string header = transpileToHeader(code);

    // Verify declarations exist
    EXPECT_THAT(header, HasSubstr("static int Shape_getArea(struct Shape *this)"));
    EXPECT_THAT(header, HasSubstr("static void Shape__dtor(struct Shape *this)"));

    // Verify declarations come before vtable struct
    size_t declPos = header.find("static int Shape_getArea");
    size_t vtablePos = header.find("struct Shape_vtable");
    EXPECT_LT(declPos, vtablePos);
}
```

**Test 2: Virtual method with parameters**
```cpp
TEST(ComStyleVtableTest, VirtualMethodWithParameters) {
    const char* code = R"(
        class Calculator {
        public:
            virtual int add(int a, int b) = 0;
            virtual double multiply(double x, double y) = 0;
        };
    )";

    std::string header = transpileToHeader(code);

    EXPECT_THAT(header, HasSubstr("static int Calculator_add(struct Calculator *this, int a, int b)"));
    EXPECT_THAT(header, HasSubstr("static double Calculator_multiply(struct Calculator *this, double x, double y)"));
}
```

**Test 3: Inheritance with overrides**
```cpp
TEST(ComStyleVtableTest, InheritanceWithOverrides) {
    const char* code = R"(
        class Base {
        public:
            virtual void method1() = 0;
            virtual int method2() = 0;
        };

        class Derived : public Base {
        public:
            void method1() override { }
            int method2() override { return 42; }
            virtual void method3() { }
        };
    )";

    std::string header = transpileToHeader(code);

    // Base class declarations
    EXPECT_THAT(header, HasSubstr("static void Base_method1(struct Base *this)"));
    EXPECT_THAT(header, HasSubstr("static int Base_method2(struct Base *this)"));

    // Derived class declarations (including inherited + new)
    EXPECT_THAT(header, HasSubstr("static void Derived_method1(struct Derived *this)"));
    EXPECT_THAT(header, HasSubstr("static int Derived_method2(struct Derived *this)"));
    EXPECT_THAT(header, HasSubstr("static void Derived_method3(struct Derived *this)"));
}
```

**Test 4: Signature mismatch detection (compile-time verification)**
```cpp
// This test verifies compile-time type checking
// Create intentional mismatch and verify it's caught
TEST(ComStyleVtableTest, SignatureMismatchDetection) {
    // NOTE: This test should FAIL TO COMPILE if working correctly
    // We'll create a separate test file that we expect to fail compilation

    // For now, document that manual verification is needed:
    // 1. Temporarily modify generator to create wrong signature
    // 2. Attempt to compile transpiled output
    // 3. Verify compiler error message points to signature mismatch

    // This serves as documentation for manual testing procedure
    GTEST_SKIP() << "Manual compile-time verification test - see test comments";
}
```

**Test 5: Multiple inheritance**
```cpp
TEST(ComStyleVtableTest, MultipleInheritance) {
    const char* code = R"(
        class Interface1 {
        public:
            virtual void method1() = 0;
        };

        class Interface2 {
        public:
            virtual void method2() = 0;
        };

        class Implementation : public Interface1, public Interface2 {
        public:
            void method1() override { }
            void method2() override { }
        };
    )";

    std::string header = transpileToHeader(code);

    // Verify all virtual method declarations present
    EXPECT_THAT(header, HasSubstr("static void Interface1_method1"));
    EXPECT_THAT(header, HasSubstr("static void Interface2_method2"));
    EXPECT_THAT(header, HasSubstr("static void Implementation_method1"));
    EXPECT_THAT(header, HasSubstr("static void Implementation_method2"));
}
```

**Verify**:
- âœ… All tests compile
- âœ… All tests pass
- âœ… Test coverage >= 90% for new code
- âœ… Tests follow project conventions (GTest, TDD)

**Done**: Test suite complete and passing

---

### Task 4: Add integration with existing tests
**Type**: Testing
**Files**: Existing test files, `CMakeLists.txt`
**Action**:
- Add `ComStyleVtableTest.cpp` to test build (`tests/CMakeLists.txt`)
- Run full existing test suite to verify no regressions:
  - `VtableGeneratorTest` - Should still pass
  - `VirtualMethodIntegrationTest` - Should still pass
  - `InheritanceTest` - Should still pass
  - All other tests - Should still pass
- Verify transpiled output for existing tests includes static declarations
- Check that generated code compiles and runs correctly

**CMakeLists.txt changes**:
```cmake
# Add new test file
add_executable(ComStyleVtableTest
    tests/ComStyleVtableTest.cpp
    # ... existing source files ...
)

target_link_libraries(ComStyleVtableTest
    gtest
    gtest_main
    # ... existing libraries ...
)

add_test(NAME ComStyleVtableTest COMMAND ComStyleVtableTest)
```

**Verify**:
- âœ… New test builds successfully
- âœ… All existing tests still pass (100% pass rate)
- âœ… No performance regression (<5% slowdown acceptable)
- âœ… Generated C code compiles without warnings
- âœ… Generated C code runs correctly

**Done**: Integration complete, all tests passing

---

### Task 5: Update documentation and examples
**Type**: Documentation
**Files**: `docs/VTABLE_IMPLEMENTATION.md` (new), `README.md`
**Action**:
- Create comprehensive vtable documentation
- Explain COM-style pattern and benefits
- Show before/after examples
- Document type safety guarantees
- Update main README with link to vtable docs

**VTABLE_IMPLEMENTATION.md structure**:
```markdown
# Virtual Method Table (Vtable) Implementation

## Overview
[Explain vtable purpose, Itanium C++ ABI compliance]

## COM-Style Static Declarations

### What It Is
[Explain pattern with code examples]

### Why We Use It
1. **Compile-Time Type Safety**
   [Example of caught error]

2. **Better Debugging**
   [Stack trace comparison]

3. **Self-Documenting Code**
   [Declaration as documentation]

### Example

**C++ Input:**
```cpp
class Shape {
public:
    virtual int getArea() = 0;
};
```

**Generated C Output:**
```c
// Static declarations
static int Shape_getArea(struct Shape *this);

// Vtable structure
typedef struct Shape_vtable {
    int (*getArea)(struct Shape *this);
} Shape_vtable;
```

## Implementation Details
[How generator works, integration points]

## Testing
[How to verify correctness]

## Performance
[Zero runtime overhead explanation]
```

**Verify**:
- âœ… Documentation created and comprehensive
- âœ… Examples are clear and accurate
- âœ… README.md updated with link
- âœ… All code examples compile

**Done**: Documentation complete

---

### Task 6: Commit and release
**Type**: Release
**Files**: All modified files
**Action**:
- Run all linters (zero errors/warnings required)
- Run full test suite (100% pass rate required)
- Commit changes with descriptive message
- Tag release: `v2.2.0`
- Push to repository

**Commit message**:
```
feat(vtable): add COM-style static declarations for virtual methods

Implement compile-time type safety for virtual method tables following
COM/DCOM patterns. Static function declarations ensure generator bugs
are caught at compile time instead of runtime.

Changes:
- VtableGenerator: Add generateStaticDeclarations() method
- CppToCVisitor: Integrate declarations into header generation
- Tests: Add ComStyleVtableTest suite with 5 test cases
- Docs: Add VTABLE_IMPLEMENTATION.md explaining pattern

Benefits:
- Compile-time signature verification (catches generator bugs)
- Better debugging (function names in stack traces)
- Zero runtime overhead
- Self-documenting code

See: .planning/phases/31-com-vmt-architecture/31-01-FINDINGS.md

Closes: Phase 31-02
Version: v2.2.0

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

**Verify**:
- âœ… All linters pass (ESLint, clang-tidy, etc.)
- âœ… All tests pass (100% pass rate)
- âœ… Code compiles without warnings
- âœ… Commit message follows conventions
- âœ… Version tag created
- âœ… Changes pushed to remote

**Done**: Phase 31-02 complete, v2.2.0 released

## Verification Criteria

Phase succeeds when:
- âœ… Static declarations generated for all virtual methods
- âœ… Declarations appear in generated header files
- âœ… Compile-time type checking works (mismatches caught)
- âœ… All existing tests pass (no regressions)
- âœ… New test suite has >= 90% coverage
- âœ… Documentation complete and accurate
- âœ… Zero runtime overhead verified
- âœ… Code committed and tagged as v2.2.0

## Success Metrics

**Type Safety**: Signature mismatches cause compile errors (manually verified)
**Test Coverage**: >= 90% of new code
**Performance**: No measurable runtime overhead
**Code Quality**: Zero linter errors/warnings
**Regression**: 100% existing test pass rate

## Dependencies

**Requires**:
- Completed Phase 30 (transpilation fixes)
- VtableGenerator working correctly
- GTest framework available

**Blocks**:
- Phase 31-03 (extend to all methods)
- Phase 31-04 (cleanup)
