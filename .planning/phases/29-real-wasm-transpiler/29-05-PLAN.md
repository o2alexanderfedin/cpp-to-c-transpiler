# Phase 29-05: Complete Browser-Based Transpiler Implementation

**Created**: 2025-12-23 13:25
**Status**: READY TO EXECUTE
**Goal**: Commit current libclang.wasm success, then implement full browser-based C++ to C transpiler

---

## Context

**Current Achievement**: libclang.wasm successfully built and tested in Node.js
- 32MB WASM module with working libclang C API
- Successfully parsing C++ code and creating AST
- 277 builtin headers packaged and loadable
- Virtual filesystem setup working correctly

**Remaining Work**: Integrate libclang into our transpiler and deploy to browser

---

## Phase 1: Commit & Push Current Success

**Objective**: Save the breakthrough work before continuing

### Task 1.1: Stage and Review Changes
**Verification**: `git status` shows all new files and modifications

Actions:
- Review all changes in libclang-wasm directory
- Review updates to status documentation
- Check for any unintended changes

### Task 1.2: Create Feature Branch
**Verification**: New branch created with descriptive name

Actions:
- Create branch: `feature/29-libclang-wasm-working`
- Checkout the branch

### Task 1.3: Commit with Detailed Message
**Verification**: Commit created with comprehensive message

Commit Message Template:
```
feat(wasm): Successfully build and test libclang.wasm for browser transpilation

BREAKTHROUGH: libclang C API now working in WASM environment

Major Achievements:
- Built libclang.wasm (32MB) with Emscripten
- Applied critical patch for WASM resource path detection
- Packaged 277 Clang builtin headers (7.7MB)
- Created working test demonstrating C++ parsing
- All libclang C API functions accessible from JavaScript

Technical Details:
- Fixed build system using wrong LLVM source directory
- Applied patch to llvm-wasm/llvm/lib/Support/Unix/Path.inc
- Configured Emscripten runtime methods: FS, cwrap, ccall, etc.
- Virtual filesystem pre-populated with headers on load

Files Added:
- libclang-wasm/out/bin/libclang.wasm (32MB)
- libclang-wasm/out/bin/libclang.mjs (339KB)
- libclang-wasm/clang-headers.mjs (7.7MB)
- libclang-wasm/test-libclang.mjs (test script)
- libclang-wasm/package-headers.mjs (packaging script)

Documentation:
- .planning/phases/29-real-wasm-transpiler/29-04-STATUS.md (updated)

Next Steps: Port transpiler to use libclang C API

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

### Task 1.4: Push to Remote
**Verification**: Branch pushed successfully

Actions:
- Push branch to origin
- Verify on GitHub

---

## Phase 2: Architecture Analysis & Design

**Objective**: Understand current transpiler and design libclang integration

### Task 2.1: Analyze Current Transpiler Implementation
**Verification**: Complete understanding of existing code structure

**Subtask**: Explore transpiler source (use Task tool with Explore agent)
- Map out all files in `src/` directory
- Identify main transpiler logic
- Find AST visitor patterns
- Locate C code generation functions
- Document current architecture

**Deliverable**: Architecture summary document

### Task 2.2: Research libclang C API Equivalents
**Verification**: Mapping from LibTooling to libclang completed

**Subtask**: Create API mapping (use Task tool)
- Research libclang AST traversal (`clang_visitChildren`)
- Find equivalents for RecursiveASTVisitor patterns
- Document cursor types and visitor callbacks
- Identify diagnostic handling functions

**Deliverable**: API mapping reference document

### Task 2.3: Design Integration Strategy
**Verification**: Clear plan for porting code

Design Decisions:
1. **Keep or Replace?**
   - Option A: Port existing TranspilerAPI.cpp to libclang C API
   - Option B: Rewrite transpiler logic in JavaScript using libclang bindings
   - **Decision**: Option B (JavaScript) - easier to maintain, better browser integration

2. **Architecture Pattern**:
   ```
   Browser â†’ TypeScript Wrapper â†’ libclang.wasm (C API) â†’ AST â†’ JS Visitor â†’ C Generator
   ```

3. **Code Organization**:
   - `src/libclang-wrapper.ts` - TypeScript bindings for libclang
   - `src/ast-visitor.ts` - AST traversal using clang_visitChildren
   - `src/c-generator.ts` - C code generation (reuse existing logic)
   - `src/transpiler.ts` - Main transpiler orchestration

---

## Phase 3: Create TypeScript libclang Wrapper

**Objective**: Build type-safe TypeScript wrapper around libclang C API

### Task 3.1: Define TypeScript Interfaces
**Verification**: Complete type definitions for libclang API

Files to Create:
- `src/libclang-types.ts` - Core type definitions

Key Types:
```typescript
export interface CXIndex extends Number {}
export interface CXTranslationUnit extends Number {}
export interface CXCursor {
  kind: CXCursorKind;
  // ... other fields
}
export enum CXCursorKind {
  ClassDecl,
  FunctionDecl,
  VarDecl,
  // ... all cursor kinds
}
```

### Task 3.2: Create libclang Loader
**Verification**: WASM module loads with headers

File: `src/libclang-loader.ts`

Functionality:
- Load libclang.wasm and libclang.mjs
- Load clang-headers.mjs
- Populate virtual filesystem with headers
- Create fake executable at /usr/lib/libclang.wasm
- Export initialized Module

### Task 3.3: Create C API Wrapper Functions
**Verification**: All needed libclang functions wrapped with types

File: `src/libclang-wrapper.ts`

Wrap Functions:
- `clang_createIndex()`
- `clang_disposeIndex()`
- `clang_parseTranslationUnit()`
- `clang_disposeTranslationUnit()`
- `clang_visitChildren()`
- `clang_getCursor...()` family
- `clang_getNumDiagnostics()`
- `clang_getDiagnostic()`

---

## Phase 4: Implement AST Visitor

**Objective**: Traverse AST and extract transpilation data

### Task 4.1: Create Visitor Callback System
**Verification**: Visitor can traverse all cursor types

File: `src/ast-visitor.ts`

Pattern:
```typescript
export class ASTVisitor {
  visit(cursor: CXCursor, parent: CXCursor): CXChildVisitResult {
    switch (cursor.kind) {
      case CXCursorKind.ClassDecl:
        return this.visitClassDecl(cursor);
      case CXCursorKind.FunctionDecl:
        return this.visitFunctionDecl(cursor);
      // ... all cases
    }
  }
}
```

### Task 4.2: Extract Information from Cursors
**Verification**: Can extract all needed transpilation data

Extract:
- Class names, members, methods
- Function signatures
- Variable declarations
- Template information
- ACSL annotations (if in comments/attributes)

### Task 4.3: Build Intermediate Representation
**Verification**: IR contains all data for C generation

File: `src/ir-builder.ts`

IR Structure (reuse existing if applicable):
```typescript
interface ClassIR {
  name: string;
  members: MemberIR[];
  methods: MethodIR[];
}
```

---

## Phase 5: Port C Code Generator

**Objective**: Generate C code from IR (reuse existing logic)

### Task 5.1: Analyze Existing C Generator
**Verification**: Understanding of current C generation logic

**Subtask**: Explore C generation code
- Find current C code generation functions
- Identify ACSL generation logic
- Map dependencies

### Task 5.2: Extract Reusable C Generation Logic
**Verification**: C generator works with new IR

Actions:
- Extract C generation functions to `src/c-generator.ts`
- Adapt to work with libclang-based IR
- Preserve ACSL generation logic
- Test with sample IR

---

## Phase 6: Integrate with WASM Bindings

**Objective**: Connect new transpiler to existing WASM interface

### Task 6.1: Update WASM Bindings
**Verification**: WASM bindings call new transpiler

File: `wasm/bindings/full.cpp` (or create new JS wrapper)

Option A: Keep C++ binding, call into libclang.wasm
Option B: Replace with pure JavaScript wrapper

**Decision**: Option B (Pure JavaScript)
- Create `wasm/transpiler-wrapper.ts`
- Export `transpile()` function matching existing interface
- Remove stub C++ implementation

### Task 6.2: Create Main Transpiler Entry Point
**Verification**: Single function transpiles C++ to C

File: `src/transpiler.ts`

```typescript
export async function transpile(
  cppCode: string,
  options: TranspilerOptions
): Promise<TranspilerResult> {
  // 1. Load libclang
  // 2. Create index
  // 3. Parse code to TU
  // 4. Visit AST
  // 5. Build IR
  // 6. Generate C code
  // 7. Return result
}
```

---

## Phase 7: Build & Deploy

**Objective**: Build updated WASM module and deploy to website

### Task 7.1: Update Build Configuration
**Verification**: Build includes all new TypeScript files

Files to Update:
- `tsconfig.json` - Include new source files
- `webpack.config.js` (if exists) - Bundle for browser
- `package.json` - Add any new dependencies

### Task 7.2: Build TypeScript to JavaScript
**Verification**: Clean build with no errors

```bash
npm run build  # or tsc
```

### Task 7.3: Bundle for Browser
**Verification**: Single bundle ready for deployment

Actions:
- Bundle all JavaScript + WASM
- Include clang-headers.mjs in bundle
- Optimize bundle size if needed

### Task 7.4: Copy to Website Public Directory
**Verification**: Files in `website/public/wasm/`

Copy:
- `libclang.wasm` (32MB)
- `libclang.mjs` (339KB)
- `clang-headers.mjs` (7.7MB) or embed in bundle
- Transpiler bundle (transpiler.js)

### Task 7.5: Update Website Integration
**Verification**: Website loads new transpiler

File: `website/src/...` (wherever transpiler is imported)

Update imports to use new transpiler module

---

## Phase 8: Browser Testing

**Objective**: Verify transpiler works in browser with real code

### Task 8.1: Test Simple C++ Code
**Verification**: Basic class transpiles correctly

Test Input:
```cpp
class Point {
public:
  int x, y;
  int getX() { return x; }
};
```

Expected Output: Valid C code with ACSL annotations

### Task 8.2: Test Complex Features
**Verification**: All transpiler features work

Test Cases:
- Templates
- Multiple classes
- Inheritance
- Member functions
- Constructors/destructors
- ACSL annotations

### Task 8.3: Performance Testing
**Verification**: Transpilation completes in <5 seconds

Test:
- Large C++ files
- Measure time from input to output
- Check memory usage

### Task 8.4: Error Handling
**Verification**: Graceful error messages for invalid code

Test:
- Syntax errors
- Unsupported features
- Missing headers

---

## Phase 9: Final Commit & Documentation

**Objective**: Commit completed work and document usage

### Task 9.1: Run Full Test Suite
**Verification**: All tests passing

```bash
npm test
```

### Task 9.2: Update Documentation
**Verification**: README and docs reflect new architecture

Update:
- README.md - New architecture overview
- ARCHITECTURE.md - libclang integration details
- Add usage examples

### Task 9.3: Final Commit
**Verification**: All changes committed

Commit Message:
```
feat(transpiler): Complete browser-based transpiler using libclang.wasm

Replaced stub implementation with real C++ parser using libclang C API

Implementation:
- TypeScript wrapper around libclang C API
- AST visitor extracting transpilation data
- C code generator with ACSL annotations
- Browser-ready bundle with embedded headers

Features:
- Real C++ parsing and AST access
- Support for classes, templates, functions
- ACSL annotation generation
- Works entirely in browser (no backend)

Testing:
- Unit tests for all components
- Integration tests with sample C++ code
- Browser compatibility verified

Performance:
- <5 seconds for typical files
- 32MB WASM + 7.7MB headers (first load)
- Subsequent uses cached

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

### Task 9.4: Push and Create PR (if applicable)
**Verification**: Code on GitHub, ready for review

---

## Parallel Execution Strategy

### Parallel Stream 1: Documentation & Commit (Phase 1)
- Can run independently first
- Fast to complete

### Parallel Stream 2: Analysis (Phase 2)
- Run all research tasks in parallel:
  - Current transpiler analysis
  - libclang API research
  - Design decisions

### Parallel Stream 3: Implementation (Phases 3-6)
Can parallelize within each phase:
- Phase 3: Create all TypeScript files in parallel (types, loader, wrapper)
- Phase 4: Visitor system + IR builder in parallel
- Phase 5: Can start while Phase 4 in progress
- Phase 6: Integration starts when Phase 5 has usable output

### Parallel Stream 4: Testing & Deploy (Phases 7-9)
- Run tests in parallel with documentation
- Deploy and test simultaneously on multiple browsers

---

## Risk Mitigation

### Risk 1: libclang API Complexity
**Mitigation**: Start with simple test case, expand gradually
**Fallback**: Simplify transpiler features if needed

### Risk 2: Large Bundle Size (32MB + 7.7MB)
**Mitigation**:
- Use lazy loading for headers
- Enable WASM streaming compilation
- Add progress indicators
**Acceptable**: First load slower, cached afterward

### Risk 3: Browser Compatibility
**Mitigation**:
- Test on Chrome, Firefox, Safari
- Use WebAssembly feature detection
- Provide fallback error message

### Risk 4: Performance Issues
**Mitigation**:
- Profile and optimize hot paths
- Consider Web Workers for parsing
- Add timeout limits

---

## Success Criteria

- [ ] Current work committed and pushed
- [ ] libclang.wasm integrated into transpiler
- [ ] All TypeScript code written and type-safe
- [ ] AST visitor extracts all needed data
- [ ] C code generator produces valid output
- [ ] ACSL annotations present in output
- [ ] Website loads and uses new transpiler
- [ ] Sample C++ code transpiles correctly in browser
- [ ] No stub/placeholder code remaining
- [ ] Performance acceptable (<5s for typical files)
- [ ] Tests passing
- [ ] Documentation updated
- [ ] Final commit pushed

---

## Timeline Estimate

**Phase 1** (Commit): 30 minutes
**Phase 2** (Analysis): 1-2 hours (parallel research)
**Phase 3** (Wrapper): 2-3 hours
**Phase 4** (Visitor): 3-4 hours
**Phase 5** (Generator): 1-2 hours (reusing existing)
**Phase 6** (Integration): 1-2 hours
**Phase 7** (Build): 1 hour
**Phase 8** (Testing): 2-3 hours
**Phase 9** (Documentation): 1 hour

**Total Estimated**: 12-18 hours (can compress with parallelization)

---

**Status**: Ready to execute
**Next Action**: Begin Phase 1 - Commit current success
