# Phase 46 Plan: Multiple Inheritance with Multiple Vtables

**Phase**: 46 (Multiple Inheritance)
**Prerequisite**: Phase 45 (Virtual Methods COM-Style)
**Status**: PLANNING
**Target**: Implement C++ multiple inheritance using multiple lpVtbl pointers with COM-style pattern

## Phase Goal

Extend Phase 45's single inheritance COM-style vtables to support multiple inheritance. Generate multiple lpVtbl pointers (lpVtbl, lpVtbl2, lpVtbl3, etc.) for each base class, implement this-pointer adjustment thunks for non-primary bases, and ensure proper vtable initialization in constructors.

## Multiple Inheritance Pattern Overview

When a C++ class inherits from multiple classes with virtual methods, we need:
1. **Multiple lpVtbl pointers** - one per polymorphic base class
2. **This-pointer adjustment** - thunks to adjust `this` when calling non-primary base methods
3. **Vtable layout** - each base gets its own vtable struct in the derived class
4. **Constructor initialization** - all lpVtbl pointers initialized in order

### Pattern Example

**C++ Source:**
```cpp
class IDrawable {
public:
    virtual void draw() = 0;
};

class ISerializable {
public:
    virtual void serialize() = 0;
};

class Shape : public IDrawable, public ISerializable {
    int x, y;
public:
    Shape(int x, int y) : x(x), y(y) {}
    void draw() override { /* ... */ }
    void serialize() override { /* ... */ }
};
```

**Generated C (Multiple Inheritance Pattern):**
```c
/* Forward declarations */
struct IDrawable;
struct ISerializable;
struct Shape;

/* IDrawable vtable and struct (primary base) */
typedef void (*IDrawable_draw_fn)(struct IDrawable *this);

struct IDrawable_vtable {
    IDrawable_draw_fn draw;
};

struct IDrawable {
    const struct IDrawable_vtable *lpVtbl;
};

/* ISerializable vtable and struct (non-primary base) */
typedef void (*ISerializable_serialize_fn)(struct ISerializable *this);

struct ISerializable_vtable {
    ISerializable_serialize_fn serialize;
};

struct ISerializable {
    const struct ISerializable_vtable *lpVtbl;
};

/* Shape vtables (one per base) */
typedef void (*Shape_draw_fn)(struct Shape *this);
typedef void (*Shape_serialize_fn)(struct Shape *this);

struct Shape_IDrawable_vtable {
    Shape_draw_fn draw;
};

struct Shape_ISerializable_vtable {
    Shape_serialize_fn serialize;
};

/* Shape struct with multiple lpVtbl pointers */
struct Shape {
    const struct Shape_IDrawable_vtable *lpVtbl;     /* Primary base (IDrawable) */
    const struct Shape_ISerializable_vtable *lpVtbl2; /* Non-primary base (ISerializable) */
    int x;
    int y;
};

/* Shape method implementations */
void Shape_draw(struct Shape *this) {
    /* Implementation */
}

void Shape_serialize(struct Shape *this) {
    /* Implementation */
}

/* Thunk for ISerializable calls - adjusts this pointer */
void Shape_serialize_thunk(struct ISerializable *this_as_ISerializable) {
    /* Calculate original Shape* by subtracting offset */
    struct Shape *this = (struct Shape *)((char *)this_as_ISerializable -
                                          offsetof(struct Shape, lpVtbl2));
    Shape_serialize(this);
}

/* Vtable instances */
static const struct Shape_IDrawable_vtable Shape_IDrawable_vtable_instance = {
    .draw = (Shape_draw_fn)Shape_draw
};

static const struct Shape_ISerializable_vtable Shape_ISerializable_vtable_instance = {
    .serialize = (Shape_serialize_fn)Shape_serialize_thunk  /* Uses thunk! */
};

/* Constructor - initializes BOTH lpVtbl pointers */
void Shape_init(struct Shape *this, int x, int y) {
    this->lpVtbl = &Shape_IDrawable_vtable_instance;    /* Primary base */
    this->lpVtbl2 = &Shape_ISerializable_vtable_instance; /* Non-primary base */
    this->x = x;
    this->y = y;
}

/* Polymorphic calls work through correct vtable */
void test_multiple_inheritance() {
    struct Shape shape;
    Shape_init(&shape, 10, 20);

    /* Call through primary base (IDrawable) - no adjustment needed */
    struct IDrawable *drawable = (struct IDrawable *)&shape;
    drawable->lpVtbl->draw(drawable); /* Calls Shape_draw directly */

    /* Call through non-primary base (ISerializable) - uses thunk */
    struct ISerializable *serializable = (struct ISerializable *)
        ((char *)&shape + offsetof(struct Shape, lpVtbl2));
    serializable->lpVtbl->serialize(serializable); /* Calls Shape_serialize_thunk */
}
```

## Key Concepts

### Primary vs Non-Primary Bases
- **Primary base**: First polymorphic base class (uses `lpVtbl`)
- **Non-primary bases**: Subsequent polymorphic bases (use `lpVtbl2`, `lpVtbl3`, etc.)
- Only non-primary bases need this-pointer adjustment

### This-Pointer Adjustment
When calling a method through a non-primary base pointer:
1. The pointer points to the base subobject (offset from start of derived object)
2. The thunk adjusts the pointer back to the start of the derived object
3. The actual method is called with the correct derived object pointer

### Vtable Layout
Each base class gets its own vtable struct:
- `Shape_IDrawable_vtable` for primary base
- `Shape_ISerializable_vtable` for non-primary base
- Each contains function pointers matching the base interface

## Implementation Tasks

### Group 1: Multiple lpVtbl Field Injection (3 tasks - 2 parallel + 1)

**Task 1: Base Class Analysis** (Est. 2-3 hours)
- Create `MultipleInheritanceAnalyzer` helper class
- Analyze CXXRecordDecl to identify all polymorphic bases
- Determine primary vs non-primary bases
- Calculate base class offsets
- **Tests** (8-10 tests):
  - Detect multiple polymorphic bases
  - Identify primary base (first)
  - Identify non-primary bases (rest)
  - Calculate base offsets correctly
  - Handle single inheritance (no change)
  - Handle non-polymorphic bases (skip)
  - Handle mixed polymorphic/non-polymorphic
  - Handle deep inheritance hierarchy

**Task 2: Multiple Vtable Type Generator** (Est. 2-3 hours) - PARALLEL with Task 1
- Extend `VtableGenerator` to create vtable struct per base
- Pattern: `ClassName_BaseName_vtable`
- Generate separate vtable for each polymorphic base
- **Tests** (10-12 tests):
  - Generate vtable for primary base
  - Generate vtable for non-primary base
  - Multiple vtables for multiple bases
  - Vtable naming convention correct
  - Each vtable has correct methods
  - Override methods in correct vtables
  - Empty base vtable (pure virtual)
  - Deep hierarchy vtables
  - Method signature compatibility

**Task 3: Multiple lpVtbl Field Injection** (Est. 2-3 hours) - DEPENDS on Task 1
- Extend `VptrInjector` to inject multiple lpVtbl fields
- Primary base uses `lpVtbl`, others use `lpVtbl2`, `lpVtbl3`, etc.
- Maintain correct field order (lpVtbl pointers first)
- **Tests** (10-12 tests):
  - Inject lpVtbl for primary base
  - Inject lpVtbl2 for first non-primary base
  - Inject lpVtbl3 for second non-primary base
  - Correct field naming (lpVtbl, lpVtbl2, lpVtbl3)
  - Correct field order (all lpVtbl* first)
  - Single inheritance still uses lpVtbl only
  - Fields after all lpVtbl pointers
  - Const correctness on all lpVtbl pointers

### Group 2: This-Pointer Adjustment/Thunks (3 tasks - 2 parallel + 1)

**Task 4: Offset Calculator** (Est. 2-3 hours)
- Create `BaseOffsetCalculator` helper class
- Calculate offsetof(Derived, lpVtbl2) for each non-primary base
- Use Clang's ASTRecordLayout API
- **Tests** (6-8 tests):
  - Calculate offset for lpVtbl2
  - Calculate offset for lpVtbl3
  - Offset is zero for primary base
  - Offset accounts for previous lpVtbl pointers
  - Offset calculation with fields
  - Deep inheritance offset calculation
  - Multiple non-primary bases offsets

**Task 5: Thunk Generator** (Est. 3-4 hours) - PARALLEL with Task 4
- Create `ThunkGenerator` helper class
- Generate thunk functions for non-primary base methods
- Pattern: `ClassName_methodName_thunk`
- Thunk adjusts `this` pointer and calls real method
- **Tests** (12-15 tests):
  - Generate thunk for non-primary base method
  - Thunk naming convention correct
  - Thunk adjusts this pointer correctly
  - Thunk calls real method
  - Thunk with parameters
  - Thunk with return value
  - Multiple thunks for multiple methods
  - Primary base methods need no thunks
  - Thunk signature matches base interface
  - Thunk for overridden method
  - Thunk for pure virtual implementation

**Task 6: Vtable Instance with Thunks** (Est. 2-3 hours) - DEPENDS on Tasks 4, 5
- Extend `VtableGenerator` to use thunks in non-primary vtables
- Primary base vtable uses direct function pointers
- Non-primary base vtables use thunk function pointers
- **Tests** (8-10 tests):
  - Primary vtable has direct pointers
  - Non-primary vtable has thunk pointers
  - Multiple non-primary vtables with thunks
  - Thunk pointers have correct type
  - Vtable instance initialization correct
  - Static const vtable instances
  - All methods in vtable have correct entry

### Group 3: Constructor Multiple lpVtbl Init (2 tasks - parallel)

**Task 7: Multiple Vtable Initialization** (Est. 2-3 hours)
- Extend `VtableInitializer` to initialize all lpVtbl pointers
- Initialize in order: lpVtbl, lpVtbl2, lpVtbl3, ...
- Must be first statements in constructor
- **Tests** (10-12 tests):
  - Initialize lpVtbl in constructor
  - Initialize lpVtbl2 in constructor
  - Initialize lpVtbl3 in constructor
  - Initialization order is correct
  - All vtable pointers initialized before fields
  - Multiple constructors all initialize
  - Derived class constructor initializes all
  - Vtable pointers point to correct instances
  - Default constructor initialization
  - Parameterized constructor initialization

**Task 8: Base Constructor Chaining** (Est. 2-3 hours) - PARALLEL with Task 7
- Handle base class constructor calls in derived constructor
- Each base constructor initializes its own lpVtbl
- Derived constructor overrides with its own vtables
- **Tests** (8-10 tests):
  - Base constructor initializes lpVtbl
  - Derived constructor overrides lpVtbl
  - Multiple bases all initialized
  - Constructor call order correct
  - Virtual base constructor handling
  - Deep hierarchy constructor chain
  - Constructor with initialization list

### Group 4: Virtual Call Routing (3 tasks - 2 parallel + 1)

**Task 9: Base Cast Detection** (Est. 2-3 hours)
- Extend `ExpressionHandler` to detect casts to base classes
- Identify which base class (primary or non-primary)
- Calculate offset adjustment for cast
- **Tests** (8-10 tests):
  - Detect cast to primary base
  - Detect cast to non-primary base
  - Calculate offset for cast
  - Static cast to base
  - Reinterpret cast to base
  - Implicit cast to base
  - Cast in function call
  - Cast in assignment

**Task 10: Virtual Call Through Base Pointer** (Est. 3-4 hours) - PARALLEL with Task 9
- Extend `VirtualCallTranslator` to route calls through correct lpVtbl
- Primary base uses `obj->lpVtbl->method(obj)`
- Non-primary base uses `obj->lpVtbl2->method(obj)` or `lpVtbl3`, etc.
- **Tests** (15-18 tests):
  - Virtual call through primary base pointer
  - Virtual call through non-primary base pointer
  - Virtual call with lpVtbl2
  - Virtual call with lpVtbl3
  - Polymorphic call through base array
  - Multiple calls through different bases
  - Call with parameters through non-primary
  - Call with return value through non-primary
  - Chained calls through multiple bases
  - Virtual call in loop through base pointer
  - Virtual call through reference
  - Mixed primary/non-primary calls

**Task 11: Base Pointer Adjustment** (Est. 2-3 hours) - DEPENDS on Tasks 9, 10
- Generate correct pointer arithmetic for base casts
- Pattern: `(Base*)((char*)derived + offset)`
- Handle both directions: derived->base and base->derived
- **Tests** (8-10 tests):
  - Upcast to primary base (no adjustment)
  - Upcast to non-primary base (with adjustment)
  - Downcast from base to derived
  - Crosscast between bases
  - Pointer adjustment in assignment
  - Pointer adjustment in function call
  - Offset calculation correct
  - Multiple levels of adjustment

### Group 5: Integration & E2E (2 tasks - sequential)

**Task 12: Integration Tests** (Est. 4-5 hours)
- Create `tests/integration/handlers/MultipleInheritanceIntegrationTest.cpp`
- Test complete multiple inheritance pipeline
- **Tests** (35-40 tests):
  - Simple two-base multiple inheritance
  - Three-base multiple inheritance
  - Four-base multiple inheritance
  - Mixed polymorphic/non-polymorphic bases
  - Deep hierarchy with multiple inheritance
  - Diamond pattern (prepare for Phase 47)
  - Virtual method override in multiple bases
  - Pure virtual in multiple bases
  - Constructor initialization of all vtables
  - Destructor cleanup (future)
  - Polymorphic call through primary base
  - Polymorphic call through non-primary base
  - Cast from derived to primary base
  - Cast from derived to non-primary base
  - Cast between bases (crosscast)
  - Method call with parameters through base
  - Method call with return through base
  - Multiple methods per base
  - Override in derived class
  - Inherited virtual methods
  - Mixed virtual/non-virtual methods
  - Thunk generation verification
  - Offset calculation verification
  - Vtable instance verification
  - Field layout verification

**Task 13: E2E Tests** (Est. 3-4 hours) - SEQUENTIAL after Task 12
- Create `tests/e2e/phase46/MultipleInheritanceE2ETest.cpp`
- Compile and execute generated C code
- **Tests** (15 tests):
  - 2 active sanity tests
  - 3-4 active tests (real algorithms)
  - 10-11 disabled algorithm tests:
    - Drawable + Serializable Shape
    - Multiple interface implementation (Plugin system)
    - Observer + Subject (multi-interface)
    - Iterator + Container
    - Reader + Writer file handler
    - GUI widget with multiple traits
    - Network socket (Readable + Writable)
    - Game entity (Renderable + Collidable + Updatable)
    - Logger with multiple outputs
    - State machine with multiple states

## Execution Strategy

### Parallel Execution Groups

**Group 1 (Tasks 1-3)**: Multiple lpVtbl Field Injection
- Task 1 (Base Analysis) + Task 2 (Vtable Gen) in parallel - ~2-3 hours
- Task 3 (Field Injection) sequential after Task 1 - ~2-3 hours
- **Total: ~4-6 hours**

**Group 2 (Tasks 4-6)**: This-Pointer Adjustment/Thunks
- Task 4 (Offset Calc) + Task 5 (Thunk Gen) in parallel - ~3-4 hours
- Task 6 (Vtable with Thunks) sequential after 4,5 - ~2-3 hours
- **Total: ~5-7 hours**

**Group 3 (Tasks 7-8)**: Constructor Multiple lpVtbl Init
- Task 7 (Vtable Init) + Task 8 (Base Ctor Chain) in parallel - ~2-3 hours
- **Total: ~2-3 hours**

**Group 4 (Tasks 9-11)**: Virtual Call Routing
- Task 9 (Cast Detection) + Task 10 (Virtual Call) in parallel - ~3-4 hours
- Task 11 (Pointer Adjustment) sequential after 9,10 - ~2-3 hours
- **Total: ~5-7 hours**

**Group 5 (Tasks 12-13)**: Integration & E2E
- Task 12 (Integration) - ~4-5 hours
- Task 13 (E2E) sequential after 12 - ~3-4 hours
- **Total: ~7-9 hours**

**Overall Estimated Time:**
- Parallel: ~23-32 hours
- Sequential: ~40-55 hours
- **Time Savings: ~40-45%**

## Files to Create

1. `include/MultipleInheritanceAnalyzer.h` - Analyze multiple bases
2. `src/MultipleInheritanceAnalyzer.cpp` - Implementation
3. `tests/unit/MultipleInheritanceAnalyzerTest.cpp` - Unit tests
4. `include/BaseOffsetCalculator.h` - Calculate base offsets
5. `src/BaseOffsetCalculator.cpp` - Implementation
6. `tests/unit/BaseOffsetCalculatorTest.cpp` - Unit tests
7. `include/ThunkGenerator.h` - Generate this-adjustment thunks
8. `src/ThunkGenerator.cpp` - Implementation
9. `tests/unit/ThunkGeneratorTest.cpp` - Unit tests
10. `tests/integration/handlers/MultipleInheritanceIntegrationTest.cpp` - Integration tests
11. `tests/e2e/phase46/MultipleInheritanceE2ETest.cpp` - E2E tests
12. `.planning/phases/46-multiple-inheritance/PHASE46-COMPLETE.md` - Summary doc

## Files to Modify

1. `include/VptrInjector.h` - Add multiple lpVtbl injection
2. `src/VptrInjector.cpp` - Implement multiple lpVtbl fields
3. `include/VtableGenerator.h` - Add per-base vtable generation
4. `src/VtableGenerator.cpp` - Generate vtable per base
5. `include/VtableInitializer.h` - Add multiple vtable initialization
6. `src/VtableInitializer.cpp` - Initialize all lpVtbl pointers
7. `include/VirtualCallTranslator.h` - Add base pointer routing
8. `src/VirtualCallTranslator.cpp` - Route calls through correct lpVtbl
9. `include/handlers/ExpressionHandler.h` - Add base cast handling
10. `src/handlers/ExpressionHandler.cpp` - Implement base cast offset
11. `CMakeLists.txt` - Add new test targets

## Success Criteria

- [ ] All 80-90 unit tests pass (100%)
- [ ] All 35-40 integration tests pass (100%)
- [ ] 2-4 E2E active tests pass (100%)
- [ ] Multiple lpVtbl pointers generated (lpVtbl, lpVtbl2, lpVtbl3)
- [ ] This-pointer adjustment thunks generated for non-primary bases
- [ ] All vtable pointers initialized in constructor
- [ ] Virtual calls route through correct lpVtbl
- [ ] Base casts calculate correct offsets
- [ ] Generated C code compiles without warnings
- [ ] Code follows SOLID principles
- [ ] TDD followed throughout
- [ ] COM pattern compliance maintained

## Test Count Targets

- **Group 1 Tests**: 28-34 tests (Base Analysis 8-10, Vtable Gen 10-12, Field Injection 10-12)
- **Group 2 Tests**: 26-33 tests (Offset Calc 6-8, Thunk Gen 12-15, Vtable+Thunks 8-10)
- **Group 3 Tests**: 18-22 tests (Vtable Init 10-12, Base Ctor 8-10)
- **Group 4 Tests**: 31-38 tests (Cast Detection 8-10, Virtual Call 15-18, Pointer Adj 8-10)
- **Group 5 Tests**: 50 tests (Integration 35-40, E2E 15)
- **Total: 153-177 tests** (target 80-100 active, rest can be disabled for complex scenarios)

## Dependencies

**Requires:**
- Phase 45 (Virtual Methods COM-Style) - COMPLETE
- VirtualMethodAnalyzer - detect polymorphic classes
- VtableGenerator - generate vtable structs
- VptrInjector - inject lpVtbl field
- VtableInitializer - initialize vtable in constructor
- VirtualCallTranslator - translate virtual calls
- ExpressionHandler - method call translation

**External:**
- Clang AST API for inheritance analysis
- Clang ASTRecordLayout for offset calculation
- Google Test framework
- CMake build system

## Risk Mitigation

**Risk 1: Offset Calculation Complexity**
- Mitigation: Use Clang's ASTRecordLayout::getFieldOffset()
- Fallback: Manual calculation based on pointer size
- Test: Comprehensive offset calculation tests

**Risk 2: Thunk Generation Complexity**
- Mitigation: Simple pattern-based generation
- Test: Verify thunks with integration tests
- Document: Clear examples in code

**Risk 3: Virtual Inheritance (Diamond Problem)**
- Mitigation: Explicitly NOT supported in Phase 46
- Defer to Phase 47
- Test: Skip or error on virtual inheritance

**Risk 4: Cross-Cast Complexity**
- Mitigation: Simple offset arithmetic
- Test: Dedicated cross-cast tests
- Document: Limitations if any

## Naming Conventions

### Multiple lpVtbl Pointers
- Primary base: `lpVtbl` (unchanged from Phase 45)
- First non-primary: `lpVtbl2`
- Second non-primary: `lpVtbl3`
- Third non-primary: `lpVtbl4`
- etc.

### Vtable Structs (per-base)
- Pattern: `ClassName_BaseName_vtable`
- Example: `Shape_IDrawable_vtable`, `Shape_ISerializable_vtable`
- Primary base may omit base name: `Shape_vtable` (backward compatible)

### Vtable Instances (per-base)
- Pattern: `ClassName_BaseName_vtable_instance`
- Example: `Shape_IDrawable_vtable_instance`

### Thunk Functions
- Pattern: `ClassName_methodName_thunk`
- Example: `Shape_serialize_thunk`
- Thunk signature matches base class method signature

### Offset Macros (if needed)
- Pattern: `OFFSET_ClassName_BaseName`
- Example: `OFFSET_Shape_ISerializable`

## Next Steps After Completion

**Phase 47: Virtual Inheritance (Diamond Problem)** - Est. 25-30 hours
- Virtual base tables (VTT)
- Virtual base pointers (vbptr)
- Single shared base instance
- Complex offset calculations

**Phase 48: RTTI for Multiple Inheritance** - Est. 15-20 hours
- Type info for multiple bases
- Dynamic cast with offset adjustment
- Type hierarchy with multiple paths

## References

### Multiple Inheritance Patterns
- [Multiple Inheritance in C - Stack Overflow](https://stackoverflow.com/questions/10067510/multiple-inheritance-in-c)
- [COM IUnknown Pattern](https://learn.microsoft.com/en-us/windows/win32/com/implementing-iunknown)
- [GCC Multiple Inheritance ABI](https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable)

### Technical Resources
- [Thunks in Multiple Inheritance - Raymond Chen](https://devblogs.microsoft.com/oldnewthing/20040209-00/?p=40713)
- [C++ Object Layout - Chen Fengfan](https://chen-fengfan.github.io/cpp-object-layout/)
- [Clang ASTRecordLayout Documentation](https://clang.llvm.org/doxygen/classclang_1_1ASTRecordLayout.html)

---

**Created**: 2025-12-26
**Status**: READY FOR IMPLEMENTATION
**Pattern**: COM-style with multiple lpVtbl pointers and this-adjustment thunks
