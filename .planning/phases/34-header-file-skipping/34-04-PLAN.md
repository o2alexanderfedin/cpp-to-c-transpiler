# Phase 34-04: Multi-File Output Generation

**Phase**: 34 - Fix Header File Skipping (v2.5.0)
**Plan**: 34-04 - Multi-File Output Generation
**Type**: Implementation (TDD)
**Estimated Effort**: 1-2 days

---

## Objective

Implement multi-file output generation using FileOriginTracker to route declarations to correct output files, enabling complete multi-file C++ project transpilation with proper header/implementation separation.

**Why This Matters**: This completes the multi-file transpilation pipeline. Without this, FileOriginTracker integration (Phase 34-03) enables header processing but all output still goes to a single file pair. This phase enables generating separate .h/.c files for each user header.

---

## Context

**From Phase 34-03 Summary**:
- FileOriginTracker successfully integrated (8/12 isInMainFile() replacements)
- Transpiler can now process user headers (not just main file)
- Next step: Route declarations to correct output files based on origin

**From Phase 34-01 Research** (`.planning/phases/34-header-file-skipping/34-01-FINDINGS.md`):
- FileOutputManager designed for single .h/.c pair output
- Needs extension to support multiple output file pairs
- `getUserHeaderFiles()` and `getDeclarationsFromFile()` APIs ready for use

**Design Principles**:
- TDD: Write tests for multi-file output scenarios
- SOLID: Extend FileOutputManager without breaking existing API
- KISS: Simple iteration over user headers
- DRY: Reuse existing path calculation and file writing logic
- Emergent Design: Let output routing patterns emerge from tests

**Files to Modify**:
- `include/FileOutputManager.h` - Add multi-file output methods
- `src/FileOutputManager.cpp` - Implement multi-file generation
- `src/CppToCConsumer.cpp` - Use multi-file output when user headers present
- `tests/FileOutputManagerTest.cpp` - Add multi-file test cases

---

## Tasks

### Task 1: Design Multi-File Output API (TDD - Red Phase)

**What to do**:
1. Read `include/FileOutputManager.h` and `src/FileOutputManager.cpp`
2. Design new API methods for multi-file output:
   ```cpp
   class FileOutputManager {
   public:
     // Existing single-file API (backward compatible)
     void writeFiles(const std::string &headerContent,
                     const std::string &implContent);

     // NEW: Multi-file output API
     struct FileContent {
       std::string originFile;  // Original source file (e.g., "Point.h")
       std::string headerContent;
       std::string implContent;
     };

     void writeMultiFileOutput(const std::vector<FileContent> &files);

     // Helper to determine output path for a specific source file
     std::string calculateOutputPathForFile(const std::string &sourceFile,
                                            bool isHeader) const;
   };
   ```
3. Write failing test in `tests/FileOutputManagerTest.cpp`:
   ```cpp
   TEST(FileOutputManagerTest, WritesMultipleOutputFilePairs) {
     // Given: Multiple FileContent entries (Point.h, Point.cpp, main.cpp)
     // When: writeMultiFileOutput() called
     // Then:
     //   - Point.h â†’ Point_transpiled.h + Point_transpiled.c
     //   - Point.cpp â†’ Point_transpiled.h + Point_transpiled.c (merged)
     //   - main.cpp â†’ main_transpiled.h + main_transpiled.c
   }
   ```
4. Verify test compiles but fails (no implementation)

**Verification**:
- âœ… Multi-file output API designed and declared in header
- âœ… Test written and compiles
- âœ… Test fails (expected - no implementation)

---

### Task 2: Implement Multi-File Output (TDD - Green Phase)

**What to do**:
1. Implement `calculateOutputPathForFile()`:
   ```cpp
   std::string FileOutputManager::calculateOutputPathForFile(
       const std::string &sourceFile, bool isHeader) const {
     // Use existing calculateOutputPath() logic
     // Strip .cpp/.h extension, add _transpiled.h or _transpiled.c
     // Preserve directory structure if sourceDir set
   }
   ```
2. Implement `writeMultiFileOutput()`:
   ```cpp
   void FileOutputManager::writeMultiFileOutput(
       const std::vector<FileContent> &files) {
     // For each FileContent:
     //   1. Calculate output paths (header + impl)
     //   2. Write header content to .h file
     //   3. Write impl content to .c file
     //   4. Use existing writeFile() helper
   }
   ```
3. Handle file merging (Point.h + Point.cpp â†’ single output pair):
   - Group by base filename (Point.h and Point.cpp â†’ "Point")
   - Merge header content from all sources
   - Merge impl content from all sources
4. Run test - should pass now

**Verification**:
- âœ… Implementation complete
- âœ… Test passes (TDD green)
- âœ… Multi-file output works
- âœ… File merging works correctly

---

### Task 3: Integrate with CppToCConsumer (TDD)

**What to do**:
1. Read `src/CppToCConsumer.cpp`
2. Modify output generation to use multi-file when user headers present:
   ```cpp
   void CppToCConsumer::HandleTranslationUnit(ASTContext &Context) {
     // ... existing traversal ...

     // NEW: Check if multi-file output needed
     auto userHeaders = fileOriginTracker.getUserHeaderFiles();

     if (userHeaders.empty()) {
       // Single-file mode (existing behavior)
       fileOutputManager.writeFiles(headerContent, implContent);
     } else {
       // Multi-file mode (new behavior)
       std::vector<FileOutputManager::FileContent> files;

       // For each user header + main file:
       for (const auto &headerPath : userHeaders) {
         auto decls = fileOriginTracker.getDeclarationsFromFile(headerPath);
         // Generate header/impl content for these declarations
         FileContent fc;
         fc.originFile = headerPath;
         fc.headerContent = generateHeaderFor(decls);
         fc.implContent = generateImplFor(decls);
         files.push_back(fc);
       }

       // Add main file
       auto mainDecls = fileOriginTracker.getDeclarationsFromFile(mainFile);
       FileContent mainFC;
       mainFC.originFile = mainFile;
       mainFC.headerContent = generateHeaderFor(mainDecls);
       mainFC.implContent = generateImplFor(mainDecls);
       files.push_back(mainFC);

       fileOutputManager.writeMultiFileOutput(files);
     }
   }
   ```
3. Implement helper methods: `generateHeaderFor()`, `generateImplFor()`
4. Write integration test

**Verification**:
- âœ… CppToCConsumer detects user headers
- âœ… Routes to multi-file output when appropriate
- âœ… Falls back to single-file for simple cases
- âœ… Integration test passes

---

### Task 4: Handle Header Dependencies and Include Directives

**What to do**:
1. Analyze dependency graph:
   - If Point.cpp includes Point.h â†’ transpiled main.c should include Point.h
   - If main.cpp includes Point.h â†’ transpiled main.c should include Point_transpiled.h
2. Implement include directive generation:
   ```cpp
   std::string generateIncludes(const std::vector<std::string> &dependencies) {
     std::string includes;
     for (const auto &dep : dependencies) {
       std::string transpiledName = dep;
       // Transform Point.h â†’ Point_transpiled.h
       includes += "#include \"" + transpiledName + "\"\n";
     }
     return includes;
   }
   ```
3. Add to header content generation
4. Test with Point.h/Point.cpp/main.cpp example

**Verification**:
- âœ… Include directives generated correctly
- âœ… Dependency order preserved
- âœ… Circular dependencies handled
- âœ… Test passes

---

### Task 5: Test with Real Multi-File Project (Integration)

**What to do**:
1. Use test case: `tests/multi-file-transpilation/01-simple-class/`
   - Point.h (class declaration)
   - Point.cpp (constructor implementation)
   - main.cpp (usage)
2. Run full transpilation:
   ```bash
   ./cpptoc tests/multi-file-transpilation/01-simple-class/*.cpp \
     --output-dir output/ \
     --source-dir tests/multi-file-transpilation/01-simple-class/
   ```
3. Verify output structure:
   ```
   output/
   â”œâ”€â”€ Point_transpiled.h
   â”œâ”€â”€ Point_transpiled.c
   â”œâ”€â”€ main_transpiled.h
   â””â”€â”€ main_transpiled.c
   ```
4. Compile transpiled C code:
   ```bash
   gcc -o test_point output/Point_transpiled.c output/main_transpiled.c
   ./test_point
   ```
5. Verify execution matches C++ original

**Verification**:
- âœ… Multi-file transpilation produces correct output structure
- âœ… Generated C code compiles without errors
- âœ… Execution matches C++ behavior
- âœ… All declarations routed to correct files

---

### Task 6: Run Phase 33 Validation Suite

**What to do**:
1. Navigate to: `tests/real-world/cpp23-validation/ab-test/`
2. Run validation suite:
   ```bash
   ./run-tests.sh
   ./compare.py
   ```
3. Measure pass rate improvement
4. Analyze which categories improved
5. Document results in SUMMARY.md

**Expected Results**:
- Before Phase 34: 0/130 (0%)
- After Phases 34-01 to 34-04: 15-30/130 (12-23%)
- Multi-file tests should now pass

**Verification**:
- âœ… Phase 33 suite runs successfully
- âœ… Pass rate improved from 0%
- âœ… Multi-file categories show improvement
- âœ… Results documented

---

### Task 7: Update Documentation and Commit

**What to do**:
1. Update `docs/MULTI_FILE_TRANSPILATION.md`:
   - Document multi-file output generation
   - Explain file routing logic
   - Provide usage examples
2. Update `README.md`:
   - Mention multi-file support
   - Add example with multiple source files
3. Create commit with comprehensive message
4. Include Phase 33 validation results

**Commit Message Format**:
```
feat(phase-34-04): Implement multi-file output generation

Extended FileOutputManager to generate separate .h/.c pairs for each
user header file, completing the multi-file transpilation pipeline.

Implementation:
- Multi-file output API (writeMultiFileOutput)
- File routing based on FileOriginTracker origin data
- Header dependency resolution and include generation
- File merging for .h/.cpp pairs (e.g., Point.h + Point.cpp)

Integration:
- CppToCConsumer detects user headers and routes to multi-file mode
- Backward compatible single-file mode preserved
- Directory structure preservation maintained

Validation:
- Phase 33 pass rate: 0% â†’ X% (X/130 tests)
- Multi-file projects now fully transpilable
- Real-world test (Point.h/Point.cpp/main.cpp) passes

ðŸ¤– Generated with Claude Code
Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

**Verification**:
- âœ… Documentation updated
- âœ… Commit created
- âœ… Phase 33 results included

---

## Success Criteria

This phase is successful when:
- âœ… Multi-file output API implemented and tested
- âœ… CppToCConsumer routes to multi-file mode when user headers present
- âœ… Real multi-file project (Point.h/Point.cpp/main.cpp) transpiles correctly
- âœ… Generated C code compiles and executes correctly
- âœ… Phase 33 pass rate improves from 0% to 12-23%
- âœ… Backward compatibility maintained (single-file mode still works)
- âœ… All tests pass (no regressions)
- âœ… Documentation updated
- âœ… Code committed

---

## Output

**Primary Deliverables**:
- Extended `FileOutputManager` with multi-file support
- Modified `CppToCConsumer` for multi-file routing
- Integration tests for multi-file output
- Phase 33 validation results
- Updated documentation

**SUMMARY.md Required**:
Create `.planning/phases/34-header-file-skipping/34-04-SUMMARY.md` with:

```markdown
# Phase 34-04 Summary: Multi-File Output Generation

**One-liner**: [Substantive summary of implementation]

**Version**: v1

## Key Achievements
- [Multi-file output API implementation]
- [Phase 33 pass rate: 0% â†’ X%]
- [Real-world test results]

## Decisions Made
- [File routing strategy]
- [Dependency resolution approach]

## Blockers Encountered
- [Any issues]

## Next Step
- Execute Phase 34-05: [next action]
```

---

## Deviation Rules (Auto-Applied During Execution)

1. **Auto-fix bugs**: If output routing has issues, fix immediately
2. **Auto-add missing critical**: If missing dependency handling, add it
3. **Auto-fix blockers**: If path calculation issues, resolve them
4. **Ask about architectural**: Major changes to output structure â†’ ask user
5. **Log enhancements**: Nice-to-have features â†’ log to ISSUES.md

All deviations will be documented in SUMMARY.md.

---

## Quality Controls

### Verification Checklist
Before declaring this phase complete:
- [ ] All 7 tasks completed
- [ ] Multi-file output API works
- [ ] Real multi-file project transpiles
- [ ] Generated C compiles and runs
- [ ] Phase 33 results measured
- [ ] Documentation updated
- [ ] SUMMARY.md created
- [ ] Code committed

### Test Coverage
- Multi-file output unit tests
- Integration test with Point class
- Phase 33 validation suite (130 tests)
- Backward compatibility tests

---

**Ready to execute**: Use subagent for autonomous execution

**TDD Principles**: Test multi-file scenarios before implementation

**SOLID Compliance**: Extend FileOutputManager without breaking existing API
