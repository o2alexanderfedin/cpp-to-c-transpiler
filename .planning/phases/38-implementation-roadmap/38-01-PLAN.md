# Phase 38-01: Implementation Roadmap Creation

## Objective

Create comprehensive implementation roadmap that breaks down handler implementation into 10-12 progressive phases, from simplest (functions, variables, arithmetic) to most complex (templates, virtual methods). Each phase must be independently testable with clear verification criteria.

## Context

**Previous Work:**
- Phase 36: Cataloged 47 C++ AST nodes in JSON format with complexity ratings
- Phase 37: Designed complete handler chain architecture with 9 handlers

**Key Documents:**
@docs/architecture/feature-node-mapping.json - 12-phase progressive roadmap
@docs/architecture/handlers/ - 9 handler specifications
@docs/architecture/01-pipeline-architecture.md - 3-stage pipeline
@docs/architecture/02-handler-chain-pattern.md - Handler interfaces
@docs/architecture/03-test-strategy.md - TDD approach

**Implementation Philosophy:**
- Start with simplest features (direct C mapping)
- Progressive complexity (build on previous phases)
- TDD mandatory (test before implement)
- 100% coverage for handlers
- Surgical precision testing

## Tasks

### Task 1: Create Implementation Phases Document
**Type**: auto
**Action**: Create `docs/architecture/05-implementation-phases.md`

Based on `feature-node-mapping.json`, create detailed specification for 12 implementation phases:

**For each phase (1-12), document:**
1. **Phase Name & Goal**: Clear objective
2. **Complexity Level**: 1-5 scale from feature-node-mapping.json
3. **C++ Features**: What C++ constructs are handled
4. **C Mapping Strategy**: How C++ translates to C
5. **Required Handlers**: Which handlers from Phase 37 are needed
6. **New Handler Code**: What new handler methods/logic needed
7. **AST Nodes**: Specific Clang node types from Phase 36 catalogs
8. **Dependencies**: Which previous phases must be complete
9. **Test Strategy**: Unit, integration, and E2E test approach
10. **Verification Criteria**: How to verify phase complete
11. **Example Translations**: 3-5 C++ → C code examples
12. **Estimated Effort**: Rough LOC and time estimate

**Phase Structure (from feature-node-mapping.json):**
- Phase 1: Basic Functions & Arithmetic (complexity 1)
- Phase 2: Control Flow (complexity 1)
- Phase 3: Global Variables & Types (complexity 1)
- Phase 4: Structs C-style (complexity 2)
- Phase 5: Pointers & References (complexity 2)
- Phase 6: Classes Simple (complexity 3)
- Phase 7: Method Calls (complexity 3)
- Phase 8: Enums (complexity 2)
- Phase 9: Inheritance Single (complexity 4)
- Phase 10: Templates Monomorphization (complexity 5)
- Phase 11: Virtual Methods (complexity 5)
- Phase 12: Namespaces (complexity 3)

**Verify**:
- All 12 phases documented with complete specifications
- Each phase has clear scope and boundaries
- Dependencies form valid DAG (no circular dependencies)
- Complexity progression makes sense (simple → complex)

---

### Task 2: Create Handler Implementation Order
**Type**: auto
**Action**: Create `docs/architecture/06-handler-implementation-order.md`

Define exact order to implement handlers and their methods:

**For each handler (9 total from Phase 37):**
1. **Handler Name**: FunctionHandler, VariableHandler, etc.
2. **Implementation Phase**: Which phase(s) it's implemented in
3. **Progressive Implementation**:
   - Phase X: Implement basic methods (e.g., simple functions)
   - Phase Y: Add advanced methods (e.g., function overloading)
4. **Dependencies**: Which handlers must exist first
5. **Parallelization**: Which handlers can be built in parallel
6. **Test Coverage**: Target unit test count per handler
7. **Complexity**: Implementation difficulty (1-5)

**Example: FunctionHandler**
```
Implementation Phases:
- Phase 1: Basic standalone functions
  - handleFunctionDecl() - no overloading, no defaults
  - Parameter translation (simple types)
  - Return type handling

- Phase 7: Method name mangling for overloads
  - Add overload resolution
  - Name mangling for C

Dependencies: VariableHandler (for parameters), StatementHandler (for body), ExpressionHandler (for return)
Can parallelize with: VariableHandler (local vars only)
```

**Verify**:
- All 9 handlers have implementation order
- Dependencies are explicit and achievable
- Parallelization opportunities identified
- No handler is "too big" (broken into phases if needed)

---

### Task 3: Create Detailed Test Plan
**Type**: auto
**Action**: Create `docs/architecture/07-test-plan.md`

Comprehensive test plan for all 12 implementation phases:

**Structure:**
```markdown
# Test Plan

## Overview
- Testing pyramid (unit → handler integration → E2E)
- Coverage requirements (100% for handlers)
- Test organization structure
- Continuous integration approach

## Phase 1: Basic Functions & Arithmetic

### Unit Tests (FunctionHandler)
1. EmptyFunction - void foo() {}
2. FunctionWithReturn - int bar() { return 0; }
3. FunctionWithParams - int add(int a, int b)
4. FunctionWithLocalVars - variables inside functions
... (50+ total unit tests)

### Unit Tests (ExpressionHandler)
1. BinaryAddition - a + b
2. BinarySubtraction - a - b
... (50+ total)

### Handler Integration Tests
1. FunctionWithArithmetic - combines FunctionHandler + ExpressionHandler
2. FunctionCallChain - function calling function
... (20-30 total)

### E2E Integration Tests
1. SimpleProgram.cpp - basic main with arithmetic, compiles and runs
2. FunctionCalls.cpp - multiple functions calling each other
... (5-10 total)

### Verification Criteria
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] Generated C code compiles with gcc/clang
- [ ] Generated C code produces same output as C++
- [ ] No memory leaks in generated code
- [ ] Code coverage 100% for implemented handlers
```

**For EACH of 12 phases:**
- List all unit tests (handler-specific)
- List integration tests (multi-handler scenarios)
- List E2E tests (full transpilation)
- Define verification criteria
- Specify test file locations

**Verify**:
- Every handler method has unit tests
- Every feature has integration test
- Every phase has E2E test
- Test progression makes sense (build on previous)
- Test file structure defined

---

### Task 4: Create Handler Test Fixtures Design
**Type**: auto
**Action**: Create `docs/architecture/08-test-fixtures-design.md`

Design mock utilities and fixtures for testing handlers:

**Content:**
1. **MockASTContext Design**:
   - How to create C++ AST nodes programmatically for testing
   - Helper methods for common node creation
   - Memory management strategy

2. **MockCNodeBuilder Design**:
   - How to verify C AST node creation without emission
   - Inspection methods for testing
   - AST matcher integration

3. **HandlerTestFixture Design**:
   - Base test fixture for all handler tests
   - Common setup/teardown
   - Helper assertion methods

4. **Integration Test Harness Design**:
   - How to run full transpilation pipeline in tests
   - How to compile and execute generated C code
   - Output verification strategies

5. **Test Data Organization**:
   - Where to put C++ test input files
   - Where to put expected C output files
   - Naming conventions

**Example:**
```cpp
// MockASTContext usage
class FunctionHandlerTest : public HandlerTestFixture {
protected:
    FunctionDecl* createSimpleFunction() {
        return cppMockContext.createFunction(
            "int",           // return type
            "add",           // name
            {"int a", "int b"}  // parameters
        );
    }
};

TEST_F(FunctionHandlerTest, SimpleFunctionTranslation) {
    FunctionDecl* cppFunc = createSimpleFunction();

    FunctionHandler handler;
    Decl* cFunc = handler.handleDecl(cppFunc, context);

    // Verify C AST structure
    ASSERT_NE(cFunc, nullptr);
    // ... assertions
}
```

**Verify**:
- Mock utilities support all Phase 1-3 AST node creation
- Test fixtures reduce boilerplate
- Integration harness supports compile + run verification
- Design enables 100% handler coverage

---

### Task 5: Create Implementation Timeline & Effort Estimates
**Type**: auto
**Action**: Create `docs/architecture/09-implementation-timeline.md`

Break down implementation into atomic work units:

**Content:**
1. **Phase-by-Phase Breakdown**:
   - For each of 12 phases, list sub-tasks
   - Estimate LOC for each handler method
   - Estimate LOC for each test file
   - Calculate total effort

2. **Parallelization Strategy**:
   - Which phases can run in parallel
   - Which handlers can be built concurrently
   - Maximum parallelism opportunities

3. **Verification Gates**:
   - After which phases should we pause for review
   - Critical checkpoints (e.g., after Phase 3, all basics work)
   - Integration gates (when to run full test suite)

4. **Risk Assessment**:
   - Which phases are highest risk (complexity 4-5)
   - Mitigation strategies
   - Fallback plans

**Example:**
```markdown
## Phase 1: Basic Functions & Arithmetic

### Sub-tasks
1. Implement FunctionHandler basic methods (3-4 hours, 200-300 LOC)
   - handleFunctionDecl()
   - translateParameters()
   - translateReturnType()

2. Implement VariableHandler local vars (2-3 hours, 150-200 LOC)
   - handleVarDecl() for local scope
   - Initialization handling

3. Implement ExpressionHandler arithmetic (4-5 hours, 300-400 LOC)
   - handleBinaryOperator() for +, -, *, /, %
   - handleIntegerLiteral()
   - handleDeclRefExpr()

4. Implement StatementHandler return (1-2 hours, 50-100 LOC)
   - handleReturnStmt()

5. Write unit tests (6-8 hours, 800-1000 LOC)
   - 50+ tests for Function, Variable, Expression handlers

6. Write integration tests (3-4 hours, 300-400 LOC)
   - 20-30 multi-handler scenarios

7. Write E2E tests (2-3 hours, 200-300 LOC)
   - 5-10 complete programs

**Total Effort: 21-29 hours, 2000-2700 LOC**
```

**Verify**:
- All 12 phases have effort estimates
- Total timeline is realistic
- Parallelization reduces calendar time
- Critical path identified

---

### Task 6: Create Phase 1 Detailed Plan
**Type**: auto
**Action**: Create `docs/architecture/10-phase1-detailed-plan.md`

Since Phase 1 (Basic Functions & Arithmetic) is the foundation, create extra-detailed plan:

**Content:**
1. **Objective**: Get basic functions, local variables, and arithmetic working end-to-end

2. **Scope**:
   - Standalone functions (no classes)
   - Local variables with initialization
   - Arithmetic operators (+, -, *, /, %)
   - Integer and float literals
   - Function calls (simple, no overloading)
   - Return statements

3. **Out of Scope** (for Phase 1):
   - Global variables (Phase 3)
   - Control flow (Phase 2)
   - Classes/methods (Phase 6+)
   - Pointers (Phase 5)

4. **Implementation Steps** (TDD):
   ```
   Step 1: FunctionHandler - Empty Function
     a. Write failing unit test: EmptyFunction
     b. Implement handleFunctionDecl() minimal
     c. Test passes
     d. Refactor

   Step 2: FunctionHandler - Return Type
     a. Write failing test: FunctionWithIntReturn
     b. Implement return type translation
     c. Test passes
     d. Refactor

   ... (20-30 steps total)
   ```

5. **Test Cases**:
   - List all 50+ unit tests
   - List all 20-30 integration tests
   - List all 5-10 E2E tests

6. **Verification Checklist**:
   - [ ] All unit tests pass
   - [ ] All integration tests pass
   - [ ] C code compiles
   - [ ] C code produces correct output
   - [ ] No memory leaks
   - [ ] 100% coverage for Phase 1 handlers

7. **Example Translations**:
   ```cpp
   // Input: C++
   int add(int a, int b) {
       int result = a + b;
       return result;
   }

   // Output: C (expected)
   int add(int a, int b) {
       int result = a + b;
       return result;
   }
   ```

**Verify**:
- Phase 1 plan is actionable step-by-step
- Each step follows TDD (test, implement, refactor)
- All test cases defined
- Success criteria clear

---

## Verification

After completing all tasks, verify:

1. **Documentation Complete**:
   - [ ] 05-implementation-phases.md exists (12 phases documented)
   - [ ] 06-handler-implementation-order.md exists (9 handlers ordered)
   - [ ] 07-test-plan.md exists (comprehensive test coverage)
   - [ ] 08-test-fixtures-design.md exists (mock utilities designed)
   - [ ] 09-implementation-timeline.md exists (effort estimated)
   - [ ] 10-phase1-detailed-plan.md exists (foundation plan ready)

2. **Consistency Checks**:
   - [ ] Implementation phases align with feature-node-mapping.json
   - [ ] Handler order respects dependencies
   - [ ] Test plan covers all features
   - [ ] Timeline is achievable
   - [ ] Phase 1 plan follows TDD

3. **Completeness**:
   - [ ] All 47 AST nodes from Phase 36 are accounted for
   - [ ] All 9 handlers from Phase 37 have implementation plans
   - [ ] No gaps in feature coverage
   - [ ] No missing test scenarios

4. **Quality**:
   - [ ] Documents are clear and actionable
   - [ ] Examples are correct and helpful
   - [ ] Estimates are reasonable
   - [ ] Risk assessment is realistic

## Success Criteria

✅ 6 architecture documents created (05-10)
✅ 12 implementation phases fully specified
✅ 9 handlers have implementation order
✅ Comprehensive test plan for all phases
✅ Phase 1 has detailed TDD plan ready to execute
✅ Timeline shows achievable path to completion
✅ All documentation cross-referenced and consistent

## Output

Create `.planning/phases/38-implementation-roadmap/38-01-SUMMARY.md` with:

**Deliverables:**
- List all 6 documents created
- Key statistics (total phases, handlers, test count estimates, LOC estimates)

**Key Decisions:**
- Why 12 phases (not more/less)
- Why this handler implementation order
- Why this test strategy

**Phase 1 Readiness:**
- Confirm Phase 1 plan is actionable
- List first 5 TDD steps
- Estimate Phase 1 completion time

**Next Steps:**
- Ready to begin Phase 39 (Foundation Implementation)
- Phase 39 will execute Phase 1 detailed plan
- Expected to implement FunctionHandler, VariableHandler, ExpressionHandler (basic), StatementHandler (basic)

**Validation:**
- All verification criteria met
- Documentation reviewed for clarity
- Ready to hand off to implementation phase
