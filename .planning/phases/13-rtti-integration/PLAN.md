# Phase 13 Plan: RTTI Integration (v2.6.0)

**Phase**: 13 of 17 (C++ Features Workstream)
**Roadmap**: `.planning/ROADMAP.md`
**Brief**: `.planning/BRIEF.md`
**Target Version**: v2.6.0
**Status**: PENDING
**Prerequisites**: Phase 9 (Virtual Methods) - RTTI depends on vtable infrastructure

## Phase Goal

Integrate Runtime Type Information (RTTI) translation infrastructure into the transpiler by implementing visitor methods for `typeid()` expressions and `dynamic_cast<>()` operations. Enable polymorphic type queries and safe downcasting with runtime type checking in translated C code.

## Deliverables

### Source Code
- [ ] `src/CppToCVisitor.cpp`: `VisitCXXTypeidExpr` implementation (visitor method)
- [ ] `src/CppToCVisitor.cpp`: `VisitCXXDynamicCastExpr` implementation (visitor method)
- [ ] Integrate TypeidTranslator into VisitCXXTypeidExpr
- [ ] Integrate DynamicCastTranslator into VisitCXXDynamicCastExpr
- [ ] Verify TypeidTranslator.cpp infrastructure in place
- [ ] Verify DynamicCastTranslator.cpp infrastructure in place
- [ ] Verify rtti_runtime.c runtime linking

### Tests
- [ ] `tests/RTTIIntegrationTest.cpp` (10+ integration tests)
  - [ ] Typeid on polymorphic types (runtime lookup)
  - [ ] Typeid on non-polymorphic types (compile-time)
  - [ ] Typeid name comparison
  - [ ] Typeid equality checks
  - [ ] Dynamic cast successful downcast
  - [ ] Dynamic cast failed downcast (returns NULL)
  - [ ] Dynamic cast with NULL pointers
  - [ ] Dynamic cast same-type optimization
  - [ ] Multiple inheritance with RTTI
  - [ ] Virtual method dispatch with RTTI

### CLI Integration
- [ ] Add `--enable-rtti={off,on}` flag (default: on if Phase 9 enabled)
- [ ] Update help text with RTTI description

### Documentation
- [ ] Update `docs/CHANGELOG.md` for v2.6.0
- [ ] Update `README.md` feature list (RTTI section)
- [ ] Update `website/src/pages/features.astro`
- [ ] Create `docs/RTTI_TRANSLATION.md` guide with examples

### Release
- [ ] Git-flow release v2.6.0

## Technical Design

### RTTI Translation Overview

Runtime Type Information in C++ provides two key mechanisms:
1. **typeid() operator**: Query type information at runtime (polymorphic) or compile-time (static)
2. **dynamic_cast<>()**: Safe type casting with runtime validation and NULL return on failure

### Infrastructure in Place

**TypeidTranslator.h/cpp** (Story #84)
- Translates `typeid(expr)` and `typeid(Type)` to C
- Polymorphic typeid: vtable lookup `ptr->vptr->type_info`
- Static typeid: direct reference `&__ti_ClassName`
- Requires VirtualMethodAnalyzer to detect polymorphism

**DynamicCastTranslator.h/cpp** (Story #85)
- Translates `dynamic_cast<Target*>(source)` to C
- Generates `cxx_dynamic_cast()` runtime calls
- Includes source_type, target_type, and type_info structs

**rtti_runtime.h/c** (Story #86, #87)
- Type_info struct definitions (Itanium ABI compatible)
  - `__class_type_info`: Simple class (no inheritance)
  - `__si_class_type_info`: Single inheritance
  - `__vmi_class_type_info`: Multiple/virtual inheritance
- `traverse_hierarchy()`: Walk inheritance tree for dynamic_cast
- `cross_cast_traverse()`: Handle cross-casts in multiple inheritance
- ACSL predicates for formal verification

### C++ to C Translation Examples

#### Example 1: Static typeid

**C++ Code:**
```cpp
class Animal {
public:
    virtual ~Animal() {}
};

class Dog : public Animal {
public:
    void bark() { std::cout << "Woof!\n"; }
};

void test_typeid_static() {
    const std::type_info& ti = typeid(Animal);
    std::cout << ti.name() << std::endl;
}
```

**Translated C Code:**
```c
struct Animal {
    const struct __class_type_info *vptr;  // vtable pointer
};

struct Dog {
    struct Animal base;
};

// Type info struct for Animal (generated by TypeInfoGenerator)
struct __class_type_info __ti_Animal = {
    .vtable_ptr = &__vt_class_type_info,
    .type_name = "4Animal"  // Length-prefixed name
};

void test_typeid_static() {
    const struct __class_type_info *ti = &__ti_Animal;
    printf("%s\n", ti->type_name);
}
```

#### Example 2: Polymorphic typeid

**C++ Code:**
```cpp
class Animal {
public:
    virtual ~Animal() {}
    virtual void speak() = 0;
};

class Cat : public Animal {
public:
    void speak() override { std::cout << "Meow!\n"; }
};

void identify_animal(Animal* a) {
    const std::type_info& ti = typeid(*a);  // Polymorphic!
    if (ti == typeid(Cat)) {
        std::cout << "It's a cat!\n";
    }
}
```

**Translated C Code:**
```c
struct Animal {
    const struct Animal_vtable *vptr;
};

struct Cat {
    struct Animal base;
};

void identify_animal(struct Animal *a) {
    // Polymorphic typeid: lookup from vtable
    const struct __class_type_info *ti = a->vptr->type_info;

    // Type comparison (not shown in detail)
    if (type_info_equal(ti, &__ti_Cat)) {
        printf("It's a cat!\n");
    }
}
```

#### Example 3: Dynamic cast successful

**C++ Code:**
```cpp
class Shape {
public:
    virtual ~Shape() {}
    virtual void draw() = 0;
};

class Circle : public Shape {
public:
    void draw() override { std::cout << "Circle\n"; }
    void bounce() { std::cout << "Bounce!\n"; }
};

void process_shape(Shape* s) {
    Circle* c = dynamic_cast<Circle*>(s);
    if (c != nullptr) {
        c->bounce();  // Safe - we know it's a Circle
    }
}
```

**Translated C Code:**
```c
struct Shape {
    const struct Shape_vtable *vptr;
};

struct Circle {
    struct Shape base;
};

void process_shape(struct Shape *s) {
    // Runtime type checking via cxx_dynamic_cast
    struct Circle *c = (struct Circle *)cxx_dynamic_cast(
        (const void *)s,          // Pointer to object
        &__ti_Shape,              // Source type (compile-time visible type)
        &__ti_Circle,             // Target type (requested type)
        -1                        // Offset (-1 = runtime check required)
    );

    if (c != NULL) {
        // Now safe to call Circle-specific methods
        Circle_bounce(c);
    }
}
```

#### Example 4: Dynamic cast failed

**C++ Code:**
```cpp
class Vehicle { public: virtual ~Vehicle() {} };
class Car : public Vehicle { public: void drive() {} };
class Boat : public Vehicle { public: void sail() {} };

void test_cast() {
    Vehicle* v = new Car();
    Boat* b = dynamic_cast<Boat*>(v);
    if (b == nullptr) {
        std::cout << "Not a boat!\n";
    }
}
```

**Translated C Code:**
```c
void test_cast() {
    struct Vehicle *v = (struct Vehicle *)malloc(sizeof(struct Car));

    // Cross-hierarchy cast (Car to Boat) returns NULL
    struct Boat *b = (struct Boat *)cxx_dynamic_cast(
        (const void *)v,
        &__ti_Car,
        &__ti_Boat,
        -1
    );

    if (b == NULL) {
        printf("Not a boat!\n");
    }
}
```

#### Example 5: Multiple inheritance with dynamic_cast

**C++ Code:**
```cpp
class A { public: virtual ~A() {} };
class B { public: virtual ~B() {} };
class D : public A, public B { public: void foo() {} };

void test_mi_cast() {
    A* a = new D();
    D* d = dynamic_cast<D*>(a);
    B* b = dynamic_cast<B*>(a);  // Cross-cast through hierarchy
}
```

**Translated C Code:**
```c
struct A { const struct A_vtable *vptr; };
struct B { const struct B_vtable *vptr; };
struct D {
    struct A base_a;
    struct B base_b;
};

void test_mi_cast() {
    struct D *d_obj = (struct D *)malloc(sizeof(struct D));
    struct A *a = (struct A *)d_obj;

    // Downcast A to D
    struct D *d = (struct D *)cxx_dynamic_cast(
        (const void *)a,
        &__ti_A,
        &__ti_D,
        -1
    );

    // Cross-cast A to B (via D)
    struct B *b = (struct B *)cxx_dynamic_cast(
        (const void *)a,
        &__ti_A,
        &__ti_B,
        -1
    );
}
```

### Visitor Method Integration Points

#### VisitCXXTypeidExpr Implementation

```cpp
/*! Visit typeid expression in AST */
bool VisitCXXTypeidExpr(CXXTypeidExpr *E) {
    // 1. Check if RTTI is enabled
    if (!options.enableRTTI) {
        // Report error: typeid not supported without RTTI
        return true;
    }

    // 2. Create TypeidTranslator instance
    TypeidTranslator translator(Context, virtualMethodAnalyzer);

    // 3. Translate the typeid expression
    std::string translatedCode = translator.translateTypeid(E);

    // 4. Store translation result
    expressionTranslations[E] = translatedCode;

    // 5. If operand is an expression, visit it
    if (E->isTypeOperand() == false) {
        Visit(E->getExprOperand());
    }

    return true;
}
```

#### VisitCXXDynamicCastExpr Implementation

```cpp
/*! Visit dynamic_cast expression in AST */
bool VisitCXXDynamicCastExpr(CXXDynamicCastExpr *E) {
    // 1. Check if RTTI is enabled
    if (!options.enableRTTI) {
        // Report error: dynamic_cast not supported without RTTI
        return true;
    }

    // 2. Create DynamicCastTranslator instance
    DynamicCastTranslator translator(Context, virtualMethodAnalyzer);

    // 3. Translate the dynamic_cast expression
    std::string translatedCode = translator.translateDynamicCast(E);

    // 4. Store translation result
    expressionTranslations[E] = translatedCode;

    // 5. Visit subexpression
    Visit(E->getSubExpr());

    return true;
}
```

### Key Design Decisions

1. **Polymorphism Detection**: Reuse VirtualMethodAnalyzer from Phase 9
2. **Type Info Generation**: TypeInfoGenerator creates __ti_ClassName references
3. **Runtime Linking**: Link rtti_runtime.c for traverse_hierarchy and cross_cast_traverse
4. **ACSL Support**: Use ACSL predicates from rtti_runtime.h for formal verification
5. **NULL Handling**: dynamic_cast returns NULL on failure (C semantics)
6. **Offset Calculation**: Use -1 (runtime check) for most casts; optimize known offsets later

## Test Plan

### Test Categories (10+ tests)

#### Category 1: Typeid Basic (3 tests)
- **test_TypidStaticTypeName**: Static typeid on non-polymorphic class
  - Verify direct reference to `__ti_ClassName`
  - Check type_info struct is generated

- **test_TypidPolymorphicBasic**: Polymorphic typeid on derived object
  - Verify vtable lookup translation
  - Check polymorphic detection works

- **test_TypidNullPointer**: Typeid on null polymorphic pointer
  - Should still work (vtable lookup is safe)

#### Category 2: Typeid Semantics (3 tests)
- **test_TypeidEquality**: Typeid equality comparison
  - Same type: ti1 == ti2 should work
  - Different types: should compare false

- **test_TypeidNameFunction**: Typeid name() method translation
  - Extract name from type_info.type_name

- **test_TypeidInheritanceChain**: Typeid in inheritance hierarchy
  - Polymorphic lookup finds correct type at each level

#### Category 3: Dynamic Cast Success (2 tests)
- **test_DynamicCastDowncast**: Successful downcast to derived class
  - Return non-NULL pointer
  - Type is correct

- **test_DynamicCastUpcast**: Upcast to base class (always succeeds)
  - Return valid base pointer

#### Category 4: Dynamic Cast Failure (2 tests)
- **test_DynamicCastWrongType**: Cast to unrelated type
  - Return NULL pointer
  - Original object unmodified

- **test_DynamicCastCrossHierarchy**: Cross-cast between unrelated hierarchies
  - Return NULL pointer

#### Category 5: Edge Cases (2 tests)
- **test_DynamicCastNullPtr**: dynamic_cast on NULL pointer
  - Return NULL (preserve NULL)

- **test_DynamicCastSameType**: dynamic_cast to same type
  - Optimization: return same pointer

#### Category 6: Integration (3 tests)
- **test_MultipleInheritanceRTTI**: RTTI with multiple inheritance
  - Test typeid and dynamic_cast with MI

- **test_VirtualMethodsWithRTTI**: Phase 9 integration
  - Virtual methods + RTTI together

- **test_PolymorphicContainers**: RTTI with collections of polymorphic types
  - Vector of base pointers, identify derived types at runtime

### Test Implementation Structure

```cpp
// File: tests/RTTIIntegrationTest.cpp

#include "clang/Tooling/Tooling.h"
#include "clang/Frontend/ASTUnit.h"
#include "../include/CppToCVisitor.h"
#include "../include/TypeInfoGenerator.h"
#include "../include/VirtualMethodAnalyzer.h"
#include <iostream>
#include <cassert>

using namespace clang;

// Helper: Build AST from code snippet
std::unique_ptr<ASTUnit> buildAST(const char *code) {
    std::vector<std::string> args = {"-std=c++17"};
    return tooling::buildASTFromCodeWithArgs(code, args, "input.cc");
}

// Test 1: Static typeid translation
void test_TypidStaticTypeName() {
    const char* code = R"(
        class Animal {
        public:
            virtual ~Animal() {}
        };

        void test() {
            const std::type_info& ti = typeid(Animal);
        }
    )";

    auto ast = buildAST(code);
    // Verify visitor generates: &__ti_Animal
    // Verify type_info struct is generated
}

// Test 2: Polymorphic typeid lookup
void test_TypeidPolymorphicBasic() {
    const char* code = R"(
        class Animal {
        public:
            virtual ~Animal() {}
        };

        class Dog : public Animal {};

        void identify(Animal* a) {
            const std::type_info& ti = typeid(*a);
        }
    )";

    auto ast = buildAST(code);
    // Verify visitor generates: a->vptr->type_info
    // Verify polymorphic flag is set
}

// Test 3: Dynamic cast success
void test_DynamicCastDowncast() {
    const char* code = R"(
        class Shape {
        public:
            virtual ~Shape() {}
        };

        class Circle : public Shape {};

        void process(Shape* s) {
            Circle* c = dynamic_cast<Circle*>(s);
            if (c != nullptr) {
                // Use Circle-specific methods
            }
        }
    )";

    auto ast = buildAST(code);
    // Verify visitor generates cxx_dynamic_cast call
    // Check parameters: source ptr, &__ti_Shape, &__ti_Circle, -1
}

// Test 4: Dynamic cast failure
void test_DynamicCastWrongType() {
    const char* code = R"(
        class Vehicle {};
        class Car : public Vehicle {};
        class Boat : public Vehicle {};

        void test() {
            Vehicle* v = new Car();
            Boat* b = dynamic_cast<Boat*>(v);
            if (b == nullptr) {
                // Not a boat
            }
        }
    )";

    auto ast = buildAST(code);
    // Verify cxx_dynamic_cast generated
    // Verify NULL check is correct
}

// Test 5-10: [Additional tests following same pattern]
```

## Dependencies

### Phase Dependencies
- **Requires: Phase 9 (Virtual Methods)** - RTTI depends on vtable infrastructure
  - VirtualMethodAnalyzer must identify polymorphic types
  - Vtable layout must include type_info pointer

- **Synergy with Phase 9**: Once virtual methods work, RTTI works automatically

### File Dependencies
- **TypeidTranslator.h/.cpp**: Infrastructure complete, needs integration
- **DynamicCastTranslator.h/.cpp**: Infrastructure complete, needs integration
- **rtti_runtime.h/.c**: Infrastructure complete, needs linking
- **TypeInfoGenerator.h/.cpp**: Generates type_info structs
- **VirtualMethodAnalyzer.h/.cpp**: From Phase 9, provides polymorphism detection

### Build System Integration
- Link `rtti_runtime.c` into final executable
- Ensure type_info vtable pointers (`__vt_class_type_info`, etc.) are available

## Verification Criteria

### Functional Requirements
- [ ] typeid() on polymorphic types performs vtable lookup (runtime)
- [ ] typeid() on static types returns compile-time constant
- [ ] typeid().name() works for all types
- [ ] dynamic_cast<>() succeeds when type matches (returns valid pointer)
- [ ] dynamic_cast<>() fails when type doesn't match (returns NULL)
- [ ] dynamic_cast<>() handles NULL pointers correctly (returns NULL)
- [ ] dynamic_cast<>() works in single inheritance hierarchies
- [ ] dynamic_cast<>() works in multiple inheritance hierarchies
- [ ] Type comparison (ti1 == ti2) works correctly

### Quality Requirements
- [ ] 10+ tests passing (100%)
- [ ] Zero RTTI translation errors
- [ ] All linters passing (clang-format, clang-tidy)
- [ ] No performance regression (typeid/dynamic_cast shouldn't be slower than baseline)
- [ ] Type safety: RTTI only works with polymorphic types
- [ ] ACSL predicates validate type_info struct validity

### Integration Requirements
- [ ] RTTI works alongside virtual methods (Phase 9)
- [ ] Type info structs generated alongside vtables
- [ ] Runtime functions link correctly
- [ ] CLI flag `--enable-rtti={off,on}` works
- [ ] Documentation complete and accurate

## Acceptance Criteria

1. **Infrastructure Used**: TypeidTranslator, DynamicCastTranslator, rtti_runtime used correctly
2. **Visitor Methods**: VisitCXXTypeidExpr and VisitCXXDynamicCastExpr implemented
3. **Type Safety**: Runtime type checking prevents unsafe casts
4. **Test Coverage**: 10+ tests verify all scenarios
5. **Documentation**: Examples show typeid and dynamic_cast translation patterns
6. **CI/CD**: All tests passing, linters clean, no performance regression

## Parallel Execution

**Parallel Execution**: ✅ Can run with Phases 6, 7, 8, 9, 11, 12
- No dependencies except Phase 9 (virtual methods)
- Independent from ACSL phases (6-7)
- Can execute alongside other features (8, 11, 12)

## Success Metrics

| Metric | Target | How Verified |
|--------|--------|-------------|
| Test Pass Rate | 100% | All 10+ tests passing |
| Type Accuracy | 100% | Correct type returned by typeid/dynamic_cast |
| NULL Handling | 100% | NULL pointers handled safely |
| Performance | <5% overhead | Benchmark typeid/dynamic_cast calls |
| Code Coverage | ≥95% | Coverage report from tests |
| Linting | 0 issues | clang-format and clang-tidy clean |

## Next Steps

1. **Implement VisitCXXTypeidExpr**: Add visitor method to CppToCVisitor
2. **Implement VisitCXXDynamicCastExpr**: Add visitor method to CppToCVisitor
3. **Create RTTIIntegrationTest**: Test suite with 10+ tests
4. **Verify TypeInfoGenerator**: Ensure type_info structs are generated
5. **Link rtti_runtime**: Add runtime library to final executable
6. **Update Documentation**: CHANGELOG, README, features page, RTTI guide
7. **Git-Flow Release**: Create v2.6.0 release

## Resources

### Key Files
- Source: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/src/CppToCVisitor.cpp`
- Headers:
  - `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/include/TypeidTranslator.h`
  - `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/include/DynamicCastTranslator.h`
  - `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/include/VirtualMethodAnalyzer.h`
- Runtime: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/runtime/rtti_runtime.h`
- Tests:
  - `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/tests/TypeidTranslatorTest.cpp`
  - `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/tests/DynamicCastTranslatorTest.cpp`

### Documentation References
- [Itanium C++ ABI: RTTI](https://itanium-cxx-abi.github.io/cxx-abi/abi.html#rtti)
- [C++ Standard: RTTI (18.7)](https://en.cppreference.com/w/cpp/language/rtti)
- [dynamic_cast Reference](https://en.cppreference.com/w/cpp/language/dynamic_cast)
- [typeid Reference](https://en.cppreference.com/w/cpp/language/typeid)

### Related Phases
- **Phase 9: Virtual Methods** (v2.2.0) - Infrastructure required
- **Phase 17: Comprehensive Integration** (v3.0.0) - Final validation

---

## Execution Checklist

- [ ] Read and understand ROADMAP and this PLAN
- [ ] Review TypeidTranslator.h/.cpp infrastructure
- [ ] Review DynamicCastTranslator.h/.cpp infrastructure
- [ ] Review rtti_runtime.h/.c functions
- [ ] Implement VisitCXXTypeidExpr in CppToCVisitor
- [ ] Implement VisitCXXDynamicCastExpr in CppToCVisitor
- [ ] Create RTTIIntegrationTest.cpp with 10+ tests
- [ ] Run tests and verify all passing
- [ ] Run linters (clang-format, clang-tidy)
- [ ] Update documentation files
- [ ] Create git-flow release v2.6.0
- [ ] Verify release builds and tests pass
- [ ] Update git tags and branches

**Ready to execute Phase 13: RTTI Integration**
