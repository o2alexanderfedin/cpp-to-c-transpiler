# Phase 45 Plan: Virtual Methods with COM-Style Vtables

**Phase**: 45 (Classes + Virtual Methods)
**Prerequisite**: Phase 44 (Classes Simple)
**Status**: PLANNING
**Target**: Implement virtual methods using Microsoft COM/DCOM vtable pattern

## Phase Goal

Implement C++ virtual method translation using strongly-typed function pointers following Microsoft COM/DCOM pattern. Generate type-safe vtable structs with explicit function pointer types for each virtual method.

## COM/DCOM Pattern Overview

The Microsoft COM/DCOM pattern in C uses:
1. **Vtable struct** with strongly-typed function pointers (not void*)
2. **Const static vtable instances** for each class
3. **lpVtbl pointer as first struct member** for layout compatibility
4. **Type safety** through explicit function pointer typedefs

### Pattern Example

**C++ Source:**
```cpp
class IAnimal {
public:
    virtual ~IAnimal() {}
    virtual void speak() = 0;
    virtual int getAge() const = 0;
};

class Dog : public IAnimal {
    int age;
public:
    Dog(int a) : age(a) {}
    virtual ~Dog() {}
    virtual void speak() { printf("Woof\n"); }
    virtual int getAge() const { return age; }
};
```

**Generated C (COM Pattern):**
```c
/* Forward declarations */
struct IAnimal;
struct Dog;

/* Strongly-typed function pointer typedefs */
typedef void (*IAnimal_destructor_fn)(struct IAnimal *this);
typedef void (*IAnimal_speak_fn)(struct IAnimal *this);
typedef int (*IAnimal_getAge_fn)(const struct IAnimal *this);

/* IAnimal vtable struct - COM pattern */
struct IAnimal_vtable {
    IAnimal_destructor_fn destructor;
    IAnimal_speak_fn speak;
    IAnimal_getAge_fn getAge;
};

/* IAnimal struct - lpVtbl is first member (COM requirement) */
struct IAnimal {
    const struct IAnimal_vtable *lpVtbl;
};

/* Dog function pointer typedefs (same signatures as IAnimal for compatibility) */
typedef void (*Dog_destructor_fn)(struct Dog *this);
typedef void (*Dog_speak_fn)(struct Dog *this);
typedef int (*Dog_getAge_fn)(const struct Dog *this);

/* Dog vtable struct - compatible with IAnimal_vtable layout */
struct Dog_vtable {
    Dog_destructor_fn destructor;
    Dog_speak_fn speak;
    Dog_getAge_fn getAge;
};

/* Dog struct - embeds IAnimal as first member for COM compatibility */
struct Dog {
    const struct Dog_vtable *lpVtbl;  /* Must be first member */
    int age;                           /* Dog's fields */
};

/* Dog method implementations */
void Dog_destructor(struct Dog *this) {
    /* Cleanup code */
}

void Dog_speak(struct Dog *this) {
    printf("Woof\n");
}

int Dog_getAge(const struct Dog *this) {
    return this->age;
}

/* Dog vtable instance - const static storage (COM pattern) */
static const struct Dog_vtable Dog_vtable_instance = {
    .destructor = (Dog_destructor_fn)Dog_destructor,
    .speak = (Dog_speak_fn)Dog_speak,
    .getAge = (Dog_getAge_fn)Dog_getAge,
};

/* Dog constructor - initializes lpVtbl */
void Dog_init(struct Dog *this, int a) {
    this->lpVtbl = &Dog_vtable_instance;
    this->age = a;
}

/* Virtual call through base pointer (polymorphic) */
void test_polymorphism() {
    struct Dog dog;
    Dog_init(&dog, 5);

    /* Upcast to base pointer */
    struct IAnimal *animal = (struct IAnimal *)&dog;

    /* Virtual dispatch through lpVtbl */
    animal->lpVtbl->speak(animal);          /* Calls Dog_speak */
    int age = animal->lpVtbl->getAge(animal); /* Calls Dog_getAge */

    /* Cleanup */
    animal->lpVtbl->destructor(animal);     /* Calls Dog_destructor */
}
```

## Implementation Tasks

### Group 1: Vtable Infrastructure (2 parallel tasks)

**Task 1: Vtable Typedef Generator** (Est. 3-4 hours)
- Create `VtableTypedefGenerator` helper class
- Generate strongly-typed function pointer typedefs
- Pattern: `typedef RetType (*ClassName_methodName_fn)(Params);`
- Input: CXXMethodDecl
- Output: Typedef declaration string
- **Tests** (8-10 tests):
  - Simple method typedef (void return)
  - Method with return value typedef
  - Method with parameters typedef
  - Const method typedef (const this)
  - Virtual destructor typedef
  - Multiple methods - all typedefs
  - Inherited virtual method typedef
  - Override method typedef (compatible signature)

**Task 2: Vtable Struct Generator** (Est. 3-4 hours)
- Extend RecordHandler to generate vtable struct
- Use strongly-typed function pointers (not void*)
- Follow COM pattern: ordered function pointers
- **Tests** (10-12 tests):
  - Single virtual method vtable struct
  - Multiple virtual methods vtable struct
  - Virtual destructor in vtable
  - Inherited vtable struct (derived compatible with base)
  - Pure virtual method vtable struct
  - Mixed virtual/non-virtual (only virtual in vtable)
  - Const methods in vtable
  - Override preserves slot order
  - Vtable with complex parameter types
  - Vtable with return types

### Group 2: Struct Layout (2 parallel tasks)

**Task 3: lpVtbl Injection** (Est. 2-3 hours)
- Extend RecordHandler to inject lpVtbl as first field
- Pattern: `const struct ClassName_vtable *lpVtbl;`
- Must be first member for COM compatibility
- **Tests** (6-8 tests):
  - lpVtbl is first field in struct
  - lpVtbl has correct type
  - lpVtbl is const pointer
  - Single inheritance - lpVtbl first
  - Multiple fields after lpVtbl
  - Empty class with only lpVtbl
  - Derived class embeds base lpVtbl correctly
  - Field access still works with lpVtbl present

**Task 4: Vtable Instance Generator** (Est. 2-3 hours)
- Generate static const vtable instances
- Pattern: `static const struct ClassName_vtable ClassName_vtable_instance = { ... };`
- Initialize with method function pointers
- **Tests** (8-10 tests):
  - Vtable instance creation
  - Vtable instance is static const
  - Vtable instance initialization - designated initializers
  - Vtable instance with destructor
  - Vtable instance with multiple methods
  - Override vtable - correct function pointers
  - Pure virtual - NULL function pointers (or error)
  - Vtable instance ordering matches vtable struct

### Group 3: Constructor Integration (1 task)

**Task 5: lpVtbl Initialization** (Est. 2-3 hours)
- Extend ConstructorHandler to inject lpVtbl initialization
- Pattern: `this->lpVtbl = &ClassName_vtable_instance;`
- Must be first statement in constructor
- **Tests** (8-10 tests):
  - lpVtbl initialization in default constructor
  - lpVtbl initialization in parameterized constructor
  - lpVtbl initialization before field initialization
  - Derived class constructor - correct vtable
  - Multiple constructors - all initialize lpVtbl
  - Constructor with member init list - lpVtbl first
  - Verify lpVtbl assignment correct type
  - Verify lpVtbl points to static vtable instance

### Group 4: Virtual Call Translation (2 parallel tasks)

**Task 6: Virtual Call Detection** (Est. 2-3 hours)
- Extend ExpressionHandler to detect virtual calls
- Check CXXMethodDecl::isVirtual()
- Distinguish from non-virtual calls
- **Tests** (6-8 tests):
  - Detect virtual method call
  - Detect non-virtual method call
  - Detect virtual call on base pointer
  - Detect virtual call on derived pointer
  - Detect virtual destructor call
  - Static method is not virtual
  - Inline method is not virtual
  - Final method (non-virtual in C)

**Task 7: Virtual Call Code Generation** (Est. 3-4 hours)
- Extend ExpressionHandler::translateCXXMemberCallExpr()
- Pattern: `obj->lpVtbl->methodName(obj, args...)`
- Handle different object types (value, pointer, reference)
- **Tests** (12-15 tests):
  - Virtual call on value object (obj.method())
  - Virtual call on pointer (ptr->method())
  - Virtual call through base pointer (polymorphic)
  - Virtual call with arguments
  - Virtual call with return value
  - Chained virtual calls
  - Virtual call in expression
  - Virtual call in condition
  - Virtual destructor call
  - Static cast then virtual call
  - Virtual call through reference parameter
  - Multiple virtual calls in sequence
  - Virtual call with complex arguments

### Group 5: Integration & E2E (sequential)

**Task 8: Integration Tests** (Est. 4-5 hours)
- Create `tests/integration/handlers/VirtualMethodsIntegrationTest.cpp`
- Test complete virtual method pipeline
- **Tests** (30-35 tests):
  - Simple class with one virtual method
  - Class with multiple virtual methods
  - Single inheritance with virtual override
  - Single inheritance with inherited virtual
  - Multi-level inheritance (A -> B -> C)
  - Pure virtual (abstract) class
  - Concrete class implementing abstract
  - Virtual destructor
  - Virtual destructor inheritance
  - Mixed virtual/non-virtual methods
  - Virtual call through base pointer
  - Virtual call through derived pointer
  - Multiple derived classes from same base
  - Virtual method with complex return type
  - Virtual method with complex parameters
  - Const virtual method
  - Virtual method returning pointer
  - Virtual method with reference parameters
  - Polymorphic array of base pointers
  - Polymorphic function parameter
  - Virtual call in loop
  - Virtual call with method chaining
  - Override in multiple levels
  - Diamond inheritance (if supported)
  - Virtual method with default parameters

**Task 9: E2E Tests** (Est. 2-3 hours)
- Create `tests/e2e/phase45/VirtualMethodsE2ETest.cpp`
- Compile and execute generated C code
- **Tests** (15 tests):
  - 1 active sanity test (simple virtual call)
  - 2-3 active tests (polymorphic algorithms)
  - 10-12 disabled algorithm tests:
    - Shape hierarchy (Circle, Rectangle)
    - Animal hierarchy (Dog, Cat)
    - Stack interface with implementations
    - List interface with implementations
    - Iterator pattern
    - Strategy pattern
    - Observer pattern
    - Factory pattern
    - Plugin system
    - Event handler system

## COM Pattern Compliance

### Type Safety Requirements
1. **Strongly-typed function pointers**: Each method has explicit typedef
2. **No void* casts**: Type-specific function pointer types
3. **Const correctness**: Vtable instances are const
4. **Type compatibility**: Derived vtables compatible with base vtables

### Memory Layout Requirements
1. **lpVtbl first member**: COM requires vptr as first field
2. **Single pointer overhead**: Only one lpVtbl per object
3. **Static vtable storage**: Global const vtable instances
4. **ABI compatibility**: Layout matches C++ vtable layout

### Naming Conventions (COM Style)
- Vtable typedef: `ClassName_methodName_fn`
- Vtable struct: `ClassName_vtable`
- Vtable instance: `ClassName_vtable_instance`
- Vtable pointer field: `lpVtbl` (COM convention)
- Method implementation: `ClassName_methodName`

## Execution Strategy

### Parallel Execution Groups

**Group 1 (Tasks 1-2)**: Vtable Infrastructure - 2 parallel tasks
- Duration: ~3-4 hours parallel (vs ~6-8 hours sequential)

**Group 2 (Tasks 3-4)**: Struct Layout - 2 parallel tasks
- Duration: ~2-3 hours parallel (vs ~4-6 hours sequential)

**Group 3 (Task 5)**: Constructor Integration - 1 task
- Duration: ~2-3 hours

**Group 4 (Tasks 6-7)**: Virtual Call Translation - 2 parallel tasks
- Duration: ~3-4 hours parallel (vs ~5-7 hours sequential)

**Group 5 (Tasks 8-9)**: Integration/E2E - Sequential
- Duration: ~6-8 hours sequential

**Total Estimated Time:**
- Parallel: ~18-23 hours
- Sequential: ~30-40 hours
- **Time Savings: ~35-40%**

## Files to Create

1. `include/helpers/VtableTypedefGenerator.h` - Generate function pointer typedefs
2. `src/helpers/VtableTypedefGenerator.cpp` - Implementation
3. `tests/unit/helpers/VtableTypedefGeneratorTest.cpp` - Unit tests
4. `tests/integration/handlers/VirtualMethodsIntegrationTest.cpp` - Integration tests
5. `tests/e2e/phase45/VirtualMethodsE2ETest.cpp` - E2E tests
6. `.planning/phases/45-virtual-methods-com/PHASE45-COMPLETE.md` - Summary doc

## Files to Modify

1. `include/handlers/RecordHandler.h` - Add vtable generation methods
2. `src/handlers/RecordHandler.cpp` - Implement vtable/lpVtbl generation
3. `include/handlers/ConstructorHandler.h` - Add lpVtbl initialization
4. `src/handlers/ConstructorHandler.cpp` - Inject lpVtbl init code
5. `include/handlers/ExpressionHandler.h` - Add virtual call detection
6. `src/handlers/ExpressionHandler.cpp` - Implement virtual call translation
7. `include/handlers/HandlerContext.h` - Add vtable tracking
8. `src/handlers/HandlerContext.cpp` - Implement vtable tracking
9. `CMakeLists.txt` - Add new test targets

## Success Criteria

- [ ] All 90+ unit tests pass (100%)
- [ ] All 30-35 integration tests pass (100%)
- [ ] 1-3 E2E active tests pass (100%)
- [ ] Vtable structs use strongly-typed function pointers
- [ ] lpVtbl is first member in all polymorphic classes
- [ ] Vtable instances are static const
- [ ] Virtual calls use lpVtbl->method(obj, args) pattern
- [ ] Type safety verified (no void* casts)
- [ ] Generated C code compiles without warnings
- [ ] Code follows SOLID principles
- [ ] TDD followed throughout

## Verification

### Build and Test
```bash
cd build
cmake ..
make -j$(nproc)
ctest --output-on-failure
```

### Specific Test Suites
```bash
# Unit tests
./build/VtableTypedefGeneratorTest
./build/RecordHandlerTest
./build/ConstructorHandlerTest
./build/ExpressionHandlerTest

# Integration tests
./build/VirtualMethodsIntegrationTest

# E2E tests
./build/VirtualMethodsE2ETest
```

### Type Safety Check
```bash
# Verify no void* function pointers
grep -r "void.*\*.*lpVtbl" tests/output/*.c
# Should find NO matches

# Verify strongly-typed typedefs
grep -r "typedef.*_fn" tests/output/*.c
# Should find ALL virtual method typedefs
```

## Dependencies

**Requires:**
- Phase 44 (Classes Simple) - COMPLETE
- RecordHandler - class to struct translation
- MethodHandler - method to function translation
- ConstructorHandler - constructor initialization
- ExpressionHandler - method call translation

**External:**
- Clang AST API for virtual method detection
- Google Test framework
- CMake build system

## Risk Mitigation

**Risk 1: Type Safety Complexity**
- Mitigation: Use explicit typedefs for each method
- Fallback: Generate helper macros if needed
- Test: Comprehensive type compatibility tests

**Risk 2: Multiple Inheritance Complexity**
- Mitigation: Start with single inheritance only (Phase 46 for multiple)
- Document limitation clearly
- Test: Error or skip multiple inheritance classes

**Risk 3: Virtual Inheritance (Diamond Problem)**
- Mitigation: Defer to Phase 47
- Document as not supported
- Test: Skip or error on virtual inheritance

**Risk 4: Covariant Return Types**
- Mitigation: Handle with careful casting
- Document limitations
- Test: Covariant return test in E2E

## Next Steps After Completion

**Phase 46: Multiple Inheritance** - Est. 15-20 hours
- Multiple vtable pointers (lpVtbl, lpVtbl2, etc.)
- Thunk generation for non-primary bases
- Offset adjustments

**Phase 47: Virtual Inheritance** - Est. 20-25 hours
- Virtual base offset tables
- Virtual base pointer (vbptr)
- Diamond problem resolution

## References

### Microsoft COM/DCOM Documentation
- [Implementing objects in C | Microsoft Learn](https://learn.microsoft.com/en-us/office/client-developer/outlook/mapi/implementing-objects-in-c)
- [The layout of a COM object - The Old New Thing](https://devblogs.microsoft.com/oldnewthing/20040205-00/?p=40733)
- [Virtual Function Tables - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/multimedia/virtual-function-tables)

### Technical Resources
- [c++ - Implementing Vtable in C [SOLVED] | DaniWeb](https://www.daniweb.com/programming/software-development/threads/228277/implementing-vtable-in-c)
- [Virtual method table - Wikipedia](https://en.wikipedia.org/wiki/Virtual_method_table)

---

**Created**: 2025-12-26
**Status**: READY FOR IMPLEMENTATION
**Pattern**: Microsoft COM/DCOM with strongly-typed function pointers
