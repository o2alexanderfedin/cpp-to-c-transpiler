# Quick Start Tutorial

**Version:** 1.5.1
**Last Updated:** December 2025

Hands-on tutorial to get you transpiling C++ to C in minutes.

---

## Table of Contents

1. [Before You Begin](#before-you-begin)
2. [Tutorial 1: Your First Class](#tutorial-1-your-first-class)
3. [Tutorial 2: Inheritance and Polymorphism](#tutorial-2-inheritance-and-polymorphism)
4. [Tutorial 3: Templates and STL](#tutorial-3-templates-and-stl)
5. [Tutorial 4: Exception Handling](#tutorial-4-exception-handling)
6. [Tutorial 5: Smart Pointers and RAII](#tutorial-5-smart-pointers-and-raii)
7. [Understanding Generated Code](#understanding-generated-code)
8. [Common Patterns](#common-patterns)
9. [Next Steps](#next-steps)

---

## Before You Begin

### Prerequisites

Ensure you have completed:
- Installation of cpptoc transpiler (see [02-installation.md](02-installation.md))
- Verified installation with `./build/cpptoc --help`

### Current Implementation Status

**Note**: The transpiler is currently in **Phase 1 (Infrastructure Setup)**. These tutorials show:
- **Current behavior**: AST parsing and structure reporting
- **Future behavior**: Full C code generation (Phase 2+)

Each tutorial shows both the current output and the expected future output.

### Create a Working Directory

```bash
mkdir cpptoc-tutorial
cd cpptoc-tutorial
```

---

## Tutorial 1: Your First Class

### Step 1: Write a Simple C++ Class

Create `point.cpp`:

```cpp
// point.cpp
#include <cmath>

class Point {
    double x;
    double y;

public:
    Point(double px, double py) : x(px), y(py) {}

    double distanceFromOrigin() const {
        return sqrt(x * x + y * y);
    }

    void move(double dx, double dy) {
        x += dx;
        y += dy;
    }
};

int main() {
    Point p(3.0, 4.0);
    double dist = p.distanceFromOrigin();  // Should be 5.0
    p.move(1.0, 1.0);
    return 0;
}
```

### Step 2: Run the Transpiler

```bash
# Current Phase 1 behavior
../build/cpptoc point.cpp --
```

**Current Output (Phase 1):**
```
Parsed file: point.cpp
Translation unit has 2 top-level declarations
Found class: Point
  Found constructor: Point::Point
  Found method: Point::distanceFromOrigin
  Found method: Point::move
  Found field: Point::x
  Found field: Point::y
Found function: main
```

### Step 3: Understanding the Output

The transpiler successfully:
- Parsed the C++ file
- Identified the `Point` class
- Found all members (constructor, methods, fields)
- Recognized the `main` function

**Future Output (Phase 2+)** will generate `point.c`:

```c
// point.c - Generated by cpptoc
#include <math.h>
#include "cpptoc_runtime.h"

// Struct definition for Point
struct Point {
    double x;
    double y;
};

// Constructor: Point::Point(double, double)
void Point_ctor_d_d(struct Point* this, double px, double py) {
    this->x = px;
    this->y = py;
}

// Method: Point::distanceFromOrigin() const
double Point_distanceFromOrigin(const struct Point* this) {
    return sqrt(this->x * this->x + this->y * this->y);
}

// Method: Point::move(double, double)
void Point_move_d_d(struct Point* this, double dx, double dy) {
    this->x += dx;
    this->y += dy;
}

// main function
int main(void) {
    struct Point p;
    Point_ctor_d_d(&p, 3.0, 4.0);
    double dist = Point_distanceFromOrigin(&p);
    Point_move_d_d(&p, 1.0, 1.0);
    return 0;
}
```

### Key Translation Patterns

| C++ Construct | C Translation |
|---------------|---------------|
| `class Point` | `struct Point` |
| Constructor `Point(...)` | Function `Point_ctor_...()` |
| Method `move()` | Function `Point_move()` |
| `this` pointer | Explicit `struct Point* this` parameter |
| Member access `x` | `this->x` |

---

## Tutorial 2: Inheritance and Polymorphism

### Step 1: Create an Inheritance Hierarchy

Create `shapes.cpp`:

```cpp
// shapes.cpp
#include <cmath>

class Shape {
protected:
    double x, y;
public:
    Shape(double px, double py) : x(px), y(py) {}
    virtual ~Shape() {}
    virtual double area() const = 0;  // Pure virtual
};

class Circle : public Shape {
    double radius;
public:
    Circle(double px, double py, double r)
        : Shape(px, py), radius(r) {}

    double area() const override {
        return M_PI * radius * radius;
    }
};

class Rectangle : public Shape {
    double width, height;
public:
    Rectangle(double px, double py, double w, double h)
        : Shape(px, py), width(w), height(h) {}

    double area() const override {
        return width * height;
    }
};

int main() {
    Circle c(0, 0, 5);
    Rectangle r(0, 0, 4, 6);

    double circleArea = c.area();
    double rectArea = r.area();

    return 0;
}
```

### Step 2: Run the Transpiler

```bash
../build/cpptoc shapes.cpp --
```

**Current Output (Phase 1):**
```
Parsed file: shapes.cpp
Translation unit has 4 top-level declarations
Found class: Shape
  Found constructor: Shape::Shape
  Found destructor: Shape::~Shape (virtual)
  Found method: Shape::area (pure virtual)
  Found field: Shape::x
  Found field: Shape::y
Found class: Circle
  Inherits from: Shape
  Found constructor: Circle::Circle
  Found method: Circle::area (override)
  Found field: Circle::radius
Found class: Rectangle
  Inherits from: Shape
  Found constructor: Rectangle::Rectangle
  Found method: Rectangle::area (override)
  Found field: Rectangle::width
  Found field: Rectangle::height
Found function: main
```

### Step 3: Understanding Virtual Functions

The transpiler detects:
- **Virtual methods** (`area()`)
- **Pure virtual methods** (abstract base class)
- **Override relationships** (`Circle::area` overrides `Shape::area`)
- **Virtual destructors**

**Future Output** will include vtables:

```c
// Generated vtable for Shape
struct Shape_vtable {
    double (*area)(const struct Shape*);
    void (*destructor)(struct Shape*);
};

// Generated vtable for Circle
struct Circle_vtable {
    double (*area)(const struct Circle*);
    void (*destructor)(struct Circle*);
};

struct Circle {
    struct Circle_vtable* vptr;  // Virtual pointer
    double x, y;                  // Inherited from Shape
    double radius;                // Circle-specific
};

// Virtual call translation
double circleArea = c.vptr->area(&c);
```

---

## Tutorial 3: Templates and STL

### Step 1: Use Templates and STL

Create `container.cpp`:

```cpp
// container.cpp
#include <vector>
#include <string>
#include <map>

template<typename T>
class Container {
    T value;
public:
    Container(T v) : value(v) {}
    T get() const { return value; }
    void set(T v) { value = v; }
};

int main() {
    // Template instantiation
    Container<int> intContainer(42);
    Container<double> doubleContainer(3.14);

    // STL containers
    std::vector<int> numbers;
    numbers.push_back(1);
    numbers.push_back(2);
    numbers.push_back(3);

    std::map<std::string, int> ages;
    ages["Alice"] = 30;
    ages["Bob"] = 25;

    return 0;
}
```

### Step 2: Run the Transpiler

```bash
../build/cpptoc container.cpp --
```

**Current Output:**
```
Parsed file: container.cpp
Translation unit has 5 top-level declarations
Found class: Container<int>
  Found constructor: Container<int>::Container
  Found method: Container<int>::get
  Found method: Container<int>::set
  Found field: Container<int>::value
Found class: Container<double>
  Found constructor: Container<double>::Container
  Found method: Container<double>::get
  Found method: Container<double>::set
  Found field: Container<double>::value
Found class: std::vector<int>
  Found method: std::vector<int>::push_back
  ... (many STL methods)
Found class: std::map<std::string, int>
  ... (STL implementation)
Found function: main
```

### Step 3: Understanding Self-Bootstrapping

The transpiler sees **instantiated templates** in the AST:
- `Container<int>` and `Container<double>` are separate classes
- `std::vector<int>` is a fully instantiated template class
- All STL methods are visible and can be transpiled

**Key Insight**: No manual STL reimplementation needed! The transpiler treats STL like any other C++ code.

**Future Output** will monomorphize templates:

```c
// Container<int>
struct Container_int {
    int value;
};
void Container_int_ctor(struct Container_int* this, int v) {
    this->value = v;
}

// Container<double>
struct Container_double {
    double value;
};
void Container_double_ctor(struct Container_double* this, double v) {
    this->value = v;
}

// std::vector<int> becomes struct vector_int
struct vector_int {
    int* data;
    size_t size;
    size_t capacity;
};
void vector_int_push_back(struct vector_int* this, int value);
```

---

## Tutorial 4: Exception Handling

### Step 1: Use Exceptions

Create `exceptions.cpp`:

```cpp
// exceptions.cpp
#include <stdexcept>
#include <string>

class FileReader {
    std::string filename;
public:
    FileReader(const std::string& name) : filename(name) {}

    void read() {
        if (filename.empty()) {
            throw std::runtime_error("Empty filename");
        }
        // Read file...
    }
};

int main() {
    try {
        FileReader reader("");
        reader.read();
    } catch (const std::runtime_error& e) {
        // Handle error
        return 1;
    }
    return 0;
}
```

### Step 2: Run the Transpiler

```bash
../build/cpptoc exceptions.cpp --
```

**Current Output:**
```
Parsed file: exceptions.cpp
Found class: FileReader
  Found method: FileReader::read
Found function: main
  Found try-catch block
    Catch handler: std::runtime_error
  Found throw statement
```

### Step 3: Understanding Exception Translation

The transpiler identifies:
- `try` blocks
- `catch` handlers with type matching
- `throw` statements
- Exception types

**Future Output** uses PNaCl SJLJ pattern:

```c
#include <setjmp.h>
#include "cpptoc_runtime.h"

void FileReader_read(struct FileReader* this) {
    if (string_empty(&this->filename)) {
        // Throw exception
        struct RuntimeError err;
        RuntimeError_ctor(&err, "Empty filename");
        __cxx_throw(&err, &RuntimeError_typeinfo);
    }
}

int main(void) {
    CXXExceptionFrame frame;
    __cxx_frame_push(&frame);

    if (setjmp(frame.jmpbuf) == 0) {
        // Try block
        struct FileReader reader;
        FileReader_ctor(&reader, "");
        FileReader_read(&reader);
    } else {
        // Catch handler
        void* caught = __cxx_get_exception();
        if (__cxx_is_type(caught, &RuntimeError_typeinfo)) {
            struct RuntimeError* e = (struct RuntimeError*)caught;
            __cxx_frame_pop(&frame);
            return 1;
        }
    }

    __cxx_frame_pop(&frame);
    return 0;
}
```

---

## Tutorial 5: Smart Pointers and RAII

### Step 1: Use Smart Pointers

Create `smart_ptr.cpp`:

```cpp
// smart_ptr.cpp
#include <memory>

class Resource {
public:
    Resource() { /* Acquire resource */ }
    ~Resource() { /* Release resource */ }
    void use() { /* Use resource */ }
};

class Manager {
    std::unique_ptr<Resource> resource;
public:
    Manager() : resource(std::make_unique<Resource>()) {}

    void doWork() {
        resource->use();
    }
};

int main() {
    Manager m;
    m.doWork();
    // Resource automatically released when m goes out of scope
    return 0;
}
```

### Step 2: Run the Transpiler

```bash
../build/cpptoc smart_ptr.cpp --
```

**Current Output:**
```
Parsed file: smart_ptr.cpp
Found class: Resource
  Found constructor: Resource::Resource
  Found destructor: Resource::~Resource
  Found method: Resource::use
Found class: Manager
  Found constructor: Manager::Manager
  Found method: Manager::doWork
  Found field: Manager::resource (unique_ptr<Resource>)
Found function: main
```

### Step 3: Understanding RAII Translation

The transpiler recognizes:
- Constructors (resource acquisition)
- Destructors (resource release)
- Scope-based lifetime
- Smart pointer types

**Future Output** includes destructor injection:

```c
struct Resource {
    // Resource data
};
void Resource_ctor(struct Resource* this);
void Resource_dtor(struct Resource* this);

struct Manager {
    struct Resource* resource;  // Owned pointer
};

void Manager_ctor(struct Manager* this) {
    this->resource = malloc(sizeof(struct Resource));
    Resource_ctor(this->resource);
}

void Manager_dtor(struct Manager* this) {
    Resource_dtor(this->resource);
    free(this->resource);
    this->resource = NULL;
}

int main(void) {
    struct Manager m;
    Manager_ctor(&m);
    Manager_doWork(&m);
    Manager_dtor(&m);  // Automatically inserted at scope exit
    return 0;
}
```

---

## Understanding Generated Code

### Name Mangling

C doesn't support function overloading, so the transpiler mangles names:

| C++ | C (Mangled) |
|-----|-------------|
| `Point::Point(double, double)` | `Point_ctor_d_d` |
| `Point::move(double, double)` | `Point_move_d_d` |
| `Point::distanceFromOrigin()` | `Point_distanceFromOrigin` |
| `Container<int>::get()` | `Container_int_get` |

### This Pointer

C++ implicit `this` becomes explicit first parameter:

```cpp
// C++
void Point::move(double dx, double dy) {
    x += dx;  // Implicit: this->x
}

// C
void Point_move_d_d(struct Point* this, double dx, double dy) {
    this->x += dx;  // Explicit this
}
```

### Member Access

```cpp
// C++
p.move(1.0, 2.0);

// C
Point_move_d_d(&p, 1.0, 2.0);
```

---

## Common Patterns

### Pattern 1: Constructor Call

```cpp
// C++
Point p(3.0, 4.0);

// C (future)
struct Point p;
Point_ctor_d_d(&p, 3.0, 4.0);
```

### Pattern 2: Method Call

```cpp
// C++
double dist = p.distanceFromOrigin();

// C (future)
double dist = Point_distanceFromOrigin(&p);
```

### Pattern 3: Virtual Call

```cpp
// C++
Shape* s = new Circle(0, 0, 5);
double area = s->area();

// C (future)
struct Circle c;
Circle_ctor(&c, 0, 0, 5);
struct Shape* s = (struct Shape*)&c;
double area = s->vptr->area(s);
```

### Pattern 4: Exception Handling

```cpp
// C++
try {
    mayThrow();
} catch (const Error& e) {
    handle(e);
}

// C (future)
CXXExceptionFrame frame;
__cxx_frame_push(&frame);
if (setjmp(frame.jmpbuf) == 0) {
    mayThrow();
} else {
    void* caught = __cxx_get_exception();
    if (__cxx_is_type(caught, &Error_typeinfo)) {
        handle((struct Error*)caught);
    }
}
__cxx_frame_pop(&frame);
```

---

## Next Steps

Now that you understand basic transpilation:

1. **Learn Core Features**: Read [04-core-features.md](04-core-features.md)
2. **Explore Advanced Topics**: See [05-advanced-topics.md](05-advanced-topics.md)
3. **Review API Reference**: Command-line options and configuration
4. **Read Best Practices**: Code organization and optimization tips

### Experiment Further

Try transpiling your own code:

```bash
# Create a test file
cat > mycode.cpp << 'EOF'
#include <vector>

class MyClass {
    std::vector<int> data;
public:
    void add(int value) { data.push_back(value); }
    int size() const { return data.size(); }
};

int main() {
    MyClass obj;
    obj.add(42);
    return obj.size();
}
EOF

# Transpile
../build/cpptoc mycode.cpp --
```

### Join the Community

- **GitHub**: Report issues and contribute
- **Documentation**: Explore technical architecture
- **Discussions**: Share experiences and ask questions

---

**Happy Transpiling!**

*Generated with [Claude Code](https://claude.com/claude-code) | December 2025*
