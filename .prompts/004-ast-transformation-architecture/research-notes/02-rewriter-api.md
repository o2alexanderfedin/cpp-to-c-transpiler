# Research Note: Clang Rewriter API Analysis

**Research Date:** 2025-12-08
**Purpose:** Investigate Rewriter for text-based source transformation

---

## Executive Summary

**Verdict:** Rewriter is a **practical and powerful** API for text-based source modifications. It is the **preferred approach** for production refactoring tools.

**Key Finding:** clang-tidy and clang-refactor use Rewriter (NOT TreeTransform) for source transformation. This is a strong validation of the approach.

**Recommendation for C++ to C Converter:** Rewriter is **USEFUL BUT INSUFFICIENT** on its own. Best combined with RecursiveASTVisitor for analysis + custom code generation.

---

## What is Rewriter?

From Clang documentation:

> Rewriter - This is a simple class that allows semantic-free text manipulation of a source file. It manages changes and ensures they are properly applied.

**Location:** `clang/include/clang/Rewrite/Core/Rewriter.h`

**Design Purpose:** Text-based source modification
- Insert text at locations
- Delete text ranges
- Replace text ranges
- Track changes across multiple files

**Key Characteristic:** Rewriter operates on SOURCE TEXT, not AST. It does not update the AST.

---

## How Rewriter Works

### Basic Architecture

```cpp
#include "clang/Rewrite/Core/Rewriter.h"

class MyASTConsumer : public ASTConsumer {
    Rewriter rewriter;

public:
    void Initialize(ASTContext &Context) override {
        rewriter.setSourceMgr(Context.getSourceManager(),
                              Context.getLangOpts());
    }

    void HandleTranslationUnit(ASTContext &Context) override {
        // Use RecursiveASTVisitor to find nodes
        // Use Rewriter to modify source

        // Get the rewritten buffer
        const RewriteBuffer *buf =
            rewriter.getRewriteBufferFor(Context.getSourceManager().getMainFileID());

        if (buf) {
            std::string output(buf->begin(), buf->end());
            // ... write output
        }
    }
};
```

### Core API Methods

**1. InsertText:**
```cpp
// Insert text at specific source location
bool InsertText(SourceLocation Loc, StringRef Str,
                bool InsertAfter = true);

// Insert text before a range
bool InsertTextBefore(SourceLocation Loc, StringRef Str);

// Insert text after a range
bool InsertTextAfter(SourceLocation Loc, StringRef Str);
```

**2. ReplaceText:**
```cpp
// Replace a range with new text
bool ReplaceText(SourceRange Range, StringRef NewStr);

// Replace using SourceLocation + length
bool ReplaceText(SourceLocation Start, unsigned Length,
                 StringRef NewStr);
```

**3. RemoveText:**
```cpp
// Remove text in a range
bool RemoveText(SourceRange Range);
```

**4. Getting Results:**
```cpp
// Get rewritten buffer for a file
const RewriteBuffer *getRewriteBufferFor(FileID FID);

// Write all changes to output stream
void overwriteChangedFiles(); // Writes back to original files
```

---

## Integration with RecursiveASTVisitor

### Typical Pattern:

```cpp
class MyTransformer : public RecursiveASTVisitor<MyTransformer> {
    ASTContext &context;
    Rewriter &rewriter;

public:
    MyTransformer(ASTContext &C, Rewriter &R) : context(C), rewriter(R) {}

    // Visit function declarations
    bool VisitFunctionDecl(FunctionDecl *F) {
        if (!F->hasBody()) return true;

        SourceLocation bodyStart = F->getBody()->getBeginLoc();

        // Insert text at start of function body
        rewriter.InsertTextAfter(bodyStart,
            "// Auto-generated by tool\n");

        return true;
    }

    // Visit throw expressions
    bool VisitCXXThrowExpr(CXXThrowExpr *E) {
        SourceRange range = E->getSourceRange();

        // Replace throw with function call
        rewriter.ReplaceText(range, "__cxx_throw(exception_object)");

        return true;
    }
};
```

---

## Practical Example: Adding Comments

From Eli Bendersky's tutorial:

### Input C++ Code:
```cpp
int foo(int x) {
    return x + 1;
}

void bar() {
    if (true) {
        foo(10);
    }
}
```

### Rewriter Transformation:
```cpp
bool VisitFunctionDecl(FunctionDecl *F) {
    if (F->hasBody()) {
        // Insert comment before function
        SourceLocation loc = F->getBeginLoc();
        rewriter.InsertTextBefore(loc,
            "// Function: " + F->getNameAsString() + "\n");

        // Insert comment after function
        Stmt *body = F->getBody();
        SourceLocation endLoc = body->getEndLoc().getLocWithOffset(1);
        rewriter.InsertText(endLoc,
            "\n// End of " + F->getNameAsString() + "\n");
    }
    return true;
}

bool VisitIfStmt(IfStmt *I) {
    // Insert comment inside if statement
    Stmt *then = I->getThen();
    SourceLocation thenLoc = then->getBeginLoc().getLocWithOffset(1);
    rewriter.InsertText(thenLoc, "\n// Inside if\n");
    return true;
}
```

### Output:
```cpp
// Function: foo
int foo(int x) {
    return x + 1;
}
// End of foo

// Function: bar
void bar() {
    if (true) {
// Inside if
        foo(10);
    }
}
// End of bar
```

---

## Capabilities

### What Rewriter CAN Do

**1. Text manipulation:**
- ✅ Insert text at any source location
- ✅ Replace text ranges
- ✅ Delete text ranges
- ✅ Multiple changes in single pass

**2. Multi-file support:**
- ✅ Track changes across multiple files
- ✅ Header and source file modifications

**3. Precise location control:**
- ✅ Insert before/after specific locations
- ✅ Use AST source ranges for accuracy

**4. Simple integration:**
- ✅ Works with RecursiveASTVisitor
- ✅ No Sema required
- ✅ Straightforward API

### What Rewriter CANNOT Do

**1. AST updates:**
- ❌ Does NOT update AST
- ❌ Changes are text-only
- ❌ Cannot re-analyze after changes

**2. Semantic awareness:**
- ❌ No type checking
- ❌ No semantic validation
- ❌ Text-based only

**3. Complex restructuring:**
- ❌ Difficult to restructure CFG
- ❌ Hard to track logical relationships
- ❌ No control flow analysis

---

## Rewriter in Production Tools

### clang-tidy

clang-tidy uses Rewriter for applying fixes:

```cpp
// From clang-tidy check implementation
void check(const MatchFinder::MatchResult &Result) {
    const auto *Call = Result.Nodes.getNodeAs<CallExpr>("call");

    // Create fix using Rewriter-style replacement
    diag(Call->getBeginLoc(), "use new API")
        .FixItHint::CreateReplacement(Call->getSourceRange(),
                                       "new_api_call()");
}
```

**Key Insight:** The most widely-used Clang refactoring tool uses text replacement, NOT TreeTransform!

### clang-refactor

Clang's official refactoring engine uses Rewriter:

From documentation:
> The refactoring engine applies refactoring actions using source transformations defined by a set of refactoring operations.

Uses `AtomicChange` which is built on Rewriter concepts.

### Microsoft C++ Refactoring

From Microsoft C++ blog on clang-tidy:
> The Rewriter class facilitates easy modification of the original source code.

---

## Limitations for C++ to C Converter

### Limitation 1: Insufficient for Full Conversion

**Problem:** Rewriter can modify source text, but cannot GENERATE complete C code.

**Example - RAII:**
```cpp
void func() {
    Resource r;  // Constructor
    use(r);
    // Destructor needed here
}
```

**What Rewriter can do:**
- Insert `Resource__dtor(&r);` at end
- Replace `Resource r` with `Resource r; Resource__ctor(&r);`

**What Rewriter CANNOT do:**
- Generate struct definition for Resource
- Generate constructor/destructor functions
- Handle complex class hierarchies

### Limitation 2: Cannot Generate New Files

**Problem:** C++ to C conversion often needs NEW C files.

**Example:**
- C++ header → C header + C source
- Template instantiations → Multiple C functions
- Class definitions → Struct definitions + vtables

**Rewriter only modifies existing files.**

### Limitation 3: No Type Information

**Problem:** Rewriter is text-based, doesn't understand types.

**Example - Name Mangling:**
```cpp
void foo(int x);    // → foo__int
void foo(double x); // → foo__double
```

**Rewriter cannot:**
- Determine function signature types
- Generate mangled names
- Resolve overload sets

Need AST analysis for this.

---

## Hybrid Approach: Rewriter + Custom Generation

### Recommended Pattern for C++ to C Converter:

**1. Use RecursiveASTVisitor for analysis:**
```cpp
class CppAnalyzer : public RecursiveASTVisitor<CppAnalyzer> {
    // Collect information about classes, functions, etc.
    std::vector<ClassInfo> classes;
    std::vector<FunctionInfo> functions;
};
```

**2. Use custom code generator for C output:**
```cpp
class CCodeGenerator {
    std::string generateStruct(const ClassInfo &info);
    std::string generateFunction(const FunctionInfo &info);
    std::string generateVTable(const ClassInfo &info);
};
```

**3. Use Rewriter only for simple transformations:**
```cpp
// For simple replacements like nullptr → NULL
rewriter.ReplaceText(nullptrExpr->getSourceRange(), "NULL");
```

**Rationale:** Rewriter is too limited for full C++ to C conversion. Use it only for targeted text replacements.

---

## Comparison: Rewriter vs Direct Generation

| Feature | Rewriter | Direct Generation |
|---------|----------|-------------------|
| **Modify existing code** | ✅ Easy | ❌ N/A |
| **Generate new code** | ⚠️ Limited | ✅ Full control |
| **Multi-file output** | ⚠️ Limited | ✅ Full control |
| **Type awareness** | ❌ No | ✅ Via AST |
| **Name mangling** | ❌ Cannot | ✅ Full control |
| **Struct generation** | ❌ Cannot | ✅ Yes |
| **VTable generation** | ❌ Cannot | ✅ Yes |
| **Code organization** | ❌ Cannot | ✅ Full control |

---

## Use Cases Where Rewriter Shines

**1. Simple refactoring:**
- Rename identifiers
- Update API calls
- Add/remove qualifiers

**2. Annotation addition:**
- Add comments
- Add attributes
- Add preprocessor directives

**3. Format corrections:**
- Style adjustments
- Whitespace fixes
- Simple text replacements

**4. Incremental transformation:**
- Modify existing C++ to work with C runtime
- Add runtime library calls to existing code

---

## Use Cases Where Rewriter Fails

**1. Complete code generation:**
```cpp
// Need to generate struct + functions
class MyClass {
    int x;
    void foo();
};

// Rewriter cannot generate:
struct MyClass { int x; };
void MyClass__foo(struct MyClass* this);
```

**2. File structure changes:**
```cpp
// MyClass.hpp
// Need to split into:
// - MyClass.h (struct definition)
// - MyClass.c (function implementations)
// - MyClass_vtable.c (vtable data)
```

**3. Complex data structures:**
```cpp
// Need to generate vtables, VTT, type_info
// Rewriter has no mechanism for this
```

---

## Practical Assessment for C++ to C Converter

### RAII Destructor Injection: ⚠️ PARTIAL

**What Rewriter can do:**
- Insert destructor calls at known locations
- Simple cases work

**What Rewriter cannot do:**
- Generate destructor function definitions
- Handle complex CFG cases
- Generate cleanup code for exceptions

**Verdict:** Rewriter can help with insertion, but need custom generation for definitions.

### Exception Handling: ⚠️ PARTIAL

**What Rewriter can do:**
- Replace `throw` with `__cxx_throw()` calls
- Insert exception frame declarations

**What Rewriter cannot do:**
- Generate exception frame structures
- Generate action tables
- Restructure try/catch to setjmp/longjmp

**Verdict:** Rewriter helps with simple replacements, but need custom generation for runtime.

### Class Conversion: ❌ INSUFFICIENT

**What Rewriter can do:**
- Minimal: rename class keyword to struct

**What Rewriter cannot do:**
- Generate member function definitions
- Generate vtables
- Generate constructors/destructors as C functions

**Verdict:** Rewriter is insufficient. Need full code generation.

### Function Conversion: ✅ PARTIALLY USEFUL

**What Rewriter can do:**
- Add `this` parameter to methods
- Replace `nullptr` with `NULL`
- Simple syntax adjustments

**What Rewriter cannot do:**
- Handle overload resolution
- Generate mangled names
- Create separate declarations/definitions

**Verdict:** Useful for simple replacements, but insufficient alone.

---

## Integration Example: Rewriter + Custom Generator

### Hybrid Architecture:

```cpp
class CppToCConverter {
    ASTContext &context;
    Rewriter rewriter;
    CCodeEmitter emitter;  // Custom C code generator

public:
    void Convert() {
        // Phase 1: Analyze AST
        AnalysisVisitor analyzer(context);
        analyzer.TraverseDecl(context.getTranslationUnitDecl());

        // Phase 2: Generate C structures/functions
        for (const ClassInfo &cls : analyzer.getClasses()) {
            std::string c_code = emitter.generateClass(cls);
            // Write to output files
        }

        // Phase 3: Use Rewriter for simple replacements
        SimpleReplacementVisitor replacer(context, rewriter);
        replacer.TraverseDecl(context.getTranslationUnitDecl());
        // Replace: nullptr → NULL, bool → _Bool, etc.

        // Output results
        emitter.writeAllFiles();
        // rewriter.overwriteChangedFiles();  // Usually NOT what we want
    }
};
```

---

## Final Assessment

### Rewriter for C++ to C Converter

**Strengths:**
- ✅ Simple API
- ✅ Good for text replacements
- ✅ Used by production tools
- ✅ Easy integration with RecursiveASTVisitor

**Weaknesses:**
- ❌ Cannot generate new code structures
- ❌ No type awareness
- ❌ Limited to existing source files
- ❌ Insufficient for full conversion

### Recommendation: USE REWRITER SPARINGLY

**Use Rewriter for:**
1. Simple keyword replacements (`nullptr` → `NULL`)
2. Trivial syntax adjustments
3. Prototyping transformations

**Do NOT rely on Rewriter for:**
1. Primary code generation
2. Struct/function generation
3. Multi-file output management
4. Complex transformations

**Primary approach should be:** RecursiveASTVisitor (analysis) + Custom Code Generator (output)

---

## Key Lesson from Production Tools

**Why do clang-tidy and clang-refactor use Rewriter?**

Answer: They do REFACTORING, not TRANSPILATION.

- **Refactoring:** Modify existing C++ to different C++
  - Rewriter works great here
  - Text-based changes sufficient

- **Transpilation:** Convert C++ to C
  - Needs full code generation
  - Needs new file structure
  - Needs type-aware transformations
  - Rewriter insufficient

**C++ to C is transpilation, NOT refactoring.**

---

## Conclusion

**Rewriter is a useful supporting tool, but NOT the primary mechanism for C++ to C conversion.**

While Rewriter excels at text-based source modifications for refactoring, it lacks the capabilities needed for full transpilation:
- Cannot generate complete new code structures
- No type awareness for name mangling
- Limited to modifying existing files
- Insufficient for complex transformations

**Recommendation:** Use RecursiveASTVisitor + custom C code generator as primary approach. Use Rewriter only for simple syntax replacements.

---

## References

1. [Eli Bendersky: Basic source-to-source transformation with Clang](https://eli.thegreenplace.net/2012/06/08/basic-source-to-source-transformation-with-clang)
2. [Eli Bendersky: Modern source-to-source transformation with Clang and libTooling](https://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling)
3. [GitHub: eliben/llvm-clang-samples - rewritersample.cpp](https://github.com/eliben/llvm-clang-samples/blob/master/src_clang/rewritersample.cpp)
4. [Microsoft: Exploring Clang Tooling Part 3: Rewriting Code with clang-tidy](https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-3-rewriting-code-with-clang-tidy/)
5. [Clang Rewriter Class Reference](https://clang.llvm.org/doxygen/classclang_1_1Rewriter.html)
