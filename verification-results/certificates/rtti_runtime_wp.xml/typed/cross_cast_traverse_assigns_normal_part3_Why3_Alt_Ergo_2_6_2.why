(* WP Task for Prover Alt-Ergo,2.6.2 *)
;;; this is a prelude for Alt-Ergo, Dolmen frontend
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
;; "CompatOrderMult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; "abs"
(define-fun abs1 ((x Int)) Int
  (ite (<= 0 x) x (- x)))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= (- y) x))))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= x y))))

;; "Abs_le"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= (- y) x) (<= x y)) (<= (abs1 x) y))))

;; "Abs_pos"
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; "div"
(declare-fun div1 (Int
  Int) Int)

;; "mod"
(declare-fun mod1 (Int
  Int) Int)

;; "Div_mod"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= (div1 x y) x))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (- (abs1 y)) (mod1 x y)))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (mod1 x y) (abs1 y)))))

;; "Div_sign_pos"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_sign_neg"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; "Mod_sign_pos"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; "Mod_sign_neg"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; "Rounds_toward_zero"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; "Div_1"
(assert (forall ((x Int)) (= (div1 x 1) x)))

;; "Mod_1"
(assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; "Div_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; "Mod_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; "Div_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                                  (+ (* x y) z)
                                                                  x)) )))

;; "Mod_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1
                                                            (+ (* x y) z)
                                                            x)) )))

;; "CompatOrderMult"
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (<= x y) (=> (<= 0.0 z) (<= (* x z) (* y z))))))

;; "c_euclidian"
(assert
  (forall ((n Int) (d Int))
    (! (=> (not (= d 0)) (= n (+ (* (div1 n d) d) (mod1 n d)))) :pattern (
    (div1
      n
      d)
    (mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (< (mod1 n d) d))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (< (- d) (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (< (mod1 n d) (- d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (< d (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cdiv_neutral"
(assert (forall ((a Int)) (! (= (div1 a 1) a) :pattern ((div1 a 1)) )))

;; "cdiv_inv"
(assert
  (forall ((a Int))
    (! (=> (not (= a 0)) (= (div1 a a) 1)) :pattern ((div1 a a)) )))

;; "cdiv_closed_remainder"
(assert
  (forall ((a Int) (b Int) (n Int))
    (=>
      (<= 0 a)
      (=>
        (<= 0 b)
        (=>
          (and (<= 0 (- b a)) (< (- b a) n))
          (=> (= (mod1 a n) (mod1 b n)) (= a b)))))))

(declare-datatypes ((addr 0))
  (((addrqtmk (base Int)(offset Int)))))

;; "null"
(define-fun null () addr
  (addrqtmk 0 0))

;; "addr_le"
(declare-fun addr_le (addr
  addr) Bool)

;; "addr_lt"
(declare-fun addr_lt (addr
  addr) Bool)

;; "addr_le_bool"
(declare-fun addr_le_bool (addr
  addr) Bool)

;; "addr_lt_bool"
(declare-fun addr_lt_bool (addr
  addr) Bool)

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_le p q) (<= (offset p) (offset q)))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (<= (offset p) (offset q)) (addr_le p q))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_lt p q) (< (offset p) (offset q)))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (< (offset p) (offset q)) (addr_lt p q))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_le p q) (= (addr_le_bool p q) true)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_le_bool p q) true) (addr_le p q)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_lt p q) (= (addr_lt_bool p q) true)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_lt_bool p q) true) (addr_lt p q)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "shift"
(define-fun shift ((p addr) (k Int)) addr
  (addrqtmk (base p) (+ (offset p) k)))

;; "valid_rw"
(define-fun valid_rw ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (< 0 (base p))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rd"
(define-fun valid_rd ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (not (= 0 (base p)))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rw_rd"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (forall ((n Int)) (=> (valid_rw m p n) (valid_rd m p n))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (valid_rd m p 1))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (not (valid_rw m p 1)))))))

;; "included"
(define-fun included ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (=>
    (< 0 lp)
    (and
      (<= 0 lq)
      (and
        (= (base p) (base q))
        (and
          (<= (offset q) (offset p))
          (<= (+ (offset p) lp) (+ (offset q) lq)))))))

;; "separated"
(define-fun separated ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (or
    (<= lp 0)
    (or
      (<= lq 0)
      (or
        (not (= (base p) (base q)))
        (or
          (<= (+ (offset q) lq) (offset p))
          (<= (+ (offset p) lp) (offset q)))))))

;; "separated_1"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int) (i Int) (j Int))
      (! (=>
           (separated p lp q lq)
           (=>
             (and (<= (offset p) i) (< i (+ (offset p) lp)))
             (=>
               (and (<= (offset q) j) (< j (+ (offset q) lq)))
               (not (= (addrqtmk (base p) i) (addrqtmk (base q) j)))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (addrqtmk (base p) i)
      (addrqtmk (base q) j)) ))))

;; "separated_included"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=>
           (< 0 lp)
           (=>
             (< 0 lq)
             (=> (separated p lp q lq) (not (included p lp q lq))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (included p lp q lq)) ))))

;; "included_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (included q lq r lr) (included p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (included q lq r lr)) ))))

;; "separated_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (separated q lq r lr) (separated p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (separated q lq r lr)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated p lp q lq) (separated q lq p lp)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated q lq p lp) (separated p lp q lq)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "region"
(declare-fun region (Int) Int)

;; "linked"
(declare-fun linked ((Array Int Int)) Bool)

;; "static_malloc"
(declare-fun static_malloc (Int) Int)

;; "statically_allocated"
(define-fun statically_allocated ((base1 Int)) Bool
  (or (= base1 0) (< 0 (static_malloc base1))))

;; "valid_pointers_are_statically_allocated"
(assert
  (forall ((a addr) (m (Array Int Int)) (n Int))
    (=> (< 0 n) (=> (valid_rd m a n) (statically_allocated (base a))))))

;; "int_of_addr"
(declare-fun int_of_addr (addr) Int)

;; "addr_of_int"
(declare-fun addr_of_int (Int) addr)

;; "addr_of_null"
(assert (= (int_of_addr null) 0))

;; "addr_of_int_bijection"
(assert
  (forall ((p addr))
    (=> (statically_allocated (base p)) (= (addr_of_int (int_of_addr p)) p))))

(declare-sort table 0)

;; "table_to_offset"
(declare-fun table_to_offset (table
  Int) Int)

;; "table_to_offset_zero"
(assert (forall ((t table)) (= (table_to_offset t 0) 0)))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= o1 o2) (<= (table_to_offset t o1) (table_to_offset t o2))))))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= (table_to_offset t o1) (table_to_offset t o2)) (<= o1 o2)))))

;; "framed"
(define-fun framed ((m (Array addr addr))) Bool
  (forall ((p addr))
    (! (=> (<= (region (base p)) 0) (<= (region (base (select m p))) 0)) :pattern ((select m p)) )))

;; "eqmem"
(define-fun eqmem (par (a)
  ((m1 (Array addr a)) (m2 (Array addr a)) (p addr) (n Int)) Bool
  (forall ((q addr))
    (! (=> (included q 1 p n) (= (select m1 q) (select m2 q))) :pattern ((select m1 q)) :pattern ((select m2 q)) ))))

;; "memcpy"
(declare-fun memcpy (par (a)
  ((Array addr a)
  addr
  (Array addr a)
  addr
  Int) (Array addr a)))

;; "memcpy'def"
(assert (par (a)
  (forall ((m0 (Array addr a)) (a0 addr) (m1 (Array addr a)) (a1 addr) (s Int) (p addr))
    (= (select (memcpy m0 a0 m1 a1 s) p) (ite (separated p 1 a0 s)
                                           (select m0 p)
                                           (let ((offset1 (+ (- (offset a1) 
                                             (offset
                                               a0)) (offset p))))
                                             (select m1 (addrqtmk
                                                          (base a1)
                                                          offset1))))))))

;; "eqmem_single"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (=> (eqmem m1 m2 p 1) (= (select m1 p) (select m2 p)))))))

;; "eqmem_single"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (=> (= (select m1 p) (select m2 p)) (eqmem m1 m2 p 1))))))

;; "eqmem_included"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr) (q addr))
      (forall ((a1 Int) (b Int))
        (! (=> (included p a1 q b) (=> (eqmem m1 m2 q b) (eqmem m1 m2 p a1))) :pattern (
        (eqmem
          m1
          m2
          p
          a1)
        (eqmem m1 m2 q b)) ))))))

;; "eqmem_sym"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (forall ((a1 Int)) (=> (eqmem m1 m2 p a1) (eqmem m2 m1 p a1)))))))

;; "eqmem_update"
(assert (par (a)
  (forall ((m0 (Array addr a)))
    (forall ((v a))
      (forall ((p addr) (q addr))
        (forall ((nqt Int))
          (=> (separated p 1 q nqt) (eqmem m0 (store m0 p v) q nqt))))))))

;; "eqmem_memcpy"
(assert (par (a)
  (forall ((m0 (Array addr a)) (m1 (Array addr a)))
    (forall ((p addr) (pqt addr) (q addr))
      (forall ((n Int) (nqt Int))
        (=> (separated p n pqt nqt) (eqmem m0 (memcpy m0 p m1 q n) pqt nqt)))))))

;; "P_valid_type_info"
(define-fun P_valid_type_info ((Malloc (Array Int Int)) (Mptr (Array addr addr)) (t addr)) Bool
  (and (valid_rd Malloc t 2) (valid_rd Malloc (select Mptr (shift t 1)) 1)))

;; Goal "wp_goal"
(assert
  (not
  (forall ((t (Array Int Int)) (t1 (Array addr addr)) (a1 addr) (a2 addr) (a3 addr) (a4 addr))
    (=>
      (not (= a4 a1))
      (=>
        (not (= null a4))
        (=>
          (not (= null a3))
          (=>
            (not (= null a2))
            (=>
              (not (= null a1))
              (=>
                (<= (region (base a4)) 0)
                (=>
                  (<= (region (base a3)) 0)
                  (=>
                    (<= (region (base a2)) 0)
                    (=>
                      (<= (region (base a1)) 0)
                      (=>
                        (linked t)
                        (=>
                          (framed t1)
                          (=>
                            (valid_rd t a3 1)
                            (=>
                              (P_valid_type_info t t1 a4)
                              (=>
                                (P_valid_type_info t t1 a2)
                                (not (P_valid_type_info t t1 a1)))))))))))))))))))

(check-sat)
