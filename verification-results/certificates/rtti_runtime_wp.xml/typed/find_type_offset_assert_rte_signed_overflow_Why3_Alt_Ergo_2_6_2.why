(* WP Task for Prover Alt-Ergo,2.6.2 *)
;;; this is a prelude for Alt-Ergo, Dolmen frontend
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
;; "CompatOrderMult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; "abs"
(define-fun abs1 ((x Int)) Int
  (ite (<= 0 x) x (- x)))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= (- y) x))))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= x y))))

;; "Abs_le"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= (- y) x) (<= x y)) (<= (abs1 x) y))))

;; "Abs_pos"
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; "div"
(declare-fun div1 (Int
  Int) Int)

;; "mod"
(declare-fun mod1 (Int
  Int) Int)

;; "Div_mod"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= (div1 x y) x))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (- (abs1 y)) (mod1 x y)))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (mod1 x y) (abs1 y)))))

;; "Div_sign_pos"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_sign_neg"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; "Mod_sign_pos"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; "Mod_sign_neg"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; "Rounds_toward_zero"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; "Div_1"
(assert (forall ((x Int)) (= (div1 x 1) x)))

;; "Mod_1"
(assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; "Div_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; "Mod_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; "Div_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                                  (+ (* x y) z)
                                                                  x)) )))

;; "Mod_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1
                                                            (+ (* x y) z)
                                                            x)) )))

;; "CompatOrderMult"
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (<= x y) (=> (<= 0.0 z) (<= (* x z) (* y z))))))

;; "c_euclidian"
(assert
  (forall ((n Int) (d Int))
    (! (=> (not (= d 0)) (= n (+ (* (div1 n d) d) (mod1 n d)))) :pattern (
    (div1
      n
      d)
    (mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (< (mod1 n d) d))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (< (- d) (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (< (mod1 n d) (- d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (< d (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cdiv_neutral"
(assert (forall ((a Int)) (! (= (div1 a 1) a) :pattern ((div1 a 1)) )))

;; "cdiv_inv"
(assert
  (forall ((a Int))
    (! (=> (not (= a 0)) (= (div1 a a) 1)) :pattern ((div1 a a)) )))

;; "cdiv_closed_remainder"
(assert
  (forall ((a Int) (b Int) (n Int))
    (=>
      (<= 0 a)
      (=>
        (<= 0 b)
        (=>
          (and (<= 0 (- b a)) (< (- b a) n))
          (=> (= (mod1 a n) (mod1 b n)) (= a b)))))))

(declare-datatypes ((addr 0))
  (((addrqtmk (base Int)(offset Int)))))

;; "null"
(define-fun null () addr
  (addrqtmk 0 0))

;; "addr_le"
(declare-fun addr_le (addr
  addr) Bool)

;; "addr_lt"
(declare-fun addr_lt (addr
  addr) Bool)

;; "addr_le_bool"
(declare-fun addr_le_bool (addr
  addr) Bool)

;; "addr_lt_bool"
(declare-fun addr_lt_bool (addr
  addr) Bool)

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_le p q) (<= (offset p) (offset q)))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (<= (offset p) (offset q)) (addr_le p q))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_lt p q) (< (offset p) (offset q)))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (< (offset p) (offset q)) (addr_lt p q))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_le p q) (= (addr_le_bool p q) true)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_le_bool p q) true) (addr_le p q)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_lt p q) (= (addr_lt_bool p q) true)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_lt_bool p q) true) (addr_lt p q)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "shift"
(define-fun shift ((p addr) (k Int)) addr
  (addrqtmk (base p) (+ (offset p) k)))

;; "valid_rw"
(define-fun valid_rw ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (< 0 (base p))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rd"
(define-fun valid_rd ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (not (= 0 (base p)))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rw_rd"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (forall ((n Int)) (=> (valid_rw m p n) (valid_rd m p n))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (valid_rd m p 1))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (not (valid_rw m p 1)))))))

;; "included"
(define-fun included ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (=>
    (< 0 lp)
    (and
      (<= 0 lq)
      (and
        (= (base p) (base q))
        (and
          (<= (offset q) (offset p))
          (<= (+ (offset p) lp) (+ (offset q) lq)))))))

;; "separated"
(define-fun separated ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (or
    (<= lp 0)
    (or
      (<= lq 0)
      (or
        (not (= (base p) (base q)))
        (or
          (<= (+ (offset q) lq) (offset p))
          (<= (+ (offset p) lp) (offset q)))))))

;; "separated_1"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int) (i Int) (j Int))
      (! (=>
           (separated p lp q lq)
           (=>
             (and (<= (offset p) i) (< i (+ (offset p) lp)))
             (=>
               (and (<= (offset q) j) (< j (+ (offset q) lq)))
               (not (= (addrqtmk (base p) i) (addrqtmk (base q) j)))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (addrqtmk (base p) i)
      (addrqtmk (base q) j)) ))))

;; "separated_included"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=>
           (< 0 lp)
           (=>
             (< 0 lq)
             (=> (separated p lp q lq) (not (included p lp q lq))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (included p lp q lq)) ))))

;; "included_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (included q lq r lr) (included p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (included q lq r lr)) ))))

;; "separated_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (separated q lq r lr) (separated p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (separated q lq r lr)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated p lp q lq) (separated q lq p lp)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated q lq p lp) (separated p lp q lq)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "region"
(declare-fun region (Int) Int)

;; "linked"
(declare-fun linked ((Array Int Int)) Bool)

;; "static_malloc"
(declare-fun static_malloc (Int) Int)

;; "statically_allocated"
(define-fun statically_allocated ((base1 Int)) Bool
  (or (= base1 0) (< 0 (static_malloc base1))))

;; "valid_pointers_are_statically_allocated"
(assert
  (forall ((a addr) (m (Array Int Int)) (n Int))
    (=> (< 0 n) (=> (valid_rd m a n) (statically_allocated (base a))))))

;; "int_of_addr"
(declare-fun int_of_addr (addr) Int)

;; "addr_of_int"
(declare-fun addr_of_int (Int) addr)

;; "addr_of_null"
(assert (= (int_of_addr null) 0))

;; "addr_of_int_bijection"
(assert
  (forall ((p addr))
    (=> (statically_allocated (base p)) (= (addr_of_int (int_of_addr p)) p))))

(declare-sort table 0)

;; "table_to_offset"
(declare-fun table_to_offset (table
  Int) Int)

;; "table_to_offset_zero"
(assert (forall ((t table)) (= (table_to_offset t 0) 0)))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= o1 o2) (<= (table_to_offset t o1) (table_to_offset t o2))))))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= (table_to_offset t o1) (table_to_offset t o2)) (<= o1 o2)))))

;; "shift_S3___base_class_type_info"
(define-fun shift_S3___base_class_type_info ((p addr) (k Int)) addr
  (shift p (* 2 k)))

;; "is_bool"
(define-fun is_bool ((x Int)) Bool
  (or (= x 0) (= x 1)))

;; "is_uint8"
(define-fun is_uint8 ((x Int)) Bool
  (and (<= 0 x) (< x 256)))

;; "is_sint8"
(define-fun is_sint8 ((x Int)) Bool
  (and (<= (- 128) x) (< x 128)))

;; "is_uint16"
(define-fun is_uint16 ((x Int)) Bool
  (and (<= 0 x) (< x 65536)))

;; "is_sint16"
(define-fun is_sint16 ((x Int)) Bool
  (and (<= (- 32768) x) (< x 32768)))

;; "is_uint32"
(define-fun is_uint32 ((x Int)) Bool
  (and (<= 0 x) (< x 4294967296)))

;; "is_sint32"
(define-fun is_sint32 ((x Int)) Bool
  (and (<= (- 2147483648) x) (< x 2147483648)))

;; "is_uint64"
(define-fun is_uint64 ((x Int)) Bool
  (and (<= 0 x) (< x 18446744073709551616)))

;; "is_sint64"
(define-fun is_sint64 ((x Int)) Bool
  (and (<= (- 9223372036854775808) x) (< x 9223372036854775808)))

;; "is_bool0"
(assert (is_bool 0))

;; "is_bool1"
(assert (is_bool 1))

;; "to_uint8"
(declare-fun to_uint8 (Int) Int)

;; "to_uint8'def"
(assert
  (forall ((x Int)) (=> (< x 0) (= (to_uint8 x) (to_uint8 (+ x 256))))))

;; "to_uint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (<= 256 x) (= (to_uint8 x) (to_uint8 (- x 256)))))))

;; "to_uint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 256 x)) (= (to_uint8 x) x)))))

;; "to_sint8"
(declare-fun to_sint8 (Int) Int)

;; "to_sint8'def"
(assert
  (forall ((x Int)) (=> (< x (- 128)) (= (to_sint8 x) (to_sint8 (+ x 256))))))

;; "to_sint8'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 128)))
      (=> (<= 128 x) (= (to_sint8 x) (to_sint8 (- x 256)))))))

;; "to_sint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x (- 128))) (=> (not (<= 128 x)) (= (to_sint8 x) x)))))

;; "to_uint16"
(declare-fun to_uint16 (Int) Int)

;; "to_uint16'def"
(assert
  (forall ((x Int)) (=> (< x 0) (= (to_uint16 x) (to_uint16 (+ x 65536))))))

;; "to_uint16'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (<= 65536 x) (= (to_uint16 x) (to_uint16 (- x 65536)))))))

;; "to_uint16'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 65536 x)) (= (to_uint16 x) x)))))

;; "to_sint16"
(declare-fun to_sint16 (Int) Int)

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=> (< x (- 32768)) (= (to_sint16 x) (to_sint16 (+ x 65536))))))

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 32768)))
      (=> (<= 32768 x) (= (to_sint16 x) (to_sint16 (- x 65536)))))))

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=> (not (< x (- 32768))) (=> (not (<= 32768 x)) (= (to_sint16 x) x)))))

;; "to_uint32"
(declare-fun to_uint32 (Int) Int)

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=> (< x 0) (= (to_uint32 x) (to_uint32 (+ x 4294967296))))))

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (<= 4294967296 x) (= (to_uint32 x) (to_uint32 (- x 4294967296)))))))

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 4294967296 x)) (= (to_uint32 x) x)))))

;; "to_sint32"
(declare-fun to_sint32 (Int) Int)

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=> (< x (- 2147483648)) (= (to_sint32 x) (to_sint32 (+ x 4294967296))))))

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 2147483648)))
      (=> (<= 2147483648 x) (= (to_sint32 x) (to_sint32 (- x 4294967296)))))))

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 2147483648)))
      (=> (not (<= 2147483648 x)) (= (to_sint32 x) x)))))

;; "to_uint64"
(declare-fun to_uint64 (Int) Int)

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=> (< x 0) (= (to_uint64 x) (to_uint64 (+ x 18446744073709551616))))))

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=>
        (<= 18446744073709551616 x)
        (= (to_uint64 x) (to_uint64 (- x 18446744073709551616)))))))

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (not (<= 18446744073709551616 x)) (= (to_uint64 x) x)))))

;; "to_sint64"
(declare-fun to_sint64 (Int) Int)

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (< x (- 9223372036854775808))
      (= (to_sint64 x) (to_sint64 (+ x 18446744073709551616))))))

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 9223372036854775808)))
      (=>
        (<= 9223372036854775808 x)
        (= (to_sint64 x) (to_sint64 (- x 18446744073709551616)))))))

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 9223372036854775808)))
      (=> (not (<= 9223372036854775808 x)) (= (to_sint64 x) x)))))

;; "two_power_abs"
(declare-fun two_power_abs (Int) Int)

;; "is_uint"
(define-fun is_uint ((n Int) (x Int)) Bool
  (and (<= 0 x) (< x (two_power_abs n))))

;; "to_uint"
(declare-fun to_uint (Int
  Int) Int)

;; "is_to_uint8"
(assert (forall ((x Int)) (is_uint8 (to_uint8 x))))

;; "is_to_sint8"
(assert (forall ((x Int)) (is_sint8 (to_sint8 x))))

;; "is_to_uint16"
(assert (forall ((x Int)) (is_uint16 (to_uint16 x))))

;; "is_to_sint16"
(assert (forall ((x Int)) (is_sint16 (to_sint16 x))))

;; "is_to_uint32"
(assert (forall ((x Int)) (is_uint32 (to_uint32 x))))

;; "is_to_sint32"
(assert (forall ((x Int)) (is_sint32 (to_sint32 x))))

;; "is_to_uint64"
(assert (forall ((x Int)) (is_uint64 (to_uint64 x))))

;; "is_to_sint64"
(assert (forall ((x Int)) (is_sint64 (to_sint64 x))))

;; "id_uint8"
(assert
  (forall ((x Int))
    (! (=> (is_uint8 x) (= (to_uint8 x) x)) :pattern ((to_uint8 x)) )))

;; "id_sint8"
(assert
  (forall ((x Int))
    (! (=> (is_sint8 x) (= (to_sint8 x) x)) :pattern ((to_sint8 x)) )))

;; "id_uint16"
(assert
  (forall ((x Int))
    (! (=> (is_uint16 x) (= (to_uint16 x) x)) :pattern ((to_uint16 x)) )))

;; "id_sint16"
(assert
  (forall ((x Int))
    (! (=> (is_sint16 x) (= (to_sint16 x) x)) :pattern ((to_sint16 x)) )))

;; "id_uint32"
(assert
  (forall ((x Int))
    (! (=> (is_uint32 x) (= (to_uint32 x) x)) :pattern ((to_uint32 x)) )))

;; "id_sint32"
(assert
  (forall ((x Int))
    (! (=> (is_sint32 x) (= (to_sint32 x) x)) :pattern ((to_sint32 x)) )))

;; "id_uint64"
(assert
  (forall ((x Int))
    (! (=> (is_uint64 x) (= (to_uint64 x) x)) :pattern ((to_uint64 x)) )))

;; "id_sint64"
(assert
  (forall ((x Int))
    (! (=> (is_sint64 x) (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "id_uint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 256)) (= (to_uint8 x) x)) :pattern ((to_uint8
                                                                    x)) )))

;; "id_sint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 128) x) (< x 128)) (= (to_sint8 x) x)) :pattern (
    (to_sint8
      x)) )))

;; "id_uint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 65536)) (= (to_uint16 x) x)) :pattern (
    (to_uint16
      x)) )))

;; "id_sint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 32768) x) (< x 32768)) (= (to_sint16 x) x)) :pattern (
    (to_sint16
      x)) )))

;; "id_uint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 4294967296)) (= (to_uint32 x) x)) :pattern (
    (to_uint32
      x)) )))

;; "id_sint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 2147483648) x) (< x 2147483648)) (= (to_sint32 x) x)) :pattern (
    (to_sint32
      x)) )))

;; "id_uint64_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 18446744073709551616)) (= (to_uint64 x) x)) :pattern (
    (to_uint64
      x)) )))

;; "id_sint64_inl"
(assert
  (forall ((x Int))
    (! (=>
         (and (<= (- 9223372036854775808) x) (< x 9223372036854775808))
         (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "proj_int8"
(assert (forall ((x Int)) (= (to_sint8 (to_uint8 x)) (to_sint8 x))))

;; "proj_int16"
(assert (forall ((x Int)) (= (to_sint16 (to_uint16 x)) (to_sint16 x))))

;; "proj_int32"
(assert (forall ((x Int)) (= (to_sint32 (to_uint32 x)) (to_sint32 x))))

;; "proj_int64"
(assert (forall ((x Int)) (= (to_sint64 (to_uint64 x)) (to_sint64 x))))

;; "is_sint64_chunk"
(define-fun is_sint64_chunk ((m (Array addr Int))) Bool
  (forall ((a addr)) (is_sint64 (select m a))))

;; "is_uint32_chunk"
(define-fun is_uint32_chunk ((m (Array addr Int))) Bool
  (forall ((a addr)) (is_uint32 (select m a))))

;; "framed"
(define-fun framed ((m (Array addr addr))) Bool
  (forall ((p addr))
    (! (=> (<= (region (base p)) 0) (<= (region (base (select m p))) 0)) :pattern ((select m p)) )))

;; "eqmem"
(define-fun eqmem (par (a)
  ((m1 (Array addr a)) (m2 (Array addr a)) (p addr) (n Int)) Bool
  (forall ((q addr))
    (! (=> (included q 1 p n) (= (select m1 q) (select m2 q))) :pattern ((select m1 q)) :pattern ((select m2 q)) ))))

;; "memcpy"
(declare-fun memcpy (par (a)
  ((Array addr a)
  addr
  (Array addr a)
  addr
  Int) (Array addr a)))

;; "memcpy'def"
(assert (par (a)
  (forall ((m0 (Array addr a)) (a0 addr) (m1 (Array addr a)) (a1 addr) (s Int) (p addr))
    (= (select (memcpy m0 a0 m1 a1 s) p) (ite (separated p 1 a0 s)
                                           (select m0 p)
                                           (let ((offset1 (+ (- (offset a1) 
                                             (offset
                                               a0)) (offset p))))
                                             (select m1 (addrqtmk
                                                          (base a1)
                                                          offset1))))))))

;; "eqmem_single"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (=> (eqmem m1 m2 p 1) (= (select m1 p) (select m2 p)))))))

;; "eqmem_single"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (=> (= (select m1 p) (select m2 p)) (eqmem m1 m2 p 1))))))

;; "eqmem_included"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr) (q addr))
      (forall ((a1 Int) (b Int))
        (! (=> (included p a1 q b) (=> (eqmem m1 m2 q b) (eqmem m1 m2 p a1))) :pattern (
        (eqmem
          m1
          m2
          p
          a1)
        (eqmem m1 m2 q b)) ))))))

;; "eqmem_sym"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (forall ((a1 Int)) (=> (eqmem m1 m2 p a1) (eqmem m2 m1 p a1)))))))

;; "eqmem_update"
(assert (par (a)
  (forall ((m0 (Array addr a)))
    (forall ((v a))
      (forall ((p addr) (q addr))
        (forall ((nqt Int))
          (=> (separated p 1 q nqt) (eqmem m0 (store m0 p v) q nqt))))))))

;; "eqmem_memcpy"
(assert (par (a)
  (forall ((m0 (Array addr a)) (m1 (Array addr a)))
    (forall ((p addr) (pqt addr) (q addr))
      (forall ((n Int) (nqt Int))
        (=> (separated p n pqt nqt) (eqmem m0 (memcpy m0 p m1 q n) pqt nqt)))))))

;; "bit_testb"
(declare-fun bit_testb (Int
  Int) Bool)

;; "bit_test"
(declare-fun bit_test (Int
  Int) Bool)

;; "lnot"
(define-fun lnot ((x Int)) Int
  (- (- x) 1))

;; "land"
(declare-fun land (Int
  Int) Int)

;; "Assoc"
(assert
  (forall ((x Int) (y Int) (z Int))
    (= (land (land x y) z) (land x (land y z)))))

;; "Comm"
(assert (forall ((x Int) (y Int)) (= (land x y) (land y x))))

;; "lxor"
(declare-fun lxor (Int
  Int) Int)

;; "Assoc"
(assert
  (forall ((x Int) (y Int) (z Int))
    (= (lxor (lxor x y) z) (lxor x (lxor y z)))))

;; "Comm"
(assert (forall ((x Int) (y Int)) (= (lxor x y) (lxor y x))))

;; "lor"
(declare-fun lor (Int
  Int) Int)

;; "Assoc"
(assert
  (forall ((x Int) (y Int) (z Int)) (= (lor (lor x y) z) (lor x (lor y z)))))

;; "Comm"
(assert (forall ((x Int) (y Int)) (= (lor x y) (lor y x))))

;; "lsl"
(declare-fun lsl (Int
  Int) Int)

;; "lsr"
(declare-fun lsr (Int
  Int) Int)

;; "land_idemp"
(assert (forall ((x Int)) (! (= (land x x) x) :pattern ((land x x)) )))

;; "land_idemp_bis"
(assert
  (forall ((x Int) (y Int))
    (! (= (land x (land x y)) (land x y)) :pattern ((land x (land x y))) )))

;; "land_0"
(assert (forall ((x Int)) (! (= (land 0 x) 0) :pattern ((land 0 x)) )))

;; "land_0bis"
(assert (forall ((x Int)) (! (= (land x 0) 0) :pattern ((land x 0)) )))

;; "land_1"
(assert
  (forall ((x Int)) (! (= (land (- 1) x) x) :pattern ((land (- 1) x)) )))

;; "land_1bis"
(assert
  (forall ((x Int)) (! (= (land x (- 1)) x) :pattern ((land x (- 1))) )))

;; "lor_idemp"
(assert (forall ((x Int)) (! (= (lor x x) x) :pattern ((lor x x)) )))

;; "lor_idemp_bis"
(assert
  (forall ((x Int) (y Int))
    (! (= (lor x (lor x y)) (lor x y)) :pattern ((lor x (lor x y))) )))

;; "lor_1"
(assert
  (forall ((x Int)) (! (= (lor (- 1) x) (- 1)) :pattern ((lor (- 1) x)) )))

;; "lor_1bis"
(assert
  (forall ((x Int)) (! (= (lor x (- 1)) (- 1)) :pattern ((lor x (- 1))) )))

;; "lor_0"
(assert (forall ((x Int)) (! (= (lor 0 x) x) :pattern ((lor 0 x)) )))

;; "lor_0bis"
(assert (forall ((x Int)) (! (= (lor x 0) x) :pattern ((lor x 0)) )))

;; "lxor_nilpotent"
(assert (forall ((x Int)) (! (= (lxor x x) 0) :pattern ((lxor x x)) )))

;; "lxor_nilpotent_bis"
(assert
  (forall ((x Int) (y Int))
    (! (= (lxor x (lxor x y)) y) :pattern ((lxor x (lxor x y))) )))

;; "lxor_1"
(assert
  (forall ((x Int))
    (! (= (lxor (- 1) x) (lnot x)) :pattern ((lxor (- 1) x)) )))

;; "lxor_1bis"
(assert
  (forall ((x Int))
    (! (= (lxor x (- 1)) (lnot x)) :pattern ((lxor x (- 1))) )))

;; "lxor_0"
(assert (forall ((x Int)) (! (= (lxor 0 x) x) :pattern ((lxor 0 x)) )))

;; "lxor_0bis"
(assert (forall ((x Int)) (! (= (lxor x 0) x) :pattern ((lxor x 0)) )))

;; "lsl_0"
(assert (forall ((x Int)) (= (lsl x 0) x)))

;; "lsl_1"
(assert (forall ((x Int)) (= (lsl x 1) (* 2 x))))

;; "lsl_add"
(assert
  (forall ((x Int) (p Int) (q Int))
    (=> (<= 0 p) (=> (<= 0 q) (= (lsl (lsl x p) q) (lsl x (+ p q)))))))

;; "lsr_0"
(assert (forall ((x Int)) (= (lsr x 0) x)))

;; "lsr_1"
(assert (forall ((x Int)) (=> (<= 0 x) (= (lsr x 1) (div1 x 2)))))

;; "lsr_add"
(assert
  (forall ((x Int) (p Int) (q Int))
    (=> (<= 0 p) (=> (<= 0 q) (= (lsr (lsr x p) q) (lsr x (+ p q)))))))

;; "lsl_lsr_add"
(assert
  (forall ((x Int) (p Int) (q Int))
    (=> (and (<= 0 q) (<= q p)) (= (lsr (lsl x p) q) (lsl x (- p q))))))

;; "bit_test_def"
(assert
  (forall ((x Int) (k Int))
    (! (=> (= (bit_testb x k) true) (bit_test x k)) :pattern ((bit_testb x k)) )))

;; "bit_test_def"
(assert
  (forall ((x Int) (k Int))
    (! (=> (bit_test x k) (= (bit_testb x k) true)) :pattern ((bit_testb x k)) )))

;; "bit_test_extraction"
(assert
  (forall ((x Int) (k Int))
    (! (=> (<= 0 k) (=> (not (= (land x (lsl 1 k)) 0)) (bit_test x k))) :pattern (
    (land
      x
      (lsl 1 k))) :pattern ((land (lsl 1 k) x)) )))

;; "bit_test_extraction"
(assert
  (forall ((x Int) (k Int))
    (! (=> (<= 0 k) (=> (bit_test x k) (not (= (land x (lsl 1 k)) 0)))) :pattern (
    (land
      x
      (lsl 1 k))) :pattern ((land (lsl 1 k) x)) )))

;; "lsl_1_0"
(assert (= (lsl 1 0) 1))

;; "bit_test_extraction_bis"
(assert
  (forall ((x Int))
    (! (=> (not (= (land 1 x) 0)) (bit_test x 0)) :pattern ((land x 1)) :pattern (
    (land
      1
      x)) )))

;; "bit_test_extraction_bis_eq"
(assert
  (forall ((x Int))
    (! (=> (bit_test x 0) (= (land 1 x) 1)) :pattern ((land x 1)) :pattern (
    (land
      1
      x)) )))

;; "lnot_extraction"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 0 i) (=> (bit_test (lnot x) i) (not (bit_test x i)))) :pattern (
    (bit_test
      (lnot x)
      i)) )))

;; "lnot_extraction"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 0 i) (=> (not (bit_test x i)) (bit_test (lnot x) i))) :pattern (
    (bit_test
      (lnot x)
      i)) )))

;; "land_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=> (<= 0 i) (=> (bit_test (land x y) i) (bit_test x i))) :pattern (
    (bit_test
      (land x y)
      i)) )))

;; "land_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=> (<= 0 i) (=> (bit_test (land x y) i) (bit_test y i))) :pattern (
    (bit_test
      (land x y)
      i)) )))

;; "land_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=>
         (<= 0 i)
         (=> (and (bit_test x i) (bit_test y i)) (bit_test (land x y) i))) :pattern (
    (bit_test
      (land x y)
      i)) )))

;; "lor_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=>
         (<= 0 i)
         (=> (bit_test (lor x y) i) (or (bit_test x i) (bit_test y i)))) :pattern (
    (bit_test
      (lor x y)
      i)) )))

;; "lor_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=>
         (<= 0 i)
         (=> (or (bit_test x i) (bit_test y i)) (bit_test (lor x y) i))) :pattern (
    (bit_test
      (lor x y)
      i)) )))

;; "lxor_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=>
         (<= 0 i)
         (=>
           (bit_test (lxor x y) i)
           (=> (bit_test x i) (not (bit_test y i))))) :pattern ((bit_test
                                                                  (lxor x y)
                                                                  i)) )))

;; "lxor_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=>
         (<= 0 i)
         (=>
           (bit_test (lxor x y) i)
           (=> (not (bit_test y i)) (bit_test x i)))) :pattern ((bit_test
                                                                  (lxor x y)
                                                                  i)) )))

;; "lxor_extraction"
(assert
  (forall ((x Int) (y Int) (i Int))
    (! (=>
         (<= 0 i)
         (=> (= (bit_test x i) (not (bit_test y i))) (bit_test (lxor x y) i))) :pattern (
    (bit_test
      (lxor x y)
      i)) )))

;; "land_1_lsl_1"
(assert
  (forall ((a1 Int) (x Int) (n Int))
    (! (=>
         (<= 0 n)
         (=> (< a1 (lsl 1 n)) (< (+ (* 2 a1) (land 1 x)) (lsl 1 (+ 1 n))))) :pattern (
    (lsl
      1
      (+ 1 n))
    (lsl 1 n)
    (+ (* 2 a1) (land 1 x))) )))

;; "lsl_extraction_sup"
(assert
  (forall ((x Int) (n Int) (m Int))
    (! (=>
         (<= 0 n)
         (=>
           (<= 0 m)
           (=> (<= n m) (=> (bit_test (lsl x n) m) (bit_test x (- m n)))))) :pattern (
    (bit_test
      (lsl x n)
      m)) )))

;; "lsl_extraction_sup"
(assert
  (forall ((x Int) (n Int) (m Int))
    (! (=>
         (<= 0 n)
         (=>
           (<= 0 m)
           (=> (<= n m) (=> (bit_test x (- m n)) (bit_test (lsl x n) m))))) :pattern (
    (bit_test
      (lsl x n)
      m)) )))

;; "lsl_extraction_inf"
(assert
  (forall ((x Int) (n Int) (m Int))
    (! (=> (<= 0 n) (=> (<= 0 m) (=> (< m n) (not (bit_test (lsl x n) m))))) :pattern (
    (bit_test
      (lsl x n)
      m)) )))

;; "lsr_extractionl"
(assert
  (forall ((x Int) (n Int) (m Int))
    (! (=>
         (<= 0 n)
         (=> (<= 0 m) (=> (bit_test (lsr x n) m) (bit_test x (+ m n))))) :pattern (
    (bit_test
      (lsr x n)
      m)) )))

;; "lsr_extractionl"
(assert
  (forall ((x Int) (n Int) (m Int))
    (! (=>
         (<= 0 n)
         (=> (<= 0 m) (=> (bit_test x (+ m n)) (bit_test (lsr x n) m)))) :pattern (
    (bit_test
      (lsr x n)
      m)) )))

;; "lsl1_extraction"
(assert
  (forall ((i Int) (j Int))
    (! (=> (<= 0 i) (=> (<= 0 j) (=> (bit_test (lsl 1 i) j) (= i j)))) :pattern (
    (bit_test
      (lsl 1 i)
      j)) )))

;; "lsl1_extraction"
(assert
  (forall ((i Int) (j Int))
    (! (=> (<= 0 i) (=> (<= 0 j) (=> (= i j) (bit_test (lsl 1 i) j)))) :pattern (
    (bit_test
      (lsl 1 i)
      j)) )))

;; "to_uint8_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 8 i) (=> (is_uint8 x) (not (bit_test x i)))) :pattern (
    (is_uint8
      x)
    (bit_test x i)) )))

;; "to_uint8_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 8))
         (=> (bit_test (to_uint8 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_uint8
                                                                    x)
                                                                    i)) )))

;; "to_uint8_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 8))
         (=> (bit_test x i) (bit_test (to_uint8 x) i))) :pattern ((bit_test
                                                                    (to_uint8
                                                                    x)
                                                                    i)) )))

;; "to_uint16_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 16 i) (=> (is_uint16 x) (not (bit_test x i)))) :pattern (
    (is_uint16
      x)
    (bit_test x i)) )))

;; "to_uint16_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 16))
         (=> (bit_test (to_uint16 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_uint16
                                                                    x)
                                                                    i)) )))

;; "to_uint16_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 16))
         (=> (bit_test x i) (bit_test (to_uint16 x) i))) :pattern ((bit_test
                                                                    (to_uint16
                                                                    x)
                                                                    i)) )))

;; "to_uint32_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 32 i) (=> (is_uint32 x) (not (bit_test x i)))) :pattern (
    (is_uint32
      x)
    (bit_test x i)) )))

;; "to_uint32_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 32))
         (=> (bit_test (to_uint32 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_uint32
                                                                    x)
                                                                    i)) )))

;; "to_uint32_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 32))
         (=> (bit_test x i) (bit_test (to_uint32 x) i))) :pattern ((bit_test
                                                                    (to_uint32
                                                                    x)
                                                                    i)) )))

;; "to_uint64_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 64 i) (=> (is_uint64 x) (not (bit_test x i)))) :pattern (
    (is_uint64
      x)
    (bit_test x i)) )))

;; "to_uint64_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 64))
         (=> (bit_test (to_uint64 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_uint64
                                                                    x)
                                                                    i)) )))

;; "to_uint64_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 64))
         (=> (bit_test x i) (bit_test (to_uint64 x) i))) :pattern ((bit_test
                                                                    (to_uint64
                                                                    x)
                                                                    i)) )))

;; "to_sint8_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 7 i) (=> (is_sint8 x) (=> (bit_test x i) (< x 0)))) :pattern (
    (is_sint8
      x)
    (bit_test x i)) )))

;; "to_sint8_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 7 i) (=> (is_sint8 x) (=> (< x 0) (bit_test x i)))) :pattern (
    (is_sint8
      x)
    (bit_test x i)) )))

;; "to_sint8_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 7))
         (=> (bit_test (to_sint8 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_sint8
                                                                    x)
                                                                    i)) )))

;; "to_sint8_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 7))
         (=> (bit_test x i) (bit_test (to_sint8 x) i))) :pattern ((bit_test
                                                                    (to_sint8
                                                                    x)
                                                                    i)) )))

;; "to_sint16_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 15 i) (=> (is_sint16 x) (=> (bit_test x i) (< x 0)))) :pattern (
    (is_sint16
      x)
    (bit_test x i)) )))

;; "to_sint16_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 15 i) (=> (is_sint16 x) (=> (< x 0) (bit_test x i)))) :pattern (
    (is_sint16
      x)
    (bit_test x i)) )))

;; "to_sint16_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 15))
         (=> (bit_test (to_sint16 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_sint16
                                                                    x)
                                                                    i)) )))

;; "to_sint16_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 15))
         (=> (bit_test x i) (bit_test (to_sint16 x) i))) :pattern ((bit_test
                                                                    (to_sint16
                                                                    x)
                                                                    i)) )))

;; "to_sint32_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 31 i) (=> (is_sint32 x) (=> (bit_test x i) (< x 0)))) :pattern (
    (is_sint32
      x)
    (bit_test x i)) )))

;; "to_sint32_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 31 i) (=> (is_sint32 x) (=> (< x 0) (bit_test x i)))) :pattern (
    (is_sint32
      x)
    (bit_test x i)) )))

;; "to_sint32_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 31))
         (=> (bit_test (to_sint32 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_sint32
                                                                    x)
                                                                    i)) )))

;; "to_sint32_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 31))
         (=> (bit_test x i) (bit_test (to_sint32 x) i))) :pattern ((bit_test
                                                                    (to_sint32
                                                                    x)
                                                                    i)) )))

;; "to_sint64_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 63 i) (=> (is_sint64 x) (=> (bit_test x i) (< x 0)))) :pattern (
    (is_sint64
      x)
    (bit_test x i)) )))

;; "to_sint64_extraction_sup"
(assert
  (forall ((x Int) (i Int))
    (! (=> (<= 63 i) (=> (is_sint64 x) (=> (< x 0) (bit_test x i)))) :pattern (
    (is_sint64
      x)
    (bit_test x i)) )))

;; "to_sint64_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 63))
         (=> (bit_test (to_sint64 x) i) (bit_test x i))) :pattern ((bit_test
                                                                    (to_sint64
                                                                    x)
                                                                    i)) )))

;; "to_sint64_extraction_inf"
(assert
  (forall ((x Int) (i Int))
    (! (=>
         (and (<= 0 i) (< i 63))
         (=> (bit_test x i) (bit_test (to_sint64 x) i))) :pattern ((bit_test
                                                                    (to_sint64
                                                                    x)
                                                                    i)) )))

;; "is_uint_lxor"
(assert
  (forall ((n Int) (x Int) (y Int))
    (=>
      (is_uint n x)
      (=> (is_uint n y) (= (to_uint n (lxor x y)) (lxor x y))))))

;; "is_uint8_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint8 x)
         (=> (is_uint8 y) (= (to_uint8 (lxor x y)) (lxor x y)))) :pattern (
    (to_uint8
      (lxor x y))) )))

;; "is_uint8_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=> (is_uint8 x) (=> (is_uint8 y) (= (to_uint8 (lor x y)) (lor x y)))) :pattern (
    (to_uint8
      (lor x y))) )))

;; "is_uint8_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint8 x)
         (=> (is_uint8 y) (= (to_uint8 (land x y)) (land x y)))) :pattern (
    (to_uint8
      (land x y))) )))

;; "is_uint8_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_uint8 x) (= (to_uint8 (lsr x y)) (lsr x y)))) :pattern (
    (to_uint8
      (lsr x y))) )))

;; "is_uint8_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 8)) (= (to_uint8 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_uint8
      (lsl 1 y))) )))

;; "is_uint8_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 8 y) (= (to_uint8 (lsl 1 y)) 0)) :pattern ((to_uint8
                                                            (lsl 1 y))) )))

;; "is_uint16_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint16 x)
         (=> (is_uint16 y) (= (to_uint16 (lxor x y)) (lxor x y)))) :pattern (
    (to_uint16
      (lxor x y))) )))

;; "is_uint16_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint16 x)
         (=> (is_uint16 y) (= (to_uint16 (lor x y)) (lor x y)))) :pattern (
    (to_uint16
      (lor x y))) )))

;; "is_uint16_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint16 x)
         (=> (is_uint16 y) (= (to_uint16 (land x y)) (land x y)))) :pattern (
    (to_uint16
      (land x y))) )))

;; "is_uint16_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_uint16 x) (= (to_uint16 (lsr x y)) (lsr x y)))) :pattern (
    (to_uint16
      (lsr x y))) )))

;; "is_uint16_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 16)) (= (to_uint16 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_uint16
      (lsl 1 y))) )))

;; "is_uint16_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 16 y) (= (to_uint16 (lsl 1 y)) 0)) :pattern ((to_uint16
                                                              (lsl 1 y))) )))

;; "is_uint32_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint32 x)
         (=> (is_uint32 y) (= (to_uint32 (lxor x y)) (lxor x y)))) :pattern (
    (to_uint32
      (lxor x y))) )))

;; "is_uint32_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint32 x)
         (=> (is_uint32 y) (= (to_uint32 (lor x y)) (lor x y)))) :pattern (
    (to_uint32
      (lor x y))) )))

;; "is_uint32_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint32 x)
         (=> (is_uint32 y) (= (to_uint32 (land x y)) (land x y)))) :pattern (
    (to_uint32
      (land x y))) )))

;; "is_uint32_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_uint32 x) (= (to_uint32 (lsr x y)) (lsr x y)))) :pattern (
    (to_uint32
      (lsr x y))) )))

;; "is_uint32_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 32)) (= (to_uint32 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_uint32
      (lsl 1 y))) )))

;; "is_uint32_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 32 y) (= (to_uint32 (lsl 1 y)) 0)) :pattern ((to_uint32
                                                              (lsl 1 y))) )))

;; "is_uint64_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint64 x)
         (=> (is_uint64 y) (= (to_uint64 (lxor x y)) (lxor x y)))) :pattern (
    (to_uint64
      (lxor x y))) )))

;; "is_uint64_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint64 x)
         (=> (is_uint64 y) (= (to_uint64 (lor x y)) (lor x y)))) :pattern (
    (to_uint64
      (lor x y))) )))

;; "is_uint64_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_uint64 x)
         (=> (is_uint64 y) (= (to_uint64 (land x y)) (land x y)))) :pattern (
    (to_uint64
      (land x y))) )))

;; "is_uint64_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_uint64 x) (= (to_uint64 (lsr x y)) (lsr x y)))) :pattern (
    (to_uint64
      (lsr x y))) )))

;; "is_uint64_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 64)) (= (to_uint64 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_uint64
      (lsl 1 y))) )))

;; "is_uint64_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 64 y) (= (to_uint64 (lsl 1 y)) 0)) :pattern ((to_uint64
                                                              (lsl 1 y))) )))

;; "is_sint8_lnot"
(assert
  (forall ((x Int))
    (! (=> (is_sint8 x) (= (to_sint8 (lnot x)) (lnot x))) :pattern ((to_sint8
                                                                    (lnot x))) )))

;; "is_sint8_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint8 x)
         (=> (is_sint8 y) (= (to_sint8 (lxor x y)) (lxor x y)))) :pattern (
    (to_sint8
      (lxor x y))) )))

;; "is_sint8_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=> (is_sint8 x) (=> (is_sint8 y) (= (to_sint8 (lor x y)) (lor x y)))) :pattern (
    (to_sint8
      (lor x y))) )))

;; "is_sint8_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint8 x)
         (=> (is_sint8 y) (= (to_sint8 (land x y)) (land x y)))) :pattern (
    (to_sint8
      (land x y))) )))

;; "is_sint8_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_sint8 x) (= (to_sint8 (lsr x y)) (lsr x y)))) :pattern (
    (to_sint8
      (lsr x y))) )))

;; "is_sint8_lsl1"
(assert (= (lsl 1 7) 128))

;; "is_sint8_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 7)) (= (to_sint8 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_sint8
      (lsl 1 y))) )))

;; "is_sint8_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 8 y) (= (to_sint8 (lsl 1 y)) 0)) :pattern ((to_sint8
                                                            (lsl 1 y))) )))

;; "is_sint16_lnot"
(assert
  (forall ((x Int))
    (! (=> (is_sint16 x) (= (to_sint16 (lnot x)) (lnot x))) :pattern (
    (to_sint16
      (lnot x))) )))

;; "is_sint16_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint16 x)
         (=> (is_sint16 y) (= (to_sint16 (lxor x y)) (lxor x y)))) :pattern (
    (to_sint16
      (lxor x y))) )))

;; "is_sint16_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint16 x)
         (=> (is_sint16 y) (= (to_sint16 (lor x y)) (lor x y)))) :pattern (
    (to_sint16
      (lor x y))) )))

;; "is_sint16_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint16 x)
         (=> (is_sint16 y) (= (to_sint16 (land x y)) (land x y)))) :pattern (
    (to_sint16
      (land x y))) )))

;; "is_sint16_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_sint16 x) (= (to_sint16 (lsr x y)) (lsr x y)))) :pattern (
    (to_sint16
      (lsr x y))) )))

;; "is_sint16_lsl1"
(assert (= (lsl 1 15) 32768))

;; "is_sint16_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 15)) (= (to_sint16 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_sint16
      (lsl 1 y))) )))

;; "is_sint16_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 16 y) (= (to_sint16 (lsl 1 y)) 0)) :pattern ((to_sint16
                                                              (lsl 1 y))) )))

;; "is_sint32_lnot"
(assert
  (forall ((x Int))
    (! (=> (is_sint32 x) (= (to_sint32 (lnot x)) (lnot x))) :pattern (
    (to_sint32
      (lnot x))) )))

;; "is_sint32_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint32 x)
         (=> (is_sint32 y) (= (to_sint32 (lxor x y)) (lxor x y)))) :pattern (
    (to_sint32
      (lxor x y))) )))

;; "is_sint32_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint32 x)
         (=> (is_sint32 y) (= (to_sint32 (lor x y)) (lor x y)))) :pattern (
    (to_sint32
      (lor x y))) )))

;; "is_sint32_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint32 x)
         (=> (is_sint32 y) (= (to_sint32 (land x y)) (land x y)))) :pattern (
    (to_sint32
      (land x y))) )))

;; "is_sint32_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_sint32 x) (= (to_sint32 (lsr x y)) (lsr x y)))) :pattern (
    (to_sint32
      (lsr x y))) )))

;; "is_sint32_lsl1"
(assert (= (lsl 1 31) 2147483648))

;; "is_sint32_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 31)) (= (to_sint32 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_sint32
      (lsl 1 y))) )))

;; "is_sint32_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 32 y) (= (to_sint32 (lsl 1 y)) 0)) :pattern ((to_sint32
                                                              (lsl 1 y))) )))

;; "is_sint64_lnot"
(assert
  (forall ((x Int))
    (! (=> (is_sint64 x) (= (to_sint64 (lnot x)) (lnot x))) :pattern (
    (to_sint64
      (lnot x))) )))

;; "is_sint64_lxor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint64 x)
         (=> (is_sint64 y) (= (to_sint64 (lxor x y)) (lxor x y)))) :pattern (
    (to_sint64
      (lxor x y))) )))

;; "is_sint64_lor"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint64 x)
         (=> (is_sint64 y) (= (to_sint64 (lor x y)) (lor x y)))) :pattern (
    (to_sint64
      (lor x y))) )))

;; "is_sint64_land"
(assert
  (forall ((x Int) (y Int))
    (! (=>
         (is_sint64 x)
         (=> (is_sint64 y) (= (to_sint64 (land x y)) (land x y)))) :pattern (
    (to_sint64
      (land x y))) )))

;; "is_sint64_lsr"
(assert
  (forall ((x Int) (y Int))
    (! (=> (<= 0 y) (=> (is_sint64 x) (= (to_sint64 (lsr x y)) (lsr x y)))) :pattern (
    (to_sint64
      (lsr x y))) )))

;; "is_sint64_lsl1"
(assert (= (lsl 1 63) 9223372036854775808))

;; "is_sint64_lsl1_inf"
(assert
  (forall ((y Int))
    (! (=> (and (<= 0 y) (< y 63)) (= (to_sint64 (lsl 1 y)) (lsl 1 y))) :pattern (
    (to_sint64
      (lsl 1 y))) )))

;; "is_sint64_lsl1_sup"
(assert
  (forall ((y Int))
    (! (=> (<= 64 y) (= (to_sint64 (lsl 1 y)) 0)) :pattern ((to_sint64
                                                              (lsl 1 y))) )))

;; "lor_addition"
(assert
  (forall ((x Int) (y Int))
    (! (=> (= (land x y) 0) (= (+ x y) (lor x y))) :pattern ((land x y)
    (lor x y)) )))

;; "lxor_addition"
(assert
  (forall ((x Int) (y Int))
    (! (=> (= (land x y) 0) (= (+ x y) (lxor x y))) :pattern ((land x y)
    (lxor x y)) )))

;; Goal "wp_goal"
(assert
  (not
  (forall ((t (Array Int Int)) (t1 (Array Int Int)) (t2 (Array Int Int)) (t3 (Array addr Int)) (t4 (Array addr Int)) (t5 (Array addr addr)) (t6 (Array addr addr)) (i Int) (i1 Int) (a1 addr) (a2 addr) (i2 Int) (a3 addr) (a4 addr) (a5 addr) (a6 addr))
    (let ((a7 (shift a2 0)))
      (let ((a8 (select t6 a7)))
        (let ((a9 (shift_S3___base_class_type_info (shift a5 4) i1)))
          (let ((a10 (shift a9 0)))
            (let ((a11 (shift a5 3)))
              (let ((x (select t4 a11)))
                (let ((a12 (shift a9 1)))
                  (let ((x1 (select t3 a12)))
                    (let ((x2 (lsr x1 8)))
                      (=>
                        (not (= a4 a2))
                        (=>
                          (not (= i 0))
                          (=>
                            (not (= null a4))
                            (=>
                              (not (= null a2))
                              (=>
                                (not (= a8 a6))
                                (=>
                                  (not (= (select t5 a10) a3))
                                  (=>
                                    (< i1 x)
                                    (=>
                                      (<= (region (base a6)) 0)
                                      (=>
                                        (<= (region (base a4)) 0)
                                        (=>
                                          (<= (region (base a2)) 0)
                                          (=>
                                            (<= (region (base a8)) 0)
                                            (=>
                                              (is_sint64_chunk t3)
                                              (=>
                                                (is_uint32_chunk t4)
                                                (=>
                                                  (linked t2)
                                                  (=>
                                                    (framed t6)
                                                    (=>
                                                      (is_uint32 i1)
                                                      (=>
                                                        (is_sint32 i)
                                                        (=>
                                                          (is_sint64 i2)
                                                          (=>
                                                            (valid_rw t a1 1)
                                                            (=>
                                                              (is_uint32 x)
                                                              (=>
                                                                (valid_rd
                                                                  t2
                                                                  a7
                                                                  1)
                                                                (=>
                                                                  (valid_rd
                                                                    t1
                                                                    a11
                                                                    1)
                                                                  (=>
                                                                    (is_sint64
                                                                    x1)
                                                                    (=>
                                                                    (valid_rd
                                                                    t1
                                                                    a10
                                                                    1)
                                                                    (=>
                                                                    (valid_rd
                                                                    t1
                                                                    a12
                                                                    1)
                                                                    (=>
                                                                    (is_sint64
                                                                    x2)
                                                                    (<= (- 9223372036854775808) (+ i2 x2))))))))))))))))))))))))))))))))))))))))

(check-sat)
