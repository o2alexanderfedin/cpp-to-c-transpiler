(* WP Task for Prover Alt-Ergo,2.6.2 *)
;;; this is a prelude for Alt-Ergo, Dolmen frontend
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
;; "CompatOrderMult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; "abs"
(define-fun abs1 ((x Int)) Int
  (ite (<= 0 x) x (- x)))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= (- y) x))))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= x y))))

;; "Abs_le"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= (- y) x) (<= x y)) (<= (abs1 x) y))))

;; "Abs_pos"
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; "div"
(declare-fun div1 (Int
  Int) Int)

;; "mod"
(declare-fun mod1 (Int
  Int) Int)

;; "Div_mod"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= (div1 x y) x))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (- (abs1 y)) (mod1 x y)))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (mod1 x y) (abs1 y)))))

;; "Div_sign_pos"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_sign_neg"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; "Mod_sign_pos"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; "Mod_sign_neg"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; "Rounds_toward_zero"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; "Div_1"
(assert (forall ((x Int)) (= (div1 x 1) x)))

;; "Mod_1"
(assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; "Div_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; "Mod_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; "Div_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                                  (+ (* x y) z)
                                                                  x)) )))

;; "Mod_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1
                                                            (+ (* x y) z)
                                                            x)) )))

;; "CompatOrderMult"
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (<= x y) (=> (<= 0.0 z) (<= (* x z) (* y z))))))

;; "c_euclidian"
(assert
  (forall ((n Int) (d Int))
    (! (=> (not (= d 0)) (= n (+ (* (div1 n d) d) (mod1 n d)))) :pattern (
    (div1
      n
      d)
    (mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (< (mod1 n d) d))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (< (- d) (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (< (mod1 n d) (- d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (< d (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cdiv_neutral"
(assert (forall ((a Int)) (! (= (div1 a 1) a) :pattern ((div1 a 1)) )))

;; "cdiv_inv"
(assert
  (forall ((a Int))
    (! (=> (not (= a 0)) (= (div1 a a) 1)) :pattern ((div1 a a)) )))

;; "cdiv_closed_remainder"
(assert
  (forall ((a Int) (b Int) (n Int))
    (=>
      (<= 0 a)
      (=>
        (<= 0 b)
        (=>
          (and (<= 0 (- b a)) (< (- b a) n))
          (=> (= (mod1 a n) (mod1 b n)) (= a b)))))))

(declare-datatypes ((addr 0))
  (((addrqtmk (base Int)(offset Int)))))

;; "null"
(define-fun null () addr
  (addrqtmk 0 0))

;; "addr_le"
(declare-fun addr_le (addr
  addr) Bool)

;; "addr_lt"
(declare-fun addr_lt (addr
  addr) Bool)

;; "addr_le_bool"
(declare-fun addr_le_bool (addr
  addr) Bool)

;; "addr_lt_bool"
(declare-fun addr_lt_bool (addr
  addr) Bool)

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_le p q) (<= (offset p) (offset q)))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (<= (offset p) (offset q)) (addr_le p q))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_lt p q) (< (offset p) (offset q)))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (< (offset p) (offset q)) (addr_lt p q))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_le p q) (= (addr_le_bool p q) true)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_le_bool p q) true) (addr_le p q)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_lt p q) (= (addr_lt_bool p q) true)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_lt_bool p q) true) (addr_lt p q)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "shift"
(define-fun shift ((p addr) (k Int)) addr
  (addrqtmk (base p) (+ (offset p) k)))

;; "valid_rw"
(define-fun valid_rw ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (< 0 (base p))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rd"
(define-fun valid_rd ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (not (= 0 (base p)))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rw_rd"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (forall ((n Int)) (=> (valid_rw m p n) (valid_rd m p n))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (valid_rd m p 1))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (not (valid_rw m p 1)))))))

;; "included"
(define-fun included ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (=>
    (< 0 lp)
    (and
      (<= 0 lq)
      (and
        (= (base p) (base q))
        (and
          (<= (offset q) (offset p))
          (<= (+ (offset p) lp) (+ (offset q) lq)))))))

;; "separated"
(define-fun separated ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (or
    (<= lp 0)
    (or
      (<= lq 0)
      (or
        (not (= (base p) (base q)))
        (or
          (<= (+ (offset q) lq) (offset p))
          (<= (+ (offset p) lp) (offset q)))))))

;; "separated_1"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int) (i Int) (j Int))
      (! (=>
           (separated p lp q lq)
           (=>
             (and (<= (offset p) i) (< i (+ (offset p) lp)))
             (=>
               (and (<= (offset q) j) (< j (+ (offset q) lq)))
               (not (= (addrqtmk (base p) i) (addrqtmk (base q) j)))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (addrqtmk (base p) i)
      (addrqtmk (base q) j)) ))))

;; "separated_included"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=>
           (< 0 lp)
           (=>
             (< 0 lq)
             (=> (separated p lp q lq) (not (included p lp q lq))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (included p lp q lq)) ))))

;; "included_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (included q lq r lr) (included p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (included q lq r lr)) ))))

;; "separated_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (separated q lq r lr) (separated p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (separated q lq r lr)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated p lp q lq) (separated q lq p lp)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated q lq p lp) (separated p lp q lq)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "region"
(declare-fun region (Int) Int)

;; "linked"
(declare-fun linked ((Array Int Int)) Bool)

;; "static_malloc"
(declare-fun static_malloc (Int) Int)

;; "statically_allocated"
(define-fun statically_allocated ((base1 Int)) Bool
  (or (= base1 0) (< 0 (static_malloc base1))))

;; "valid_pointers_are_statically_allocated"
(assert
  (forall ((a addr) (m (Array Int Int)) (n Int))
    (=> (< 0 n) (=> (valid_rd m a n) (statically_allocated (base a))))))

;; "int_of_addr"
(declare-fun int_of_addr (addr) Int)

;; "addr_of_int"
(declare-fun addr_of_int (Int) addr)

;; "addr_of_null"
(assert (= (int_of_addr null) 0))

;; "addr_of_int_bijection"
(assert
  (forall ((p addr))
    (=> (statically_allocated (base p)) (= (addr_of_int (int_of_addr p)) p))))

(declare-sort table 0)

;; "table_to_offset"
(declare-fun table_to_offset (table
  Int) Int)

;; "table_to_offset_zero"
(assert (forall ((t table)) (= (table_to_offset t 0) 0)))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= o1 o2) (<= (table_to_offset t o1) (table_to_offset t o2))))))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= (table_to_offset t o1) (table_to_offset t o2)) (<= o1 o2)))))

;; "shift_S3___base_class_type_info"
(define-fun shift_S3___base_class_type_info ((p addr) (k Int)) addr
  (shift p (* 2 k)))

;; "is_bool"
(define-fun is_bool ((x Int)) Bool
  (or (= x 0) (= x 1)))

;; "is_uint8"
(define-fun is_uint8 ((x Int)) Bool
  (and (<= 0 x) (< x 256)))

;; "is_sint8"
(define-fun is_sint8 ((x Int)) Bool
  (and (<= (- 128) x) (< x 128)))

;; "is_uint16"
(define-fun is_uint16 ((x Int)) Bool
  (and (<= 0 x) (< x 65536)))

;; "is_sint16"
(define-fun is_sint16 ((x Int)) Bool
  (and (<= (- 32768) x) (< x 32768)))

;; "is_uint32"
(define-fun is_uint32 ((x Int)) Bool
  (and (<= 0 x) (< x 4294967296)))

;; "is_sint32"
(define-fun is_sint32 ((x Int)) Bool
  (and (<= (- 2147483648) x) (< x 2147483648)))

;; "is_uint64"
(define-fun is_uint64 ((x Int)) Bool
  (and (<= 0 x) (< x 18446744073709551616)))

;; "is_sint64"
(define-fun is_sint64 ((x Int)) Bool
  (and (<= (- 9223372036854775808) x) (< x 9223372036854775808)))

;; "is_bool0"
(assert (is_bool 0))

;; "is_bool1"
(assert (is_bool 1))

;; "to_uint8"
(declare-fun to_uint8 (Int) Int)

;; "to_uint8'def"
(assert
  (forall ((x Int)) (=> (< x 0) (= (to_uint8 x) (to_uint8 (+ x 256))))))

;; "to_uint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (<= 256 x) (= (to_uint8 x) (to_uint8 (- x 256)))))))

;; "to_uint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 256 x)) (= (to_uint8 x) x)))))

;; "to_sint8"
(declare-fun to_sint8 (Int) Int)

;; "to_sint8'def"
(assert
  (forall ((x Int)) (=> (< x (- 128)) (= (to_sint8 x) (to_sint8 (+ x 256))))))

;; "to_sint8'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 128)))
      (=> (<= 128 x) (= (to_sint8 x) (to_sint8 (- x 256)))))))

;; "to_sint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x (- 128))) (=> (not (<= 128 x)) (= (to_sint8 x) x)))))

;; "to_uint16"
(declare-fun to_uint16 (Int) Int)

;; "to_uint16'def"
(assert
  (forall ((x Int)) (=> (< x 0) (= (to_uint16 x) (to_uint16 (+ x 65536))))))

;; "to_uint16'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (<= 65536 x) (= (to_uint16 x) (to_uint16 (- x 65536)))))))

;; "to_uint16'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 65536 x)) (= (to_uint16 x) x)))))

;; "to_sint16"
(declare-fun to_sint16 (Int) Int)

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=> (< x (- 32768)) (= (to_sint16 x) (to_sint16 (+ x 65536))))))

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 32768)))
      (=> (<= 32768 x) (= (to_sint16 x) (to_sint16 (- x 65536)))))))

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=> (not (< x (- 32768))) (=> (not (<= 32768 x)) (= (to_sint16 x) x)))))

;; "to_uint32"
(declare-fun to_uint32 (Int) Int)

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=> (< x 0) (= (to_uint32 x) (to_uint32 (+ x 4294967296))))))

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (<= 4294967296 x) (= (to_uint32 x) (to_uint32 (- x 4294967296)))))))

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 4294967296 x)) (= (to_uint32 x) x)))))

;; "to_sint32"
(declare-fun to_sint32 (Int) Int)

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=> (< x (- 2147483648)) (= (to_sint32 x) (to_sint32 (+ x 4294967296))))))

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 2147483648)))
      (=> (<= 2147483648 x) (= (to_sint32 x) (to_sint32 (- x 4294967296)))))))

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 2147483648)))
      (=> (not (<= 2147483648 x)) (= (to_sint32 x) x)))))

;; "to_uint64"
(declare-fun to_uint64 (Int) Int)

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=> (< x 0) (= (to_uint64 x) (to_uint64 (+ x 18446744073709551616))))))

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=>
        (<= 18446744073709551616 x)
        (= (to_uint64 x) (to_uint64 (- x 18446744073709551616)))))))

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (not (<= 18446744073709551616 x)) (= (to_uint64 x) x)))))

;; "to_sint64"
(declare-fun to_sint64 (Int) Int)

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (< x (- 9223372036854775808))
      (= (to_sint64 x) (to_sint64 (+ x 18446744073709551616))))))

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 9223372036854775808)))
      (=>
        (<= 9223372036854775808 x)
        (= (to_sint64 x) (to_sint64 (- x 18446744073709551616)))))))

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 9223372036854775808)))
      (=> (not (<= 9223372036854775808 x)) (= (to_sint64 x) x)))))

;; "is_to_uint8"
(assert (forall ((x Int)) (is_uint8 (to_uint8 x))))

;; "is_to_sint8"
(assert (forall ((x Int)) (is_sint8 (to_sint8 x))))

;; "is_to_uint16"
(assert (forall ((x Int)) (is_uint16 (to_uint16 x))))

;; "is_to_sint16"
(assert (forall ((x Int)) (is_sint16 (to_sint16 x))))

;; "is_to_uint32"
(assert (forall ((x Int)) (is_uint32 (to_uint32 x))))

;; "is_to_sint32"
(assert (forall ((x Int)) (is_sint32 (to_sint32 x))))

;; "is_to_uint64"
(assert (forall ((x Int)) (is_uint64 (to_uint64 x))))

;; "is_to_sint64"
(assert (forall ((x Int)) (is_sint64 (to_sint64 x))))

;; "id_uint8"
(assert
  (forall ((x Int))
    (! (=> (is_uint8 x) (= (to_uint8 x) x)) :pattern ((to_uint8 x)) )))

;; "id_sint8"
(assert
  (forall ((x Int))
    (! (=> (is_sint8 x) (= (to_sint8 x) x)) :pattern ((to_sint8 x)) )))

;; "id_uint16"
(assert
  (forall ((x Int))
    (! (=> (is_uint16 x) (= (to_uint16 x) x)) :pattern ((to_uint16 x)) )))

;; "id_sint16"
(assert
  (forall ((x Int))
    (! (=> (is_sint16 x) (= (to_sint16 x) x)) :pattern ((to_sint16 x)) )))

;; "id_uint32"
(assert
  (forall ((x Int))
    (! (=> (is_uint32 x) (= (to_uint32 x) x)) :pattern ((to_uint32 x)) )))

;; "id_sint32"
(assert
  (forall ((x Int))
    (! (=> (is_sint32 x) (= (to_sint32 x) x)) :pattern ((to_sint32 x)) )))

;; "id_uint64"
(assert
  (forall ((x Int))
    (! (=> (is_uint64 x) (= (to_uint64 x) x)) :pattern ((to_uint64 x)) )))

;; "id_sint64"
(assert
  (forall ((x Int))
    (! (=> (is_sint64 x) (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "id_uint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 256)) (= (to_uint8 x) x)) :pattern ((to_uint8
                                                                    x)) )))

;; "id_sint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 128) x) (< x 128)) (= (to_sint8 x) x)) :pattern (
    (to_sint8
      x)) )))

;; "id_uint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 65536)) (= (to_uint16 x) x)) :pattern (
    (to_uint16
      x)) )))

;; "id_sint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 32768) x) (< x 32768)) (= (to_sint16 x) x)) :pattern (
    (to_sint16
      x)) )))

;; "id_uint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 4294967296)) (= (to_uint32 x) x)) :pattern (
    (to_uint32
      x)) )))

;; "id_sint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 2147483648) x) (< x 2147483648)) (= (to_sint32 x) x)) :pattern (
    (to_sint32
      x)) )))

;; "id_uint64_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 18446744073709551616)) (= (to_uint64 x) x)) :pattern (
    (to_uint64
      x)) )))

;; "id_sint64_inl"
(assert
  (forall ((x Int))
    (! (=>
         (and (<= (- 9223372036854775808) x) (< x 9223372036854775808))
         (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "proj_int8"
(assert (forall ((x Int)) (= (to_sint8 (to_uint8 x)) (to_sint8 x))))

;; "proj_int16"
(assert (forall ((x Int)) (= (to_sint16 (to_uint16 x)) (to_sint16 x))))

;; "proj_int32"
(assert (forall ((x Int)) (= (to_sint32 (to_uint32 x)) (to_sint32 x))))

;; "proj_int64"
(assert (forall ((x Int)) (= (to_sint64 (to_uint64 x)) (to_sint64 x))))

;; "is_uint32_chunk"
(define-fun is_uint32_chunk ((m (Array addr Int))) Bool
  (forall ((a addr)) (is_uint32 (select m a))))

;; "framed"
(define-fun framed ((m (Array addr addr))) Bool
  (forall ((p addr))
    (! (=> (<= (region (base p)) 0) (<= (region (base (select m p))) 0)) :pattern ((select m p)) )))

;; "eqmem"
(define-fun eqmem (par (a)
  ((m1 (Array addr a)) (m2 (Array addr a)) (p addr) (n Int)) Bool
  (forall ((q addr))
    (! (=> (included q 1 p n) (= (select m1 q) (select m2 q))) :pattern ((select m1 q)) :pattern ((select m2 q)) ))))

;; "memcpy"
(declare-fun memcpy (par (a)
  ((Array addr a)
  addr
  (Array addr a)
  addr
  Int) (Array addr a)))

;; "memcpy'def"
(assert (par (a)
  (forall ((m0 (Array addr a)) (a0 addr) (m1 (Array addr a)) (a1 addr) (s Int) (p addr))
    (= (select (memcpy m0 a0 m1 a1 s) p) (ite (separated p 1 a0 s)
                                           (select m0 p)
                                           (let ((offset1 (+ (- (offset a1) 
                                             (offset
                                               a0)) (offset p))))
                                             (select m1 (addrqtmk
                                                          (base a1)
                                                          offset1))))))))

;; "eqmem_single"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (=> (eqmem m1 m2 p 1) (= (select m1 p) (select m2 p)))))))

;; "eqmem_single"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (=> (= (select m1 p) (select m2 p)) (eqmem m1 m2 p 1))))))

;; "eqmem_included"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr) (q addr))
      (forall ((a1 Int) (b Int))
        (! (=> (included p a1 q b) (=> (eqmem m1 m2 q b) (eqmem m1 m2 p a1))) :pattern (
        (eqmem
          m1
          m2
          p
          a1)
        (eqmem m1 m2 q b)) ))))))

;; "eqmem_sym"
(assert (par (a)
  (forall ((m1 (Array addr a)) (m2 (Array addr a)))
    (forall ((p addr))
      (forall ((a1 Int)) (=> (eqmem m1 m2 p a1) (eqmem m2 m1 p a1)))))))

;; "eqmem_update"
(assert (par (a)
  (forall ((m0 (Array addr a)))
    (forall ((v a))
      (forall ((p addr) (q addr))
        (forall ((nqt Int))
          (=> (separated p 1 q nqt) (eqmem m0 (store m0 p v) q nqt))))))))

;; "eqmem_memcpy"
(assert (par (a)
  (forall ((m0 (Array addr a)) (m1 (Array addr a)))
    (forall ((p addr) (pqt addr) (q addr))
      (forall ((n Int) (nqt Int))
        (=> (separated p n pqt nqt) (eqmem m0 (memcpy m0 p m1 q n) pqt nqt)))))))

;; "P_valid_type_info"
(define-fun P_valid_type_info ((Malloc (Array Int Int)) (Mptr (Array addr addr)) (t addr)) Bool
  (and (valid_rd Malloc t 2) (valid_rd Malloc (select Mptr (shift t 1)) 1)))

;; Goal "wp_goal"
(assert
  (not
  (forall ((t (Array Int Int)) (t1 (Array Int Int)) (t2 (Array addr Int)) (t3 (Array addr addr)) (a1 addr) (i Int) (a2 addr) (a3 addr) (a4 addr) (a5 addr))
    (let ((a6 (shift a3 0)))
      (let ((a7 (select t3 a6)))
        (let ((a8 (shift a4 3)))
          (let ((x (select t2 a8)))
            (let ((a9 (shift_S3___base_class_type_info (shift a4 4) i)))
              (=>
                (not (= a3 a1))
                (=>
                  (not (= null a3))
                  (=>
                    (not (= null a2))
                    (=>
                      (not (= null a1))
                      (=>
                        (not (= a7 a5))
                        (=>
                          (< i x)
                          (=>
                            (<= (region (base a5)) 0)
                            (=>
                              (<= (region (base a3)) 0)
                              (=>
                                (<= (region (base a2)) 0)
                                (=>
                                  (<= (region (base a1)) 0)
                                  (=>
                                    (<= (region (base a7)) 0)
                                    (=>
                                      (is_uint32_chunk t2)
                                      (=>
                                        (linked t1)
                                        (=>
                                          (framed t3)
                                          (=>
                                            (is_uint32 i)
                                            (=>
                                              (valid_rd t1 a2 1)
                                              (=>
                                                (P_valid_type_info t1 t3 a3)
                                                (=>
                                                  (P_valid_type_info
                                                    t1
                                                    t3
                                                    a1)
                                                  (=>
                                                    (is_uint32 x)
                                                    (=>
                                                      (valid_rd t1 a6 1)
                                                      (=>
                                                        (valid_rd t a8 1)
                                                        (=>
                                                          (valid_rd
                                                            t
                                                            (shift a9 0)
                                                            1)
                                                          (valid_rd
                                                            t
                                                            (shift a9 1)
                                                            1)))))))))))))))))))))))))))))))

(check-sat)
