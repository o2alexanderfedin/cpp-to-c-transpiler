/**
 * @file ExpressionHandlerTest.cpp
 * @brief TDD tests for ExpressionHandler
 *
 * Following strict TDD: Red → Green → Refactor
 *
 * Test Plan (35+ tests):
 *
 * LITERALS (5 tests):
 * 1. IntegerLiteral - 42
 * 2. NegativeIntegerLiteral - -10
 * 3. FloatingLiteral - 3.14
 * 4. StringLiteral - "hello"
 * 5. CharacterLiteral - 'a'
 *
 * BINARY OPERATORS (15 tests):
 * 6. BinaryAddition - a + b
 * 7. BinarySubtraction - a - b
 * 8. BinaryMultiplication - a * b
 * 9. BinaryDivision - a / b
 * 10. BinaryModulo - a % b
 * 11. NestedAddition - (a + b) + c
 * 12. MixedArithmetic - a + b * c
 * 13. ComplexNesting - (a + b) * (c - d)
 * 14. ComparisonEqual - a == b
 * 15. ComparisonNotEqual - a != b
 * 16. ComparisonLess - a < b
 * 17. ComparisonGreater - a > b
 * 18. ComparisonLessEqual - a <= b
 * 19. ComparisonGreaterEqual - a >= b
 * 20. LogicalAnd - a && b
 *
 * UNARY OPERATORS (5 tests):
 * 21. UnaryMinus - -x
 * 22. UnaryPlus - +x
 * 23. UnaryIncrement - ++x
 * 24. UnaryDecrement - --x
 * 25. UnaryNot - !x
 *
 * DECLREFEXPR (5 tests):
 * 26. SimpleVarRef - x
 * 27. VarRefInExpr - x + 1
 * 28. MultipleVarRefs - x + y
 * 29. VarRefNested - (x + y) * z
 * 30. VarRefWithLiteral - x * 2
 *
 * COMPLEX EXPRESSIONS (10+ tests):
 * 31. ArithmeticChain - a + b - c + d
 * 32. DeepNesting - ((a + b) * (c - d)) / e
 * 33. AllOperators - (a + b) * c / d - e % f
 * 34. LogicalChain - a && b || c
 * 35. MixedComparison - (a > b) && (c < d)
 * 36. ParenthesizedExpr - (a + b)
 * 37. MultiLevelNesting - (((a + b) * c) - d) / e
 * 38. ComplexLogical - (a > 0 && b < 100) || c == 42
 */

#include "handlers/ExpressionHandler.h"
#include "handlers/HandlerContext.h"
#include "CNodeBuilder.h"
#include "clang/Tooling/Tooling.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include <gtest/gtest.h>
#include <memory>

using namespace cpptoc;

/**
 * @class ExpressionHandlerTest
 * @brief Test fixture for ExpressionHandler
 *
 * Uses clang::tooling::buildASTFromCode for real AST contexts.
 */
class ExpressionHandlerTest : public ::testing::Test {
protected:
    std::unique_ptr<clang::ASTUnit> cppAST;
    std::unique_ptr<clang::ASTUnit> cAST;
    std::unique_ptr<clang::CNodeBuilder> builder;
    std::unique_ptr<HandlerContext> context;

    void SetUp() override {
        // Create real AST contexts using minimal code
        cppAST = clang::tooling::buildASTFromCode("int dummy;");
        cAST = clang::tooling::buildASTFromCode("int dummy2;");

        ASSERT_NE(cppAST, nullptr) << "Failed to create C++ AST";
        ASSERT_NE(cAST, nullptr) << "Failed to create C AST";

        // Create builder and context
        builder = std::make_unique<clang::CNodeBuilder>(cAST->getASTContext());
        context = std::make_unique<HandlerContext>(
            cppAST->getASTContext(),
            cAST->getASTContext(),
            *builder
        );
    }

    void TearDown() override {
        context.reset();
        builder.reset();
        cAST.reset();
        cppAST.reset();
    }

    /**
     * @brief Helper class to extract expressions from AST
     */
    class ExprExtractor : public clang::RecursiveASTVisitor<ExprExtractor> {
    public:
        clang::Expr* foundExpr = nullptr;

        bool VisitExpr(clang::Expr* E) {
            if (!foundExpr && !llvm::isa<clang::ImplicitCastExpr>(E)) {
                foundExpr = E;
            }
            return true;
        }
    };

    /**
     * @brief Parse C++ code and extract first expression
     */
    clang::Expr* parseExpr(const std::string& code) {
        std::string fullCode = "void test() { " + code + "; }";
        auto AST = clang::tooling::buildASTFromCode(fullCode);
        if (!AST) return nullptr;

        ExprExtractor extractor;
        extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
        return extractor.foundExpr;
    }
};

// ============================================================================
// LITERALS (Tests 1-5)
// ============================================================================

/**
 * Test 1: Integer Literal
 * C++ Input: 42
 * Expected: IntegerLiteral with value 42
 */
TEST_F(ExpressionHandlerTest, IntegerLiteral) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("42");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::IntegerLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* intLit = llvm::dyn_cast<clang::IntegerLiteral>(result);
    ASSERT_NE(intLit, nullptr) << "Result is not IntegerLiteral";
    EXPECT_EQ(intLit->getValue().getLimitedValue(), 42);
}

/**
 * Test 2: Negative Integer Literal (via UnaryOperator)
 * C++ Input: -10
 * Expected: UnaryOperator with IntegerLiteral
 */
TEST_F(ExpressionHandlerTest, NegativeIntegerLiteral) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("-10");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
}

/**
 * Test 3: Floating Literal
 * C++ Input: 3.14
 * Expected: FloatingLiteral
 */
TEST_F(ExpressionHandlerTest, FloatingLiteral) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("3.14");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::FloatingLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* floatLit = llvm::dyn_cast<clang::FloatingLiteral>(result);
    ASSERT_NE(floatLit, nullptr) << "Result is not FloatingLiteral";
}

/**
 * Test 4: String Literal
 * C++ Input: "hello"
 * Expected: StringLiteral
 */
TEST_F(ExpressionHandlerTest, StringLiteral) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"hello\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "hello");
}

// ============================================================================
// STRING LITERALS - PHASE 3 TASK 1 (Comprehensive string support)
// ============================================================================

/**
 * Test: String Literal - Empty String
 * C++ Input: ""
 * Expected: StringLiteral with empty content
 */
TEST_F(ExpressionHandlerTest, StringLiteralEmpty) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "");
    EXPECT_EQ(strLit->getLength(), 0);
}

/**
 * Test: String Literal - Newline Escape
 * C++ Input: "hello\nworld"
 * Expected: StringLiteral with newline escape preserved
 */
TEST_F(ExpressionHandlerTest, StringLiteralWithNewline) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"hello\\nworld\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "hello\nworld");
}

/**
 * Test: String Literal - Tab Escape
 * C++ Input: "tab\there"
 * Expected: StringLiteral with tab escape preserved
 */
TEST_F(ExpressionHandlerTest, StringLiteralWithTab) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"tab\\there\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "tab\there");
}

/**
 * Test: String Literal - Quote Escape
 * C++ Input: "say \"hello\""
 * Expected: StringLiteral with escaped quotes preserved
 */
TEST_F(ExpressionHandlerTest, StringLiteralWithQuote) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"say \\\"hello\\\"\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "say \"hello\"");
}

/**
 * Test: String Literal - Backslash Escape
 * C++ Input: "path\\to\\file"
 * Expected: StringLiteral with backslash escape preserved
 */
TEST_F(ExpressionHandlerTest, StringLiteralWithBackslash) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"path\\\\to\\\\file\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "path\\to\\file");
}

/**
 * Test: String Literal - Multiple Escapes
 * C++ Input: "line1\nline2\tindented"
 * Expected: StringLiteral with multiple escape sequences
 */
TEST_F(ExpressionHandlerTest, StringLiteralMultipleEscapes) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"line1\\nline2\\tindented\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "line1\nline2\tindented");
}

/**
 * Test: String Literal - Null Character
 * C++ Input: "null\0char"
 * Expected: StringLiteral with null character preserved
 */
TEST_F(ExpressionHandlerTest, StringLiteralWithNull) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"null\\0char\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    // Note: String will contain null, so we check the length instead
    EXPECT_GT(strLit->getLength(), 0);
}

/**
 * Test: String Literal - Long String
 * C++ Input: "This is a longer string with multiple words and spaces"
 * Expected: StringLiteral with full content preserved
 */
TEST_F(ExpressionHandlerTest, StringLiteralLong) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"This is a longer string with multiple words and spaces\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "This is a longer string with multiple words and spaces");
}

/**
 * Test: String Literal - Special Characters
 * C++ Input: "!@#$%^&*()_+-={}[]|:;<>,.?/"
 * Expected: StringLiteral with special characters preserved
 */
TEST_F(ExpressionHandlerTest, StringLiteralSpecialChars) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"!@#$%^&*()_+-={}[]|:;<>,.?/\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "!@#$%^&*()_+-={}[]|:;<>,.?/");
}

/**
 * Test: String Literal - Numeric Content
 * C++ Input: "12345"
 * Expected: StringLiteral with numeric content
 */
TEST_F(ExpressionHandlerTest, StringLiteralNumeric) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("\"12345\"");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::StringLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result);
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
    EXPECT_EQ(strLit->getString().str(), "12345");
}

/**
 * Test 5: Character Literal
 * C++ Input: 'a'
 * Expected: CharacterLiteral
 */
TEST_F(ExpressionHandlerTest, CharacterLiteral) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'a'");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), 'a');
}

// ============================================================================
// CHARACTER LITERALS - PHASE 3 TASK 2 (Tests for comprehensive char support)
// ============================================================================

/**
 * Test: Simple Character Literal (uppercase)
 * C++ Input: 'Z'
 * Expected: CharacterLiteral with value 'Z'
 */
TEST_F(ExpressionHandlerTest, CharLiteralUppercase) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'Z'");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), 'Z');
}

/**
 * Test: Character Literal - Newline Escape Sequence
 * C++ Input: '\n'
 * Expected: CharacterLiteral with value 10 (newline)
 */
TEST_F(ExpressionHandlerTest, CharLiteralNewline) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'\\n'");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), '\n');
}

/**
 * Test: Character Literal - Tab Escape Sequence
 * C++ Input: '\t'
 * Expected: CharacterLiteral with value 9 (tab)
 */
TEST_F(ExpressionHandlerTest, CharLiteralTab) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'\\t'");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), '\t');
}

/**
 * Test: Character Literal - Backslash Escape Sequence
 * C++ Input: '\\'
 * Expected: CharacterLiteral with value 92 (backslash)
 */
TEST_F(ExpressionHandlerTest, CharLiteralBackslash) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'\\\\'");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), '\\');
}

/**
 * Test: Character Literal - Single Quote Escape Sequence
 * C++ Input: '\''
 * Expected: CharacterLiteral with value 39 (single quote)
 */
TEST_F(ExpressionHandlerTest, CharLiteralSingleQuote) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'\\''");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), '\'');
}

/**
 * Test: Character Literal - Null Character
 * C++ Input: '\0'
 * Expected: CharacterLiteral with value 0
 */
TEST_F(ExpressionHandlerTest, CharLiteralNull) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'\\0'");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), '\0');
}

/**
 * Test: Character Literal - Hexadecimal Escape
 * C++ Input: '\x41'
 * Expected: CharacterLiteral with value 65 ('A')
 */
TEST_F(ExpressionHandlerTest, CharLiteralHexEscape) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'\\x41'");
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_TRUE(llvm::isa<clang::CharacterLiteral>(cppExpr));

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* charLit = llvm::dyn_cast<clang::CharacterLiteral>(result);
    ASSERT_NE(charLit, nullptr) << "Result is not CharacterLiteral";
    EXPECT_EQ(charLit->getValue(), 0x41); // 'A'
}

/**
 * Test: Character Literal in Expression
 * C++ Input: 'a' + 1
 * Expected: BinaryOperator with CharacterLiteral and IntegerLiteral
 */
TEST_F(ExpressionHandlerTest, CharLiteralInExpression) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("'a' + 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add);

    // Verify LHS is a character literal (might be wrapped in implicit cast)
    auto* lhs = binOp->getLHS();
    ASSERT_NE(lhs, nullptr);
}

// ============================================================================
// BINARY OPERATORS (Tests 6-20)
// ============================================================================

/**
 * Test 6: Binary Addition
 * C++ Input: 1 + 2
 * Expected: BinaryOperator with BO_Add
 */
TEST_F(ExpressionHandlerTest, BinaryAddition) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 + 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add);
}

/**
 * Test 7: Binary Subtraction
 * C++ Input: 5 - 3
 * Expected: BinaryOperator with BO_Sub
 */
TEST_F(ExpressionHandlerTest, BinarySubtraction) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("5 - 3");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Sub);
}

/**
 * Test 8: Binary Multiplication
 * C++ Input: 4 * 5
 * Expected: BinaryOperator with BO_Mul
 */
TEST_F(ExpressionHandlerTest, BinaryMultiplication) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("4 * 5");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Mul);
}

/**
 * Test 9: Binary Division
 * C++ Input: 10 / 2
 * Expected: BinaryOperator with BO_Div
 */
TEST_F(ExpressionHandlerTest, BinaryDivision) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("10 / 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Div);
}

/**
 * Test 10: Binary Modulo
 * C++ Input: 7 % 3
 * Expected: BinaryOperator with BO_Rem
 */
TEST_F(ExpressionHandlerTest, BinaryModulo) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("7 % 3");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Rem);
}

/**
 * Test 11: Nested Addition
 * C++ Input: (1 + 2) + 3
 * Expected: Nested BinaryOperator tree
 */
TEST_F(ExpressionHandlerTest, NestedAddition) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 + 2) + 3");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add);

    // Check LHS is also a BinaryOperator
    auto* lhs = llvm::dyn_cast<clang::BinaryOperator>(binOp->getLHS()->IgnoreParens());
    ASSERT_NE(lhs, nullptr);
    EXPECT_EQ(lhs->getOpcode(), clang::BO_Add);
}

/**
 * Test 12: Mixed Arithmetic
 * C++ Input: 1 + 2 * 3
 * Expected: BinaryOperator respecting precedence
 */
TEST_F(ExpressionHandlerTest, MixedArithmetic) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 + 2 * 3");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add);
}

/**
 * Test 13: Complex Nesting
 * C++ Input: (1 + 2) * (3 - 4)
 * Expected: Nested BinaryOperators
 */
TEST_F(ExpressionHandlerTest, ComplexNesting) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 + 2) * (3 - 4)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Mul);
}

/**
 * Test 14: Comparison Equal
 * C++ Input: 1 == 2
 * Expected: BinaryOperator with BO_EQ
 */
TEST_F(ExpressionHandlerTest, ComparisonEqual) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 == 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_EQ);
}

/**
 * Test 15: Comparison Not Equal
 * C++ Input: 1 != 2
 * Expected: BinaryOperator with BO_NE
 */
TEST_F(ExpressionHandlerTest, ComparisonNotEqual) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 != 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_NE);
}

/**
 * Test 16: Comparison Less
 * C++ Input: 1 < 2
 * Expected: BinaryOperator with BO_LT
 */
TEST_F(ExpressionHandlerTest, ComparisonLess) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 < 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LT);
}

/**
 * Test 17: Comparison Greater
 * C++ Input: 1 > 2
 * Expected: BinaryOperator with BO_GT
 */
TEST_F(ExpressionHandlerTest, ComparisonGreater) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 > 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_GT);
}

/**
 * Test 18: Comparison Less Equal
 * C++ Input: 1 <= 2
 * Expected: BinaryOperator with BO_LE
 */
TEST_F(ExpressionHandlerTest, ComparisonLessEqual) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 <= 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LE);
}

/**
 * Test 19: Comparison Greater Equal
 * C++ Input: 1 >= 2
 * Expected: BinaryOperator with BO_GE
 */
TEST_F(ExpressionHandlerTest, ComparisonGreaterEqual) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 >= 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_GE);
}

/**
 * Test 20: Logical AND
 * C++ Input: 1 && 0
 * Expected: BinaryOperator with BO_LAnd
 */
TEST_F(ExpressionHandlerTest, LogicalAnd) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 && 0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);
}

// ============================================================================
// UNARY OPERATORS (Tests 21-25)
// ============================================================================

/**
 * Test 21: Unary Minus
 * C++ Input: -5
 * Expected: UnaryOperator with UO_Minus
 */
TEST_F(ExpressionHandlerTest, UnaryMinus) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("-5");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr);
    EXPECT_EQ(unOp->getOpcode(), clang::UO_Minus);
}

/**
 * Test 22: Unary Plus
 * C++ Input: +5
 * Expected: UnaryOperator with UO_Plus
 */
TEST_F(ExpressionHandlerTest, UnaryPlus) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("+5");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr);
    EXPECT_EQ(unOp->getOpcode(), clang::UO_Plus);
}

/**
 * Test 23: Unary Increment (prefix)
 * C++ Input: ++x
 * Expected: UnaryOperator with UO_PreInc
 */
TEST_F(ExpressionHandlerTest, UnaryIncrement) {
    // Arrange
    std::string code = "int x = 0; void test() { ++x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 24: Unary Decrement (prefix)
 * C++ Input: --x
 * Expected: UnaryOperator with UO_PreDec
 */
TEST_F(ExpressionHandlerTest, UnaryDecrement) {
    // Arrange
    std::string code = "int x = 10; void test() { --x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 25: Unary Logical NOT
 * C++ Input: !0
 * Expected: UnaryOperator with UO_LNot
 */
TEST_F(ExpressionHandlerTest, UnaryNot) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("!0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr);
    EXPECT_EQ(unOp->getOpcode(), clang::UO_LNot);
}

// ============================================================================
// DECLREFEXPR (Tests 26-30)
// ============================================================================

/**
 * Test 26: Simple Variable Reference
 * C++ Input: x
 * Expected: DeclRefExpr
 */
TEST_F(ExpressionHandlerTest, SimpleVarRef) {
    // Arrange
    std::string code = "int x = 5; void test() { x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 27: Variable Reference in Expression
 * C++ Input: x + 1
 * Expected: BinaryOperator with DeclRefExpr
 */
TEST_F(ExpressionHandlerTest, VarRefInExpr) {
    // Arrange
    std::string code = "int x = 5; void test() { x + 1; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr);
}

/**
 * Test 28: Multiple Variable References
 * C++ Input: x + y
 * Expected: BinaryOperator with two DeclRefExprs
 */
TEST_F(ExpressionHandlerTest, MultipleVarRefs) {
    // Arrange
    std::string code = "int x = 5; int y = 10; void test() { x + y; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 29: Variable Reference Nested
 * C++ Input: (x + y) * z
 * Expected: Nested operators with DeclRefExprs
 */
TEST_F(ExpressionHandlerTest, VarRefNested) {
    // Arrange
    std::string code = "int x=1, y=2, z=3; void test() { (x + y) * z; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 30: Variable Reference with Literal
 * C++ Input: x * 2
 * Expected: BinaryOperator with DeclRefExpr and IntegerLiteral
 */
TEST_F(ExpressionHandlerTest, VarRefWithLiteral) {
    // Arrange
    std::string code = "int x = 5; void test() { x * 2; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

// ============================================================================
// COMPLEX EXPRESSIONS (Tests 31-38)
// ============================================================================

/**
 * Test 31: Arithmetic Chain
 * C++ Input: 1 + 2 - 3 + 4
 * Expected: Chained BinaryOperators
 */
TEST_F(ExpressionHandlerTest, ArithmeticChain) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 + 2 - 3 + 4");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 32: Deep Nesting
 * C++ Input: ((1 + 2) * (3 - 4)) / 5
 * Expected: Deeply nested BinaryOperators
 */
TEST_F(ExpressionHandlerTest, DeepNesting) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("((1 + 2) * (3 - 4)) / 5");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 33: All Operators
 * C++ Input: (1 + 2) * 3 / 4 - 5 % 6
 * Expected: Mixed operator tree
 */
TEST_F(ExpressionHandlerTest, AllOperators) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 + 2) * 3 / 4 - 5 % 6");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 34: Logical Chain
 * C++ Input: 1 && 0 || 1
 * Expected: Chained logical operators
 */
TEST_F(ExpressionHandlerTest, LogicalChain) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 && 0 || 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 35: Mixed Comparison
 * C++ Input: (1 > 2) && (3 < 4)
 * Expected: Logical AND of comparisons
 */
TEST_F(ExpressionHandlerTest, MixedComparison) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 > 2) && (3 < 4)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 36: Parenthesized Expression
 * C++ Input: (42)
 * Expected: ParenExpr wrapping IntegerLiteral
 */
TEST_F(ExpressionHandlerTest, ParenthesizedExpr) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(42)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 37: Multi-Level Nesting
 * C++ Input: (((1 + 2) * 3) - 4) / 5
 * Expected: Multi-level nested operators
 */
TEST_F(ExpressionHandlerTest, MultiLevelNesting) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(((1 + 2) * 3) - 4) / 5");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

/**
 * Test 38: Complex Logical Expression
 * C++ Input: (1 > 0 && 2 < 100) || 3 == 42
 * Expected: Complex logical tree
 */
TEST_F(ExpressionHandlerTest, ComplexLogical) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 > 0 && 2 < 100) || 3 == 42");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr);
}

// ============================================================================
// UNARY OPERATORS - PHASE 2 TASK 3 (Tests 39-50)
// ============================================================================

/**
 * Test 39: Prefix Increment
 * C++ Input: ++x
 * Expected: UnaryOperator with UO_PreInc
 */
TEST_F(ExpressionHandlerTest, PrefixIncrement) {
    // Arrange
    std::string code = "int x = 0; void test() { ++x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_PreInc);
}

/**
 * Test 40: Prefix Decrement
 * C++ Input: --x
 * Expected: UnaryOperator with UO_PreDec
 */
TEST_F(ExpressionHandlerTest, PrefixDecrement) {
    // Arrange
    std::string code = "int x = 10; void test() { --x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_PreDec);
}

/**
 * Test 41: Prefix Increment in Expression
 * C++ Input: ++x + y
 * Expected: Addition with prefix increment on LHS
 */
TEST_F(ExpressionHandlerTest, PrefixInExpression) {
    // Arrange
    std::string code = "int x = 0; int y = 5; void test() { ++x + y; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    auto* lhsUnOp = llvm::dyn_cast<clang::UnaryOperator>(binOp->getLHS());
    ASSERT_NE(lhsUnOp, nullptr) << "LHS is not UnaryOperator";
    EXPECT_EQ(lhsUnOp->getOpcode(), clang::UO_PreInc);
}

/**
 * Test 42: Prefix Nested
 * C++ Input: ++(++x)
 * Expected: Nested UnaryOperator with UO_PreInc
 */
TEST_F(ExpressionHandlerTest, PrefixNested) {
    // Arrange
    std::string code = "int x = 0; void test() { ++(++x); }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_PreInc);
}

/**
 * Test 43: Postfix Increment
 * C++ Input: x++
 * Expected: UnaryOperator with UO_PostInc
 */
TEST_F(ExpressionHandlerTest, PostfixIncrement) {
    // Arrange
    std::string code = "int x = 0; void test() { x++; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_PostInc);
}

/**
 * Test 44: Postfix Decrement
 * C++ Input: x--
 * Expected: UnaryOperator with UO_PostDec
 */
TEST_F(ExpressionHandlerTest, PostfixDecrement) {
    // Arrange
    std::string code = "int x = 10; void test() { x--; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_PostDec);
}

/**
 * Test 45: Postfix Increment in Expression
 * C++ Input: x++ + y
 * Expected: Addition with postfix increment on LHS
 */
TEST_F(ExpressionHandlerTest, PostfixInExpression) {
    // Arrange
    std::string code = "int x = 0; int y = 5; void test() { x++ + y; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    auto* lhsUnOp = llvm::dyn_cast<clang::UnaryOperator>(binOp->getLHS());
    ASSERT_NE(lhsUnOp, nullptr) << "LHS is not UnaryOperator";
    EXPECT_EQ(lhsUnOp->getOpcode(), clang::UO_PostInc);
}

/**
 * Test 46: Postfix Nested (edge case - invalid C++)
 * C++ Input: (x++)++
 * Note: This is invalid in C++, so we test a valid variant
 */
TEST_F(ExpressionHandlerTest, PostfixNested) {
    // Arrange - test valid postfix nested in parentheses
    std::string code = "int x = 0; void test() { (x++); }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
}

/**
 * Test 47: Unary Minus
 * C++ Input: -x
 * Expected: UnaryOperator with UO_Minus
 */
TEST_F(ExpressionHandlerTest, UnaryMinusOperator) {
    // Arrange
    std::string code = "int x = 5; void test() { -x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_Minus);
}

/**
 * Test 48: Unary Plus
 * C++ Input: +x
 * Expected: UnaryOperator with UO_Plus
 */
TEST_F(ExpressionHandlerTest, UnaryPlusOperator) {
    // Arrange
    std::string code = "int x = 5; void test() { +x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_Plus);
}

/**
 * Test 49: Unary Minus in Expression
 * C++ Input: a + (-b)
 * Expected: BinaryOperator with negated subexpression
 */
TEST_F(ExpressionHandlerTest, UnaryMinusInExpression) {
    // Arrange
    std::string code = "int a = 5; int b = 3; void test() { a + (-b); }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add);
    auto* rhsUnOp = llvm::dyn_cast<clang::UnaryOperator>(binOp->getRHS()->IgnoreParens());
    ASSERT_NE(rhsUnOp, nullptr) << "RHS is not UnaryOperator";
    EXPECT_EQ(rhsUnOp->getOpcode(), clang::UO_Minus);
}

/**
 * Test 50: Double Negative
 * C++ Input: -(-x)
 * Expected: Nested UnaryOperator with UO_Minus
 */
TEST_F(ExpressionHandlerTest, DoubleNegative) {
    // Arrange
    std::string code = "int x = 5; void test() { -(-x); }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_Minus);
    auto* subUnOp = llvm::dyn_cast<clang::UnaryOperator>(unOp->getSubExpr()->IgnoreParens());
    ASSERT_NE(subUnOp, nullptr) << "Subexpression is not UnaryOperator";
    EXPECT_EQ(subUnOp->getOpcode(), clang::UO_Minus);
}

// ============================================================================
// COMPARISON OPERATORS - PHASE 2 TASK 1 (Tests 39-50)
// ============================================================================

/**
 * Test 39: Equality Operator with Integers
 * C++ Input: 5 == 10
 * Expected: BinaryOperator with BO_EQ
 */
TEST_F(ExpressionHandlerTest, EqualityOperator) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("5 == 10");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_EQ);
}

/**
 * Test 40: Inequality Operator
 * C++ Input: 5 != 10
 * Expected: BinaryOperator with BO_NE
 */
TEST_F(ExpressionHandlerTest, InequalityOperator) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("5 != 10");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_NE);
}

/**
 * Test 41: Equality with Zero
 * C++ Input: 0 == 0
 * Expected: BinaryOperator with BO_EQ
 */
TEST_F(ExpressionHandlerTest, EqualityWithLiterals) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("0 == 0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_EQ);
}

/**
 * Test 42: Inequality with 42
 * C++ Input: 42 != 0
 * Expected: BinaryOperator with BO_NE
 */
TEST_F(ExpressionHandlerTest, InequalityWithLiterals) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("42 != 0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_NE);
}

/**
 * Test 43: Less Than Operator
 * C++ Input: 5 < 10
 * Expected: BinaryOperator with BO_LT
 */
TEST_F(ExpressionHandlerTest, LessThanOperator) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("5 < 10");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LT);
}

/**
 * Test 44: Greater Than Operator
 * C++ Input: 15 > 10
 * Expected: BinaryOperator with BO_GT
 */
TEST_F(ExpressionHandlerTest, GreaterThanOperator) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("15 > 10");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_GT);
}

/**
 * Test 45: Less Or Equal Operator
 * C++ Input: 5 <= 10
 * Expected: BinaryOperator with BO_LE
 */
TEST_F(ExpressionHandlerTest, LessOrEqualOperator) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("5 <= 10");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LE);
}

/**
 * Test 46: Greater Or Equal Operator
 * C++ Input: 15 >= 10
 * Expected: BinaryOperator with BO_GE
 */
TEST_F(ExpressionHandlerTest, GreaterOrEqualOperator) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("15 >= 10");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_GE);
}

/**
 * Test 47: Relational with Different Literals
 * C++ Input: 7 < 20
 * Expected: BinaryOperator with BO_LT
 */
TEST_F(ExpressionHandlerTest, RelationalWithLiterals) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("7 < 20");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LT);
}

/**
 * Test 48: Relational Chaining with Logical AND
 * C++ Input: 1 < 2 && 2 < 3
 * Expected: LogicalAnd of two comparisons
 */
TEST_F(ExpressionHandlerTest, RelationalChaining) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 < 2 && 2 < 3");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);
}

/**
 * Test 49: Negative Comparison
 * C++ Input: -5 < 0
 * Expected: Comparison with negative literal
 */
TEST_F(ExpressionHandlerTest, NegativeComparison) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("-5 < 0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LT);
}

/**
 * Test 50: Float Comparison
 * C++ Input: 2.5 > 3.14
 * Expected: Comparison with floating literal
 */
TEST_F(ExpressionHandlerTest, FloatComparison) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("2.5 > 3.14");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_GT);
}


// ============================================================================
// LOGICAL OPERATORS - TASK 2 (15 tests)
// ============================================================================

/**
 * Test 51: Logical AND Basic
 * C++ Input: a && b
 * Expected: BinaryOperator with BO_LAnd
 */
TEST_F(ExpressionHandlerTest, LogicalAndBasic) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 && 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);
}

/**
 * Test 52: Logical AND With Comparison
 * C++ Input: x > 0 && y < 10
 * Expected: BinaryOperator(BO_LAnd) with comparison operators
 */
TEST_F(ExpressionHandlerTest, LogicalAndWithComparison) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 > 0) && (2 < 10)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);
}

/**
 * Test 53: Logical AND Chain
 * C++ Input: a && b && c
 * Expected: Chained BinaryOperators with BO_LAnd
 */
TEST_F(ExpressionHandlerTest, LogicalAndChain) {
    // Arrange - Use simpler expression that parseExpr handles properly
    clang::Expr* cppExpr = parseExpr("(1 && 1) && 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);
}

/**
 * Test 54: Logical AND Nested
 * C++ Input: (a && b) && (c && d)
 * Expected: Nested BinaryOperators with BO_LAnd
 */
TEST_F(ExpressionHandlerTest, LogicalAndNested) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 && 2) && (3 && 4)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);
}

/**
 * Test 55: Logical AND Short-Circuit Semantics
 * C++ Input: 1 && 0
 * Expected: BinaryOperator with preserved structure
 */
TEST_F(ExpressionHandlerTest, LogicalAndShortCircuit) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 && 0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);
    ASSERT_NE(binOp->getLHS(), nullptr);
    ASSERT_NE(binOp->getRHS(), nullptr);
}

/**
 * Test 56: Logical OR Basic
 * C++ Input: a || b
 * Expected: BinaryOperator with BO_LOr
 */
TEST_F(ExpressionHandlerTest, LogicalOrBasic) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 || 0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LOr);
}

/**
 * Test 57: Logical OR With Comparison
 * C++ Input: x < 0 || x > 100
 * Expected: BinaryOperator(BO_LOr) with comparison operators
 */
TEST_F(ExpressionHandlerTest, LogicalOrWithComparison) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 < 0) || (1 > 100)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LOr);
}

/**
 * Test 58: Logical OR Chain
 * C++ Input: a || b || c
 * Expected: Chained BinaryOperators with BO_LOr
 */
TEST_F(ExpressionHandlerTest, LogicalOrChain) {
    // Arrange - Use simpler expression that parseExpr handles properly
    clang::Expr* cppExpr = parseExpr("(0 || 1) || 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LOr);
}

/**
 * Test 59: Logical OR Nested
 * C++ Input: (a || b) || (c || d)
 * Expected: Nested BinaryOperators with BO_LOr
 */
TEST_F(ExpressionHandlerTest, LogicalOrNested) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(1 || 0) || (0 || 1)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LOr);
}

/**
 * Test 60: Logical OR Short-Circuit Semantics
 * C++ Input: 1 || 0
 * Expected: BinaryOperator with preserved structure
 */
TEST_F(ExpressionHandlerTest, LogicalOrShortCircuit) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 || 0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LOr);
    ASSERT_NE(binOp->getLHS(), nullptr);
    ASSERT_NE(binOp->getRHS(), nullptr);
}

/**
 * Test 61: Logical NOT Basic
 * C++ Input: !a
 * Expected: UnaryOperator with UO_LNot
 */
TEST_F(ExpressionHandlerTest, LogicalNotBasic) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("!1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_LNot);
}

/**
 * Test 62: Logical NOT With Comparison
 * C++ Input: !(x > 0)
 * Expected: UnaryOperator(UO_LNot) with comparison operator
 */
TEST_F(ExpressionHandlerTest, LogicalNotWithComparison) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("!(1 > 0)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_LNot);
}

/**
 * Test 63: Logical NOT Double Negation
 * C++ Input: !!x
 * Expected: Nested UnaryOperators with UO_LNot
 */
TEST_F(ExpressionHandlerTest, LogicalNotDouble) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("!!1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_LNot);

    auto* innerExpr = unOp->getSubExpr();
    ASSERT_NE(innerExpr, nullptr);
    auto* innerUnOp = llvm::dyn_cast<clang::UnaryOperator>(innerExpr->IgnoreParens());
    ASSERT_NE(innerUnOp, nullptr);
    EXPECT_EQ(innerUnOp->getOpcode(), clang::UO_LNot);
}

/**
 * Test 64: Logical NOT In Condition
 * C++ Input: !a && b
 * Expected: BinaryOperator(BO_LAnd) with left UnaryOperator(UO_LNot)
 */
TEST_F(ExpressionHandlerTest, LogicalNotInCondition) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("!0 && 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LAnd);

    auto* lhs = llvm::dyn_cast<clang::UnaryOperator>(binOp->getLHS()->IgnoreParens());
    ASSERT_NE(lhs, nullptr) << "LHS is not UnaryOperator";
    EXPECT_EQ(lhs->getOpcode(), clang::UO_LNot);
}

/**
 * Test 65: Logical NOT Complex
 * C++ Input: !(a && b || c)
 * Expected: UnaryOperator(UO_LNot) with complex logical expression
 */
TEST_F(ExpressionHandlerTest, LogicalNotComplex) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("!(1 && 0 || 1)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_LNot);

    auto* innerExpr = unOp->getSubExpr();
    ASSERT_NE(innerExpr, nullptr);
    auto* innerBinOp = llvm::dyn_cast<clang::BinaryOperator>(innerExpr->IgnoreParens());
    ASSERT_NE(innerBinOp, nullptr) << "Inner expression is not BinaryOperator";
}

// ============================================================================
// ARRAY INITIALIZATION (InitListExpr) - PHASE 3 TASK 4
// ============================================================================

/**
 * Test 66: Full Array Initialization
 * C++ Input: int arr[3] = {1, 2, 3}
 * Expected: InitListExpr with 3 integer literals
 */
TEST_F(ExpressionHandlerTest, InitListExpr_FullArrayInit) {
    // Arrange
    std::string code = "int arr[3] = {1, 2, 3};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Extract InitListExpr from VarDecl
    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found) found = ILE;
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    clang::InitListExpr* cppInit = extractor.found;

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppInit, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    EXPECT_EQ(initList->getNumInits(), 3);

    // Verify each element
    for (unsigned i = 0; i < 3; ++i) {
        auto* init = initList->getInit(i);
        ASSERT_NE(init, nullptr) << "Init " << i << " is null";
        auto* intLit = llvm::dyn_cast<clang::IntegerLiteral>(init);
        ASSERT_NE(intLit, nullptr) << "Init " << i << " is not IntegerLiteral";
        EXPECT_EQ(intLit->getValue().getLimitedValue(), i + 1);
    }
}

/**
 * Test 67: Partial Array Initialization
 * C++ Input: int arr[5] = {1, 2}
 * Expected: InitListExpr with 2 integer literals (remaining elements zero-initialized)
 */
TEST_F(ExpressionHandlerTest, InitListExpr_PartialArrayInit) {
    // Arrange
    std::string code = "int arr[5] = {1, 2};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found) found = ILE;
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    // C initializer lists preserve explicit inits, may have implicit zero inits
    EXPECT_GE(initList->getNumInits(), 2);
}

/**
 * Test 68: Nested Array Initialization (2D)
 * C++ Input: int matrix[2][2] = {{1, 2}, {3, 4}}
 * Expected: InitListExpr with 2 nested InitListExpr
 */
TEST_F(ExpressionHandlerTest, InitListExpr_NestedArrayInit) {
    // Arrange
    std::string code = "int matrix[2][2] = {{1, 2}, {3, 4}};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found && ILE->getNumInits() == 2) {
                // Get the outer InitListExpr (the one with 2 sub-lists)
                found = ILE;
            }
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    EXPECT_EQ(initList->getNumInits(), 2);

    // Verify nested structure
    for (unsigned i = 0; i < 2; ++i) {
        auto* nested = llvm::dyn_cast<clang::InitListExpr>(initList->getInit(i));
        ASSERT_NE(nested, nullptr) << "Nested init " << i << " is not InitListExpr";
        EXPECT_EQ(nested->getNumInits(), 2);
    }
}

/**
 * Test 69: Empty Initializer
 * C++ Input: int arr[3] = {}
 * Expected: InitListExpr with 0 explicit inits (zero-initialized)
 */
TEST_F(ExpressionHandlerTest, InitListExpr_EmptyInit) {
    // Arrange
    std::string code = "int arr[3] = {};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found) found = ILE;
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
}

/**
 * Test 70: Initializer with Expressions
 * C++ Input: int arr[3] = {1 + 1, 2 * 2, 3 - 1}
 * Expected: InitListExpr with 3 binary operator expressions
 */
TEST_F(ExpressionHandlerTest, InitListExpr_WithExpressions) {
    // Arrange
    std::string code = "int arr[3] = {1 + 1, 2 * 2, 3 - 1};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found) found = ILE;
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    EXPECT_EQ(initList->getNumInits(), 3);

    // Verify first element is a binary operator
    auto* firstInit = initList->getInit(0);
    ASSERT_NE(firstInit, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(firstInit);
    ASSERT_NE(binOp, nullptr) << "First init is not BinaryOperator";
}

/**
 * Test 71: String Array Initialization
 * C++ Input: const char* arr[2] = {"hello", "world"}
 * Expected: InitListExpr with 2 string literals
 */
TEST_F(ExpressionHandlerTest, InitListExpr_StringArray) {
    // Arrange
    std::string code = "const char* arr[2] = {\"hello\", \"world\"};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found) found = ILE;
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    EXPECT_EQ(initList->getNumInits(), 2);
}

/**
 * Test 72: Single Element Initialization
 * C++ Input: int arr[1] = {42}
 * Expected: InitListExpr with 1 integer literal
 */
TEST_F(ExpressionHandlerTest, InitListExpr_SingleElement) {
    // Arrange
    std::string code = "int arr[1] = {42};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found) found = ILE;
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    EXPECT_EQ(initList->getNumInits(), 1);

    auto* intLit = llvm::dyn_cast<clang::IntegerLiteral>(initList->getInit(0));
    ASSERT_NE(intLit, nullptr);
    EXPECT_EQ(intLit->getValue().getLimitedValue(), 42);
}

/**
 * Test 73: Nested with Different Depths
 * C++ Input: int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}
 * Expected: InitListExpr with properly nested structure
 */
TEST_F(ExpressionHandlerTest, InitListExpr_DeeperNesting) {
    // Arrange
    std::string code = "int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found && ILE->getNumInits() == 2) {
                // Get the outer InitListExpr
                found = ILE;
            }
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    EXPECT_EQ(initList->getNumInits(), 2);

    // Verify first nested list has 3 elements
    auto* nested = llvm::dyn_cast<clang::InitListExpr>(initList->getInit(0));
    ASSERT_NE(nested, nullptr);
    EXPECT_EQ(nested->getNumInits(), 3);
}

/**
 * Test 74: Mixed Nested and Flat Initialization
 * C++ Input: int arr[3][2] = {{1, 2}, {3, 4}, {5, 6}}
 * Expected: InitListExpr with 3 nested InitListExpr, each with 2 elements
 */
TEST_F(ExpressionHandlerTest, InitListExpr_MixedNesting) {
    // Arrange
    std::string code = "int arr[3][2] = {{1, 2}, {3, 4}, {5, 6}};";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    class InitListExtractor : public clang::RecursiveASTVisitor<InitListExtractor> {
    public:
        clang::InitListExpr* found = nullptr;
        bool VisitInitListExpr(clang::InitListExpr* ILE) {
            if (!found && ILE->getNumInits() == 3) {
                // Get the outer InitListExpr
                found = ILE;
            }
            return true;
        }
    };

    InitListExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(extractor.found, nullptr) << "InitListExpr not found in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(extractor.found, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* initList = llvm::dyn_cast<clang::InitListExpr>(result);
    ASSERT_NE(initList, nullptr) << "Result is not InitListExpr";
    EXPECT_EQ(initList->getNumInits(), 3);

    // Verify all 3 nested lists have 2 elements each
    for (unsigned i = 0; i < 3; ++i) {
        auto* nested = llvm::dyn_cast<clang::InitListExpr>(initList->getInit(i));
        ASSERT_NE(nested, nullptr) << "Nested init " << i << " is not InitListExpr";
        EXPECT_EQ(nested->getNumInits(), 2);
    }
}

// ============================================================================
// ARRAY SUBSCRIPT - PHASE 3 TASK 5 (Array subscript support)
// ============================================================================

/**
 * Test: Array Subscript - Simple subscript
 * C++ Input: arr[0]
 * Expected: ArraySubscriptExpr with IntegerLiteral index
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptSimple) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            arr[0];
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the array subscript expression
    class ArraySubscriptFinder : public clang::RecursiveASTVisitor<ArraySubscriptFinder> {
    public:
        clang::ArraySubscriptExpr* result = nullptr;
        bool VisitArraySubscriptExpr(clang::ArraySubscriptExpr* ASE) {
            if (!result) result = ASE;
            return true;
        }
    };

    ArraySubscriptFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.result, nullptr) << "Failed to find ArraySubscriptExpr in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.result, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* arraySubExpr = llvm::dyn_cast<clang::ArraySubscriptExpr>(result);
    ASSERT_NE(arraySubExpr, nullptr) << "Result is not ArraySubscriptExpr";

    // Verify base is a DeclRefExpr
    auto* base = arraySubExpr->getBase();
    ASSERT_NE(base, nullptr);

    // Verify index is IntegerLiteral with value 0
    auto* idx = arraySubExpr->getIdx();
    ASSERT_NE(idx, nullptr);
    auto* intLit = llvm::dyn_cast<clang::IntegerLiteral>(idx->IgnoreParenImpCasts());
    ASSERT_NE(intLit, nullptr) << "Index is not IntegerLiteral";
    EXPECT_EQ(intLit->getValue().getLimitedValue(), 0);
}

/**
 * Test: Array Subscript - Variable index
 * C++ Input: arr[i]
 * Expected: ArraySubscriptExpr with DeclRefExpr index
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptVariableIndex) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int i = 5;
            arr[i];
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the array subscript expression
    class ArraySubscriptFinder : public clang::RecursiveASTVisitor<ArraySubscriptFinder> {
    public:
        clang::ArraySubscriptExpr* result = nullptr;
        bool VisitArraySubscriptExpr(clang::ArraySubscriptExpr* ASE) {
            if (!result) result = ASE;
            return true;
        }
    };

    ArraySubscriptFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.result, nullptr) << "Failed to find ArraySubscriptExpr in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.result, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* arraySubExpr = llvm::dyn_cast<clang::ArraySubscriptExpr>(result);
    ASSERT_NE(arraySubExpr, nullptr) << "Result is not ArraySubscriptExpr";

    // Verify index is a DeclRefExpr
    auto* idx = arraySubExpr->getIdx();
    ASSERT_NE(idx, nullptr);
}

/**
 * Test: Array Subscript - Expression index
 * C++ Input: arr[i + 1]
 * Expected: ArraySubscriptExpr with BinaryOperator index
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptExpressionIndex) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int i = 5;
            arr[i + 1];
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the array subscript expression
    class ArraySubscriptFinder : public clang::RecursiveASTVisitor<ArraySubscriptFinder> {
    public:
        clang::ArraySubscriptExpr* result = nullptr;
        bool VisitArraySubscriptExpr(clang::ArraySubscriptExpr* ASE) {
            if (!result) result = ASE;
            return true;
        }
    };

    ArraySubscriptFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.result, nullptr) << "Failed to find ArraySubscriptExpr in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.result, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* arraySubExpr = llvm::dyn_cast<clang::ArraySubscriptExpr>(result);
    ASSERT_NE(arraySubExpr, nullptr) << "Result is not ArraySubscriptExpr";

    // Verify index is a BinaryOperator
    auto* idx = arraySubExpr->getIdx();
    ASSERT_NE(idx, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(idx->IgnoreParenImpCasts());
    ASSERT_NE(binOp, nullptr) << "Index is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add);
}

/**
 * Test: Array Subscript - Multi-dimensional subscript
 * C++ Input: matrix[i][j]
 * Expected: Nested ArraySubscriptExpr
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptMultiDimensional) {
    // Arrange
    std::string code = R"(
        void test() {
            int matrix[3][4];
            int i = 1, j = 2;
            matrix[i][j];
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find all array subscript expressions (there should be 2: matrix[i] and matrix[i][j])
    class ArraySubscriptFinder : public clang::RecursiveASTVisitor<ArraySubscriptFinder> {
    public:
        std::vector<clang::ArraySubscriptExpr*> results;
        bool VisitArraySubscriptExpr(clang::ArraySubscriptExpr* ASE) {
            results.push_back(ASE);
            return true;
        }
    };

    ArraySubscriptFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_EQ(finder.results.size(), 2u) << "Expected 2 ArraySubscriptExpr nodes";

    // Act - translate the outer subscript (matrix[i][j])
    // Find the one that has an ArraySubscriptExpr as its base
    clang::ArraySubscriptExpr* outerASE = nullptr;
    for (auto* ase : finder.results) {
        if (llvm::isa<clang::ArraySubscriptExpr>(ase->getBase()->IgnoreParenImpCasts())) {
            outerASE = ase;
            break;
        }
    }
    ASSERT_NE(outerASE, nullptr) << "Failed to find outer ArraySubscriptExpr";

    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(outerASE, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* outerSub = llvm::dyn_cast<clang::ArraySubscriptExpr>(result);
    ASSERT_NE(outerSub, nullptr) << "Result is not ArraySubscriptExpr";

    // Verify the base exists (we don't strictly require it to be ArraySubscriptExpr
    // because our translation might simplify it, but it should translate successfully)
    auto* base = outerSub->getBase();
    ASSERT_NE(base, nullptr) << "Base is null";
}

/**
 * Test: Array Subscript - As lvalue (assignment target)
 * C++ Input: arr[0] = 42
 * Expected: BinaryOperator with ArraySubscriptExpr LHS
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptAsLValue) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            arr[0] = 42;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the assignment expression
    class AssignmentFinder : public clang::RecursiveASTVisitor<AssignmentFinder> {
    public:
        clang::BinaryOperator* result = nullptr;
        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (!result && BO->getOpcode() == clang::BO_Assign) {
                result = BO;
            }
            return true;
        }
    };

    AssignmentFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.result, nullptr) << "Failed to find assignment in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.result, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* assignOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(assignOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(assignOp->getOpcode(), clang::BO_Assign);

    // Verify LHS is ArraySubscriptExpr
    auto* lhs = assignOp->getLHS();
    ASSERT_NE(lhs, nullptr);
    auto* arraySubExpr = llvm::dyn_cast<clang::ArraySubscriptExpr>(lhs->IgnoreParenImpCasts());
    ASSERT_NE(arraySubExpr, nullptr) << "LHS is not ArraySubscriptExpr";
}

/**
 * Test: Array Subscript - In expression
 * C++ Input: arr[0] + arr[1]
 * Expected: BinaryOperator with two ArraySubscriptExpr operands
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptInExpression) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            arr[0] + arr[1];
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the addition expression
    class BinaryOpFinder : public clang::RecursiveASTVisitor<BinaryOpFinder> {
    public:
        clang::BinaryOperator* result = nullptr;
        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (!result && BO->getOpcode() == clang::BO_Add) {
                result = BO;
            }
            return true;
        }
    };

    BinaryOpFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.result, nullptr) << "Failed to find addition in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.result, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* addOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(addOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(addOp->getOpcode(), clang::BO_Add);

    // Verify both operands are ArraySubscriptExpr
    auto* lhs = addOp->getLHS();
    ASSERT_NE(lhs, nullptr);
    auto* lhsArray = llvm::dyn_cast<clang::ArraySubscriptExpr>(lhs->IgnoreParenImpCasts());
    ASSERT_NE(lhsArray, nullptr) << "LHS is not ArraySubscriptExpr";

    auto* rhs = addOp->getRHS();
    ASSERT_NE(rhs, nullptr);
    auto* rhsArray = llvm::dyn_cast<clang::ArraySubscriptExpr>(rhs->IgnoreParenImpCasts());
    ASSERT_NE(rhsArray, nullptr) << "RHS is not ArraySubscriptExpr";
}

/**
 * Test: Array Subscript - Nested in complex expression
 * C++ Input: (arr[i] * 2) + arr[j]
 * Expected: Complex expression with ArraySubscriptExpr nodes
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptComplexExpression) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int i = 1, j = 2;
            (arr[i] * 2) + arr[j];
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the outer addition expression
    class BinaryOpFinder : public clang::RecursiveASTVisitor<BinaryOpFinder> {
    public:
        clang::BinaryOperator* result = nullptr;
        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (!result && BO->getOpcode() == clang::BO_Add) {
                result = BO;
            }
            return true;
        }
    };

    BinaryOpFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.result, nullptr) << "Failed to find addition in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.result, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* addOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(addOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(addOp->getOpcode(), clang::BO_Add);
}

/**
 * Test: Array Subscript - With calculation in index
 * C++ Input: arr[i * 2 + 1]
 * Expected: ArraySubscriptExpr with complex index expression
 */
TEST_F(ExpressionHandlerTest, ArraySubscriptComplexIndex) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int i = 2;
            arr[i * 2 + 1];
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the array subscript expression
    class ArraySubscriptFinder : public clang::RecursiveASTVisitor<ArraySubscriptFinder> {
    public:
        clang::ArraySubscriptExpr* result = nullptr;
        bool VisitArraySubscriptExpr(clang::ArraySubscriptExpr* ASE) {
            if (!result) result = ASE;
            return true;
        }
    };

    ArraySubscriptFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.result, nullptr) << "Failed to find ArraySubscriptExpr in AST";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.result, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* arraySubExpr = llvm::dyn_cast<clang::ArraySubscriptExpr>(result);
    ASSERT_NE(arraySubExpr, nullptr) << "Result is not ArraySubscriptExpr";

    // Verify index is a BinaryOperator (i * 2 + 1)
    auto* idx = arraySubExpr->getIdx();
    ASSERT_NE(idx, nullptr);
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(idx->IgnoreParenImpCasts());
    ASSERT_NE(binOp, nullptr) << "Index is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add);
}

// ============================================================================
// C-STYLE CASTS (Tests 81-90)
// ============================================================================

/**
 * Test 81: Simple C-style cast to int
 * C++ Input: (int)x
 * Expected: CStyleCastExpr with int type
 */
TEST_F(ExpressionHandlerTest, CStyleCast_SimpleIntCast) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(int)3.14");
    ASSERT_NE(cppExpr, nullptr);
    auto* castExpr = llvm::dyn_cast<clang::CStyleCastExpr>(cppExpr->IgnoreParenImpCasts());
    ASSERT_NE(castExpr, nullptr) << "Expected CStyleCastExpr";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* resultCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(resultCast, nullptr) << "Result is not CStyleCastExpr";

    // Verify the subexpression was translated
    auto* subExpr = resultCast->getSubExpr();
    ASSERT_NE(subExpr, nullptr);
}

/**
 * Test 82: C-style pointer cast
 * C++ Input: (void*)ptr
 * Expected: CStyleCastExpr to void*
 */
TEST_F(ExpressionHandlerTest, CStyleCast_PointerCast) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(void*)0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* resultCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(resultCast, nullptr) << "Result is not CStyleCastExpr";
}

/**
 * Test 83: C-style const cast
 * C++ Input: (char*)const_str
 * Expected: CStyleCastExpr removing const
 */
TEST_F(ExpressionHandlerTest, CStyleCast_ConstCast) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(int*)\"hello\"");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* resultCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(resultCast, nullptr) << "Result is not CStyleCastExpr";
}

/**
 * Test 84: C-style cast in expression
 * C++ Input: (int)x + 1
 * Expected: BinaryOperator with CStyleCastExpr as LHS
 */
TEST_F(ExpressionHandlerTest, CStyleCast_InExpression) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(int)3.14 + 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";

    // Verify LHS is a cast
    auto* lhs = binOp->getLHS();
    ASSERT_NE(lhs, nullptr);
}

/**
 * Test 85: Nested C-style casts
 * C++ Input: (int)(float)x
 * Expected: CStyleCastExpr with CStyleCastExpr as subexpression
 */
TEST_F(ExpressionHandlerTest, CStyleCast_Nested) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(int)(float)42");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* outerCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(outerCast, nullptr) << "Result is not CStyleCastExpr";

    // Verify inner cast
    auto* subExpr = outerCast->getSubExpr();
    ASSERT_NE(subExpr, nullptr);
}

/**
 * Test 86: C-style cast to float
 * C++ Input: (float)42
 * Expected: CStyleCastExpr with float type
 */
TEST_F(ExpressionHandlerTest, CStyleCast_ToFloat) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(float)42");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* resultCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(resultCast, nullptr) << "Result is not CStyleCastExpr";
}

/**
 * Test 87: C-style cast with complex expression
 * C++ Input: (int)(a + b)
 * Expected: CStyleCastExpr with BinaryOperator as subexpression
 */
TEST_F(ExpressionHandlerTest, CStyleCast_ComplexExpr) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(int)(3 + 4)");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* resultCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(resultCast, nullptr) << "Result is not CStyleCastExpr";
}

/**
 * Test 88: C-style cast to char
 * C++ Input: (char)65
 * Expected: CStyleCastExpr with char type
 */
TEST_F(ExpressionHandlerTest, CStyleCast_ToChar) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(char)65");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* resultCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(resultCast, nullptr) << "Result is not CStyleCastExpr";
}

/**
 * Test 89: C-style cast in assignment
 * C++ Input: x = (int)y
 * Expected: BinaryOperator with CStyleCastExpr as RHS
 */
TEST_F(ExpressionHandlerTest, CStyleCast_InAssignment) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 + (int)3.14");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
}

/**
 * Test 90: C-style cast to long
 * C++ Input: (long)x
 * Expected: CStyleCastExpr with long type
 */
TEST_F(ExpressionHandlerTest, CStyleCast_ToLong) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("(long)42");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* resultCast = llvm::dyn_cast<clang::CStyleCastExpr>(result->IgnoreParenImpCasts());
    ASSERT_NE(resultCast, nullptr) << "Result is not CStyleCastExpr";
}

// ============================================================================
// IMPLICIT CASTS (Tests 91-98)
// ============================================================================

/**
 * Test 91: Implicit integer promotion
 * C++ Input: char + int operation
 * Expected: ImplicitCastExpr for integer promotion
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_IntegerPromotion) {
    // Arrange - use a simple expression that triggers implicit cast
    clang::Expr* cppExpr = parseExpr("'a' + 1");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    // The result should be a BinaryOperator
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
}

/**
 * Test 92: Implicit float to int conversion
 * C++ Input: float value in int context
 * Expected: Transparent handling or ImplicitCastExpr
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_FloatToInt) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("3.14");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
}

/**
 * Test 93: Implicit array to pointer decay
 * C++ Input: Array in pointer context
 * Expected: Transparent handling
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_ArrayToPointerDecay) {
    // Arrange - reference to array triggers decay
    // For testing, we just verify the handler processes the expression
    clang::Expr* cppExpr = parseExpr("\"hello\"");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* strLit = llvm::dyn_cast<clang::StringLiteral>(result->IgnoreParenImpCasts());
    ASSERT_NE(strLit, nullptr) << "Result is not StringLiteral";
}

/**
 * Test 94: Implicit lvalue to rvalue conversion
 * C++ Input: Variable used as rvalue
 * Expected: Transparent handling
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_LValueToRValue) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 + 2");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
}

/**
 * Test 95: Implicit integral conversion
 * C++ Input: int to long conversion
 * Expected: Transparent handling
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_IntegralConversion) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("42");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* intLit = llvm::dyn_cast<clang::IntegerLiteral>(result);
    ASSERT_NE(intLit, nullptr) << "Result is not IntegerLiteral";
}

/**
 * Test 96: Implicit NoOp cast
 * C++ Input: Expression with NoOp cast
 * Expected: Transparent handling
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_NoOp) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("0");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
}

/**
 * Test 97: Implicit bool conversion
 * C++ Input: Integer in boolean context
 * Expected: Transparent handling
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_BoolConversion) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("!42");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unaryOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unaryOp, nullptr) << "Result is not UnaryOperator";
}

/**
 * Test 98: Implicit conversion in complex expression
 * C++ Input: Mixed type arithmetic
 * Expected: Transparent handling of all implicit casts
 */
TEST_F(ExpressionHandlerTest, ImplicitCast_ComplexExpression) {
    // Arrange
    clang::Expr* cppExpr = parseExpr("1 + 2.5");
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
}

// ============================================================================
// PHASE 42: POINTERS & REFERENCES - ADDRESS-OF OPERATOR (Tests 99-106)
// ============================================================================

/**
 * Test 99: Address of variable (&x)
 * C++ Input: &x
 * Expected: UnaryOperator with UO_AddrOf
 */
TEST_F(ExpressionHandlerTest, AddressOf_SimpleVariable) {
    // Arrange
    // Helper class to find UnaryOperator specifically
    class UnaryOpExtractor : public clang::RecursiveASTVisitor<UnaryOpExtractor> {
    public:
        clang::UnaryOperator* foundOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (!foundOp) {
                foundOp = UO;
            }
            return true;
        }
    };

    std::string code = "int x = 5; void test() { &x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    UnaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::UnaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr);
    ASSERT_EQ(cppExpr->getOpcode(), clang::UO_AddrOf) << "C++ expr is not address-of";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_AddrOf);
}

/**
 * Test 100: Address of array element (&arr[i])
 * C++ Input: &arr[i]
 * Expected: UnaryOperator with UO_AddrOf wrapping ArraySubscriptExpr
 */
TEST_F(ExpressionHandlerTest, AddressOf_ArrayElement) {
    // Arrange
    class UnaryOpExtractor : public clang::RecursiveASTVisitor<UnaryOpExtractor> {
    public:
        clang::UnaryOperator* foundOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (!foundOp && UO->getOpcode() == clang::UO_AddrOf) {
                foundOp = UO;
            }
            return true;
        }
    };

    std::string code = "int arr[10]; int i = 0; void test() { &arr[i]; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    UnaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::UnaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_AddrOf);

    // Verify sub-expression is ArraySubscriptExpr
    auto* arrayExpr = llvm::dyn_cast<clang::ArraySubscriptExpr>(unOp->getSubExpr()->IgnoreImpCasts());
    EXPECT_NE(arrayExpr, nullptr) << "Subexpression is not ArraySubscriptExpr";
}

/**
 * Test 101: Address of dereferenced pointer (&*ptr)
 * C++ Input: &*ptr
 * Expected: UnaryOperator with UO_AddrOf wrapping UnaryOperator with UO_Deref
 */
TEST_F(ExpressionHandlerTest, AddressOf_DereferencedPointer) {
    // Arrange
    std::string code = "int x = 5; int* ptr = &x; void test() { &*ptr; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    // Note: The compiler might optimize &*ptr to ptr, so we accept either form
    // For now, just verify we get a valid result
}

/**
 * Test 102: Address in assignment (ptr = &x)
 * C++ Input: ptr = &x
 * Expected: BinaryOperator with RHS being UnaryOperator(UO_AddrOf)
 */
TEST_F(ExpressionHandlerTest, AddressOf_InAssignment) {
    // Arrange
    class BinaryOpExtractor : public clang::RecursiveASTVisitor<BinaryOpExtractor> {
    public:
        clang::BinaryOperator* foundOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (!foundOp && BO->getOpcode() == clang::BO_Assign) {
                foundOp = BO;
            }
            return true;
        }
    };

    std::string code = "int x = 5; int* ptr; void test() { ptr = &x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    BinaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::BinaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Assign);

    // Verify RHS is address-of operator
    auto* rhsUnOp = llvm::dyn_cast<clang::UnaryOperator>(binOp->getRHS()->IgnoreImpCasts());
    ASSERT_NE(rhsUnOp, nullptr) << "RHS is not UnaryOperator";
    EXPECT_EQ(rhsUnOp->getOpcode(), clang::UO_AddrOf);
}

/**
 * Test 103: Address in function call (func(&x))
 * C++ Input: &x in function argument position
 * Expected: UnaryOperator with UO_AddrOf
 */
TEST_F(ExpressionHandlerTest, AddressOf_InFunctionCall) {
    // Arrange
    class UnaryOpExtractor : public clang::RecursiveASTVisitor<UnaryOpExtractor> {
    public:
        clang::UnaryOperator* foundOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (!foundOp && UO->getOpcode() == clang::UO_AddrOf) {
                foundOp = UO;
            }
            return true;
        }
    };

    // For now, just test the address-of expression itself
    std::string code = "int x = 5; void test() { &x; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    UnaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::UnaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_AddrOf);
}

/**
 * Test 104: Address in expression (&x + 5)
 * C++ Input: &x + 5 (pointer arithmetic)
 * Expected: BinaryOperator with LHS being UnaryOperator(UO_AddrOf)
 */
TEST_F(ExpressionHandlerTest, AddressOf_InExpression) {
    // Arrange
    class BinaryOpExtractor : public clang::RecursiveASTVisitor<BinaryOpExtractor> {
    public:
        clang::BinaryOperator* foundOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (!foundOp && BO->getOpcode() == clang::BO_Add) {
                foundOp = BO;
            }
            return true;
        }
    };

    std::string code = "int x = 5; void test() { &x + 5; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    BinaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::BinaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";

    // Verify LHS is address-of operator
    auto* lhsUnOp = llvm::dyn_cast<clang::UnaryOperator>(binOp->getLHS()->IgnoreImpCasts());
    ASSERT_NE(lhsUnOp, nullptr) << "LHS is not UnaryOperator";
    EXPECT_EQ(lhsUnOp->getOpcode(), clang::UO_AddrOf);
}

/**
 * Test 105: Multiple address-of operators in expression
 * C++ Input: &a == &b
 * Expected: BinaryOperator with both sides being UnaryOperator(UO_AddrOf)
 */
TEST_F(ExpressionHandlerTest, AddressOf_MultipleInComparison) {
    // Arrange
    class BinaryOpExtractor : public clang::RecursiveASTVisitor<BinaryOpExtractor> {
    public:
        clang::BinaryOperator* foundOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (!foundOp && BO->getOpcode() == clang::BO_EQ) {
                foundOp = BO;
            }
            return true;
        }
    };

    std::string code = "int a; int b; void test() { &a == &b; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    BinaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::BinaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr) << "Failed to find BO_EQ operator";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_EQ);

    // Verify both sides are address-of operators
    auto* lhsUnOp = llvm::dyn_cast<clang::UnaryOperator>(binOp->getLHS()->IgnoreImpCasts());
    ASSERT_NE(lhsUnOp, nullptr) << "LHS is not UnaryOperator";
    EXPECT_EQ(lhsUnOp->getOpcode(), clang::UO_AddrOf);

    auto* rhsUnOp = llvm::dyn_cast<clang::UnaryOperator>(binOp->getRHS()->IgnoreImpCasts());
    ASSERT_NE(rhsUnOp, nullptr) << "RHS is not UnaryOperator";
    EXPECT_EQ(rhsUnOp->getOpcode(), clang::UO_AddrOf);
}

/**
 * Test 106: Address of with parentheses (&(x))
 * C++ Input: &(x)
 * Expected: UnaryOperator with UO_AddrOf wrapping ParenExpr
 */
TEST_F(ExpressionHandlerTest, AddressOf_WithParentheses) {
    // Arrange
    class UnaryOpExtractor : public clang::RecursiveASTVisitor<UnaryOpExtractor> {
    public:
        clang::UnaryOperator* foundOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (!foundOp && UO->getOpcode() == clang::UO_AddrOf) {
                foundOp = UO;
            }
            return true;
        }
    };

    std::string code = "int x; void test() { &(x); }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    UnaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::UnaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr) << "Failed to find UO_AddrOf operator";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_AddrOf);
}

// ============================================================================
// PHASE 42: POINTERS & REFERENCES - DEREFERENCE OPERATOR (Tests 107-114)
// ============================================================================

/**
 * Test 107: Simple dereference operator (*ptr)
 * C++ Input: *ptr
 * Expected: UnaryOperator with UO_Deref
 */
TEST_F(ExpressionHandlerTest, Dereference_SimplePointer) {
    // Arrange
    // Helper class to find UnaryOperator specifically
    class UnaryOpExtractor : public clang::RecursiveASTVisitor<UnaryOpExtractor> {
    public:
        clang::UnaryOperator* foundOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (!foundOp && UO->getOpcode() == clang::UO_Deref) {
                foundOp = UO;
            }
            return true;
        }
    };

    std::string code = "int x = 5; int* ptr = &x; void test() { *ptr; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    UnaryOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::UnaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr) << "Failed to find UO_Deref operator";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unOp->getOpcode(), clang::UO_Deref) << "Opcode is not UO_Deref";
}

/**
 * Test 108: Dereference in assignment (*ptr = 5)
 * C++ Input: *ptr = 5
 * Expected: BinaryOperator with UnaryOperator(UO_Deref) on LHS
 */
TEST_F(ExpressionHandlerTest, Dereference_InAssignment) {
    // Arrange
    // Helper class to find BinaryOperator specifically
    class BinOpExtractor : public clang::RecursiveASTVisitor<BinOpExtractor> {
    public:
        clang::BinaryOperator* foundOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (!foundOp && BO->getOpcode() == clang::BO_Assign) {
                foundOp = BO;
            }
            return true;
        }
    };

    std::string code = "int x = 0; int* ptr = &x; void test() { *ptr = 5; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    BinOpExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::BinaryOperator* cppExpr = extractor.foundOp;
    ASSERT_NE(cppExpr, nullptr) << "Failed to find BO_Assign operator";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Assign) << "Opcode is not BO_Assign";

    // Check LHS is dereference operator
    auto* lhs = llvm::dyn_cast<clang::UnaryOperator>(binOp->getLHS());
    ASSERT_NE(lhs, nullptr) << "LHS is not UnaryOperator";
    EXPECT_EQ(lhs->getOpcode(), clang::UO_Deref) << "LHS opcode is not UO_Deref";
}

/**
 * Test 109: Dereference in expression (*ptr + 1)
 * C++ Input: *ptr + 1
 * Expected: BinaryOperator with UnaryOperator(UO_Deref) on LHS
 */
TEST_F(ExpressionHandlerTest, Dereference_InExpression) {
    // Arrange
    std::string code = "int x = 5; int* ptr = &x; void test() { *ptr + 1; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add) << "Opcode is not BO_Add";
}

/**
 * Test 110: Double dereference (**pp)
 * C++ Input: **pp
 * Expected: Nested UnaryOperator with UO_Deref
 */
TEST_F(ExpressionHandlerTest, Dereference_Double) {
    // Arrange
    std::string code = "int x = 5; int* p = &x; int** pp = &p; void test() { **pp; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";

    // Outer dereference
    auto* outerDeref = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(outerDeref, nullptr) << "Outer result is not UnaryOperator";
    EXPECT_EQ(outerDeref->getOpcode(), clang::UO_Deref) << "Outer opcode is not UO_Deref";

    // Inner dereference
    auto* innerDeref = llvm::dyn_cast<clang::UnaryOperator>(outerDeref->getSubExpr());
    ASSERT_NE(innerDeref, nullptr) << "Inner result is not UnaryOperator";
    EXPECT_EQ(innerDeref->getOpcode(), clang::UO_Deref) << "Inner opcode is not UO_Deref";
}

/**
 * Test 111: Dereference with postfix increment (*ptr++)
 * C++ Input: *ptr++
 * Expected: Dereference of postfix increment
 */
TEST_F(ExpressionHandlerTest, Dereference_WithPostfixIncrement) {
    // Arrange
    std::string code = "int arr[5] = {1,2,3,4,5}; int* ptr = arr; void test() { *ptr++; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";

    // Outer operation should be dereference
    auto* deref = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(deref, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(deref->getOpcode(), clang::UO_Deref) << "Opcode is not UO_Deref";
}

/**
 * Test 112: Dereference of pointer arithmetic (*(arr + i))
 * C++ Input: *(arr + i)
 * Expected: Dereference of binary addition
 */
TEST_F(ExpressionHandlerTest, Dereference_PointerArithmetic) {
    // Arrange
    std::string code = "int arr[5] = {1,2,3,4,5}; int i = 2; void test() { *(arr + i); }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";

    // Outer operation should be dereference
    auto* deref = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(deref, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(deref->getOpcode(), clang::UO_Deref) << "Opcode is not UO_Deref";

    // Inner should be binary operator (addition)
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(deref->getSubExpr());
    ASSERT_NE(binOp, nullptr) << "Subexpression is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add) << "Subexpression opcode is not BO_Add";
}

/**
 * Test 113: Dereference in complex expression (*ptr1 + *ptr2)
 * C++ Input: *ptr1 + *ptr2
 * Expected: Addition of two dereferences
 */
TEST_F(ExpressionHandlerTest, Dereference_ComplexExpression) {
    // Arrange
    std::string code = "int x = 5; int y = 10; int* ptr1 = &x; int* ptr2 = &y; void test() { *ptr1 + *ptr2; }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";

    // Top level should be addition
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add) << "Opcode is not BO_Add";

    // LHS and RHS should both be dereferences
    auto* lhsDeref = llvm::dyn_cast<clang::UnaryOperator>(binOp->getLHS());
    ASSERT_NE(lhsDeref, nullptr) << "LHS is not UnaryOperator";
    EXPECT_EQ(lhsDeref->getOpcode(), clang::UO_Deref) << "LHS opcode is not UO_Deref";

    auto* rhsDeref = llvm::dyn_cast<clang::UnaryOperator>(binOp->getRHS());
    ASSERT_NE(rhsDeref, nullptr) << "RHS is not UnaryOperator";
    EXPECT_EQ(rhsDeref->getOpcode(), clang::UO_Deref) << "RHS opcode is not UO_Deref";
}

/**
 * Test 114: Parenthesized dereference ((*ptr))
 * C++ Input: (*ptr)
 * Expected: ParenExpr containing UnaryOperator(UO_Deref)
 */
TEST_F(ExpressionHandlerTest, Dereference_Parenthesized) {
    // Arrange
    std::string code = "int x = 5; int* ptr = &x; void test() { (*ptr); }";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    ExprExtractor extractor;
    extractor.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    clang::Expr* cppExpr = extractor.foundExpr;
    ASSERT_NE(cppExpr, nullptr);

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(cppExpr, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";

    // Outer should be parenthesized expression
    auto* parenExpr = llvm::dyn_cast<clang::ParenExpr>(result);
    ASSERT_NE(parenExpr, nullptr) << "Result is not ParenExpr";

    // Inner should be dereference
    auto* deref = llvm::dyn_cast<clang::UnaryOperator>(parenExpr->getSubExpr());
    ASSERT_NE(deref, nullptr) << "Subexpression is not UnaryOperator";
    EXPECT_EQ(deref->getOpcode(), clang::UO_Deref) << "Opcode is not UO_Deref";
}

// ============================================================================
// PHASE 42: POINTER ARITHMETIC (Tests 107-118) - Task 5
// ============================================================================

/**
 * Test 107: Pointer plus integer
 * C++ Input: ptr + 5
 * Expected: BinaryOperator with BO_Add opcode, pointer type
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PointerPlusInt) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr;
            int* result = ptr + 5;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr + 5" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::BinaryOperator* foundBinOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (BO->getOpcode() == clang::BO_Add &&
                BO->getLHS()->getType()->isPointerType()) {
                foundBinOp = BO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundBinOp, nullptr) << "Could not find ptr + 5 expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundBinOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add) << "Opcode should be BO_Add";
}

/**
 * Test 108: Pointer minus integer
 * C++ Input: ptr - 3
 * Expected: BinaryOperator with BO_Sub opcode, pointer type
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PointerMinusInt) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr + 7;
            int* result = ptr - 3;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr - 3" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::BinaryOperator* foundBinOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (BO->getOpcode() == clang::BO_Sub &&
                BO->getLHS()->getType()->isPointerType() &&
                !BO->getRHS()->getType()->isPointerType()) {
                foundBinOp = BO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundBinOp, nullptr) << "Could not find ptr - 3 expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundBinOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Sub) << "Opcode should be BO_Sub";
}

/**
 * Test 109: Integer plus pointer (commutative)
 * C++ Input: 5 + ptr
 * Expected: BinaryOperator with BO_Add opcode, pointer type
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_IntPlusPointer) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr;
            int* result = 5 + ptr;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "5 + ptr" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::BinaryOperator* foundBinOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (BO->getOpcode() == clang::BO_Add &&
                BO->getRHS()->getType()->isPointerType()) {
                foundBinOp = BO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundBinOp, nullptr) << "Could not find 5 + ptr expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundBinOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Add) << "Opcode should be BO_Add";
}

/**
 * Test 110: Pointer minus pointer (ptrdiff_t)
 * C++ Input: ptr2 - ptr1
 * Expected: BinaryOperator with BO_Sub opcode, ptrdiff_t type
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PointerMinusPointer) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr1 = arr;
            int* ptr2 = arr + 5;
            long diff = ptr2 - ptr1;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr2 - ptr1" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::BinaryOperator* foundBinOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (BO->getOpcode() == clang::BO_Sub &&
                BO->getLHS()->getType()->isPointerType() &&
                BO->getRHS()->getType()->isPointerType()) {
                foundBinOp = BO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundBinOp, nullptr) << "Could not find ptr2 - ptr1 expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundBinOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_Sub) << "Opcode should be BO_Sub";
}

/**
 * Test 111: Pointer postfix increment
 * C++ Input: ptr++
 * Expected: UnaryOperator with UO_PostInc opcode
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PostfixIncrement) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr;
            ptr++;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr++" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::UnaryOperator* foundUnaryOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (UO->getOpcode() == clang::UO_PostInc &&
                UO->getSubExpr()->getType()->isPointerType()) {
                foundUnaryOp = UO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundUnaryOp, nullptr) << "Could not find ptr++ expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundUnaryOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unaryOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unaryOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unaryOp->getOpcode(), clang::UO_PostInc) << "Opcode should be UO_PostInc";
}

/**
 * Test 112: Pointer prefix increment
 * C++ Input: ++ptr
 * Expected: UnaryOperator with UO_PreInc opcode
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PrefixIncrement) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr;
            ++ptr;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "++ptr" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::UnaryOperator* foundUnaryOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (UO->getOpcode() == clang::UO_PreInc &&
                UO->getSubExpr()->getType()->isPointerType()) {
                foundUnaryOp = UO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundUnaryOp, nullptr) << "Could not find ++ptr expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundUnaryOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unaryOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unaryOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unaryOp->getOpcode(), clang::UO_PreInc) << "Opcode should be UO_PreInc";
}

/**
 * Test 113: Pointer postfix decrement
 * C++ Input: ptr--
 * Expected: UnaryOperator with UO_PostDec opcode
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PostfixDecrement) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr + 9;
            ptr--;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr--" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::UnaryOperator* foundUnaryOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (UO->getOpcode() == clang::UO_PostDec &&
                UO->getSubExpr()->getType()->isPointerType()) {
                foundUnaryOp = UO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundUnaryOp, nullptr) << "Could not find ptr-- expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundUnaryOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unaryOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unaryOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unaryOp->getOpcode(), clang::UO_PostDec) << "Opcode should be UO_PostDec";
}

/**
 * Test 114: Pointer prefix decrement
 * C++ Input: --ptr
 * Expected: UnaryOperator with UO_PreDec opcode
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PrefixDecrement) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr + 9;
            --ptr;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "--ptr" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::UnaryOperator* foundUnaryOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (UO->getOpcode() == clang::UO_PreDec &&
                UO->getSubExpr()->getType()->isPointerType()) {
                foundUnaryOp = UO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundUnaryOp, nullptr) << "Could not find --ptr expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundUnaryOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unaryOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unaryOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unaryOp->getOpcode(), clang::UO_PreDec) << "Opcode should be UO_PreDec";
}

/**
 * Test 115: Pointer compound assignment (+=)
 * C++ Input: ptr += 2
 * Expected: BinaryOperator with BO_AddAssign opcode
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_CompoundAddAssign) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr;
            ptr += 2;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr += 2" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::BinaryOperator* foundBinOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (BO->getOpcode() == clang::BO_AddAssign &&
                BO->getLHS()->getType()->isPointerType()) {
                foundBinOp = BO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundBinOp, nullptr) << "Could not find ptr += 2 expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundBinOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_AddAssign) << "Opcode should be BO_AddAssign";
}

/**
 * Test 116: Pointer compound assignment (-=)
 * C++ Input: ptr -= 1
 * Expected: BinaryOperator with BO_SubAssign opcode
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_CompoundSubAssign) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr + 5;
            ptr -= 1;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr -= 1" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::BinaryOperator* foundBinOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (BO->getOpcode() == clang::BO_SubAssign &&
                BO->getLHS()->getType()->isPointerType()) {
                foundBinOp = BO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundBinOp, nullptr) << "Could not find ptr -= 1 expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundBinOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_SubAssign) << "Opcode should be BO_SubAssign";
}

/**
 * Test 117: Pointer array access via arithmetic
 * C++ Input: *(ptr + i)
 * Expected: UnaryOperator (dereference) of BinaryOperator (pointer + int)
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_ArrayAccessViaArithmetic) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr = arr;
            int i = 3;
            int value = *(ptr + i);
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "*(ptr + i)" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::UnaryOperator* foundUnaryOp = nullptr;

        bool VisitUnaryOperator(clang::UnaryOperator* UO) {
            if (UO->getOpcode() == clang::UO_Deref) {
                if (auto* BO = llvm::dyn_cast<clang::BinaryOperator>(UO->getSubExpr()->IgnoreParenImpCasts())) {
                    if (BO->getOpcode() == clang::BO_Add &&
                        BO->getLHS()->getType()->isPointerType()) {
                        foundUnaryOp = UO;
                    }
                }
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundUnaryOp, nullptr) << "Could not find *(ptr + i) expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundUnaryOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* unaryOp = llvm::dyn_cast<clang::UnaryOperator>(result);
    ASSERT_NE(unaryOp, nullptr) << "Result is not UnaryOperator";
    EXPECT_EQ(unaryOp->getOpcode(), clang::UO_Deref) << "Opcode should be UO_Deref";
}

/**
 * Test 118: Pointer comparison (less than)
 * C++ Input: ptr1 < ptr2
 * Expected: BinaryOperator with BO_LT opcode
 */
TEST_F(ExpressionHandlerTest, PointerArithmetic_PointerComparison) {
    // Arrange
    std::string code = R"(
        void test() {
            int arr[10];
            int* ptr1 = arr;
            int* ptr2 = arr + 5;
            int result = ptr1 < ptr2;
        }
    )";
    auto AST = clang::tooling::buildASTFromCode(code);
    ASSERT_NE(AST, nullptr);

    // Find the "ptr1 < ptr2" expression
    class PtrArithFinder : public clang::RecursiveASTVisitor<PtrArithFinder> {
    public:
        clang::BinaryOperator* foundBinOp = nullptr;

        bool VisitBinaryOperator(clang::BinaryOperator* BO) {
            if (BO->getOpcode() == clang::BO_LT &&
                BO->getLHS()->getType()->isPointerType() &&
                BO->getRHS()->getType()->isPointerType()) {
                foundBinOp = BO;
            }
            return true;
        }
    };

    PtrArithFinder finder;
    finder.TraverseDecl(AST->getASTContext().getTranslationUnitDecl());
    ASSERT_NE(finder.foundBinOp, nullptr) << "Could not find ptr1 < ptr2 expression";

    // Act
    ExpressionHandler handler;
    clang::Expr* result = handler.handleExpr(finder.foundBinOp, *context);

    // Assert
    ASSERT_NE(result, nullptr) << "Translation returned null";
    auto* binOp = llvm::dyn_cast<clang::BinaryOperator>(result);
    ASSERT_NE(binOp, nullptr) << "Result is not BinaryOperator";
    EXPECT_EQ(binOp->getOpcode(), clang::BO_LT) << "Opcode should be BO_LT";
}
