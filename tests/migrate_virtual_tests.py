#!/usr/bin/env python3
"""
Automated migration script for virtual function and RTTI tests to GTest format.
Handles the conversion of old-style test macros to Google Test assertions.
"""

import re
import sys
from pathlib import Path

def convert_test_to_gtest(test_code, test_name, fixture_name):
    """Convert a single test function to GTest TEST_F format."""

    # Remove old test function declaration
    test_code = re.sub(r'^void\s+test_\w+\(\)\s*\{', '', test_code, flags=re.MULTILINE)
    test_code = test_code.rstrip()
    if test_code.endswith('}'):
        test_code = test_code[:-1].rstrip()

    # Convert TEST_START macro
    test_code = re.sub(
        r'TEST_START\("([^"]+)"\);',
        r'// Test: \1',
        test_code
    )

    # Convert TEST_PASS macro
    test_code = re.sub(
        r'TEST_PASS\("([^"]+)"\);',
        '',
        test_code
    )

    # Convert ASSERT macros to EXPECT/ASSERT_NE, EXPECT_TRUE, etc.
    # Handle: ASSERT(ptr, "message")
    test_code = re.sub(
        r'ASSERT\(([^,]+),\s*"([^"]+)"\);',
        lambda m: f'ASSERT_NE({m.group(1)}, nullptr) << "{m.group(2)}";',
        test_code
    )

    # Convert buildAST to use AST member variable
    test_code = re.sub(
        r'std::unique_ptr<ASTUnit>\s+AST\s*=\s*buildAST\(',
        'AST = buildAST(',
        test_code
    )

    # Convert Context declaration
    test_code = re.sub(
        r'auto&\s+Context\s*=\s*AST->getASTContext\(\);',
        'auto& Context = AST->getASTContext();',
        test_code
    )

    # Convert assertions with boolean conditions
    # ASSERT(condition, "message") -> EXPECT_TRUE(condition) << "message"
    test_code = re.sub(
        r'ASSERT\(([^,]+),\s*"([^"]+)"\);',
        lambda m: f'EXPECT_TRUE({m.group(1)}) << "{m.group(2)}";',
        test_code
    )

    # Convert size assertions
    test_code = re.sub(
        r'EXPECT_TRUE\(([^)]+)\.size\(\)\s*==\s*(\d+)\)',
        r'EXPECT_EQ(\1.size(), \2u)',
        test_code
    )

    # Convert !empty() assertions
    test_code = re.sub(
        r'EXPECT_TRUE\(!([^)]+)\.empty\(\)\)',
        r'EXPECT_FALSE(\1.empty())',
        test_code
    )

    # Clean up test name for GTest format
    gtest_name = test_name.replace('test_', '')

    return f'TEST_F({fixture_name}, {gtest_name}) {{\n{test_code}\n}}\n'

def migrate_test_file(input_file, output_file, fixture_name, include_files):
    """Migrate an entire test file to GTest format."""

    with open(input_file, 'r') as f:
        content = f.read()

    # Extract all test functions
    test_pattern = r'void\s+(test_\w+)\(\)\s*\{(.*?)\n\}'
    tests = re.findall(test_pattern, content, re.DOTALL)

    # Build output
    output = f'''// tests/gtest/{Path(output_file).name}
// Migrated from {Path(input_file).name}
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class {fixture_name} : public VirtualFunctionTestBase {{
protected:
    void SetUp() override {{
        // Base setup handles AST initialization
    }}
}};

'''

    # Convert each test
    for test_name, test_body in tests:
        gtest_code = convert_test_to_gtest(f'void {test_name}() {{{test_body}\n}}', test_name, fixture_name)
        output += gtest_code + '\n'

    # Write output
    with open(output_file, 'w') as f:
        f.write(output)

    return len(tests)

def main():
    """Main migration function."""
    base_path = Path('/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/tests')
    gtest_path = base_path / 'gtest'

    migrations = [
        {
            'input': base_path / 'RTTIIntegrationTest.cpp',
            'output': gtest_path / 'RTTIIntegrationTest_GTest.cpp',
            'fixture': 'RTTIIntegrationTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
        {
            'input': base_path / 'VirtualMethodAnalyzerTest.cpp',
            'output': gtest_path / 'VirtualMethodAnalyzerTest_GTest.cpp',
            'fixture': 'VirtualMethodAnalyzerTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
        {
            'input': base_path / 'VtableGeneratorTest.cpp',
            'output': gtest_path / 'VtableGeneratorTest_GTest.cpp',
            'fixture': 'VtableGeneratorTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
        {
            'input': base_path / 'VptrInjectorTest.cpp',
            'output': gtest_path / 'VptrInjectorTest_GTest.cpp',
            'fixture': 'VptrInjectorTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
        {
            'input': base_path / 'OverrideResolverTest.cpp',
            'output': gtest_path / 'OverrideResolverTest_GTest.cpp',
            'fixture': 'OverrideResolverTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
        {
            'input': base_path / 'VirtualCallTranslatorTest.cpp',
            'output': gtest_path / 'VirtualCallTranslatorTest_GTest.cpp',
            'fixture': 'VirtualCallTranslatorTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
        {
            'input': base_path / 'PureVirtualHandlerTest.cpp',
            'output': gtest_path / 'PureVirtualHandlerTest_GTest.cpp',
            'fixture': 'PureVirtualHandlerTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
        {
            'input': base_path / 'VirtualDestructorHandlerTest.cpp',
            'output': gtest_path / 'VirtualDestructorHandlerTest_GTest.cpp',
            'fixture': 'VirtualDestructorHandlerTest',
            'includes': ['VirtualFunctionTestFixtures.h']
        },
    ]

    total_tests = 0
    for migration in migrations:
        print(f"Migrating {migration['input'].name}...")
        num_tests = migrate_test_file(
            migration['input'],
            migration['output'],
            migration['fixture'],
            migration['includes']
        )
        total_tests += num_tests
        print(f"  Migrated {num_tests} tests to {migration['output'].name}")

    print(f"\nTotal tests migrated: {total_tests}")
    return 0

if __name__ == '__main__':
    sys.exit(main())
