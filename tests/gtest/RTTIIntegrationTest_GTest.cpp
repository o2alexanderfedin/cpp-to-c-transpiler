// tests/gtest/RTTIIntegrationTest_GTest.cpp
// Migrated from RTTIIntegrationTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class RTTIIntegrationTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(RTTIIntegrationTest, TypidStaticTypeName) {

    // Test: Static typeid on non-polymorphic class

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Animal {
        public:
            virtual ~Animal() {}
        };

        void test_typeid_static() {
            const std::type_info& ti = typeid(Animal);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    TypeidTranslator Translator(Context, Analyzer);

    const CXXTypeidExpr* typeidExpr = findTypeidExpr(Context);
    ASSERT_NE(typeidExpr != nullptr, nullptr) << "typeid expression not found";

    // Verify it's a static typeid
    ASSERT_NE(typeidExpr->isTypeOperand(), nullptr) << "Expected type operand";
    ASSERT_NE(!Translator.isPolymorphicTypeid(typeidExpr), nullptr) << "Expected static typeid";

    // Translate
    std::string translation = Translator.translateTypeid(typeidExpr);
    ASSERT_NE(!translation.empty(), nullptr) << "Translation is empty";
    ASSERT_NE(translation.find("__ti_Animal") != std::string::npos, nullptr) << "Expected __ti_Animal reference";
    ASSERT_NE(translation.find("&") != std::string::npos, nullptr) << "Expected address-of operator";

    
}

TEST_F(RTTIIntegrationTest, TypeidPolymorphicBasic) {

    // Test: Polymorphic typeid on derived object

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Animal {
        public:
            virtual ~Animal() {}
        };

        class Dog : public Animal {
        public:
            void bark() {}
        };

        void identify(Animal* a) {
            const std::type_info& ti = typeid(*a);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    TypeidTranslator Translator(Context, Analyzer);

    const CXXTypeidExpr* typeidExpr = findTypeidExpr(Context);
    ASSERT_NE(typeidExpr != nullptr, nullptr) << "typeid expression not found";

    // Verify it's a polymorphic typeid
    ASSERT_NE(!typeidExpr->isTypeOperand(), nullptr) << "Expected expression operand";
    ASSERT_NE(Translator.isPolymorphicTypeid(typeidExpr), nullptr) << "Expected polymorphic typeid";

    // Translate
    std::string translation = Translator.translateTypeid(typeidExpr);
    ASSERT_NE(!translation.empty(), nullptr) << "Translation is empty";
    ASSERT_NE(translation.find("vptr") != std::string::npos, nullptr) << "Expected vptr reference for polymorphic lookup";

    
}

TEST_F(RTTIIntegrationTest, TypeidNullPointer) {

    // Test: Typeid on null polymorphic pointer

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Base {
        public:
            virtual ~Base() {}
        };

        void test() {
            Base* ptr = nullptr;
            if (ptr) {
                const std::type_info& ti = typeid(*ptr);
            }
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    TypeidTranslator Translator(Context, Analyzer);

    const CXXTypeidExpr* typeidExpr = findTypeidExpr(Context);
    ASSERT_NE(typeidExpr != nullptr, nullptr) << "typeid expression not found";

    // Translate - should generate code (actual null check is runtime behavior)
    std::string translation = Translator.translateTypeid(typeidExpr);
    ASSERT_NE(!translation.empty(), nullptr) << "Translation is empty";

    
}

TEST_F(RTTIIntegrationTest, TypeidEquality) {

    // Test: Typeid equality comparison

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Shape {
        public:
            virtual ~Shape() {}
        };

        class Circle : public Shape {};

        void test() {
            const std::type_info& ti1 = typeid(Circle);
            const std::type_info& ti2 = typeid(Circle);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    TypeidTranslator Translator(Context, Analyzer);

    auto typeids = findAllTypeidExprs(Context);
    ASSERT_NE(typeids.size() >= 2, nullptr) << "Expected at least 2 typeid expressions";

    // Both should be static and reference same type
    std::string trans1 = Translator.translateTypeid(typeids[0]);
    std::string trans2 = Translator.translateTypeid(typeids[1]);

    ASSERT_NE(trans1.find("__ti_Circle") != std::string::npos, nullptr) << "First typeid should reference __ti_Circle";
    ASSERT_NE(trans2.find("__ti_Circle") != std::string::npos, nullptr) << "Second typeid should reference __ti_Circle";

    
}

TEST_F(RTTIIntegrationTest, TypeidNameFunction) {

    // Test: Typeid name() method translation

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Widget {
        public:
            virtual ~Widget() {}
        };

        void test() {
            const std::type_info& ti = typeid(Widget);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    TypeidTranslator Translator(Context, Analyzer);

    const CXXTypeidExpr* typeidExpr = findTypeidExpr(Context);
    ASSERT_NE(typeidExpr != nullptr, nullptr) << "typeid expression not found";

    std::string translation = Translator.translateTypeid(typeidExpr);
    ASSERT_NE(translation.find("__ti_Widget") != std::string::npos, nullptr) << "Expected __ti_Widget reference";

    
}

TEST_F(RTTIIntegrationTest, TypeidInheritanceChain) {

    // Test: Typeid in inheritance chain

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Grandparent {
        public:
            virtual ~Grandparent() {}
        };

        class Parent : public Grandparent {};
        class Child : public Parent {};

        void test(Grandparent* gp, Parent* p, Child* c) {
            const std::type_info& ti1 = typeid(*gp);
            const std::type_info& ti2 = typeid(*p);
            const std::type_info& ti3 = typeid(*c);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    TypeidTranslator Translator(Context, Analyzer);

    auto typeids = findAllTypeidExprs(Context);
    ASSERT_NE(typeids.size() >= 3, nullptr) << "Expected at least 3 typeid expressions";

    // All should be polymorphic (expression operands)
    for (const auto* expr : typeids) {
        ASSERT_NE(Translator.isPolymorphicTypeid(expr), nullptr) << "Expected polymorphic typeid";
        std::string trans = Translator.translateTypeid(expr);
        ASSERT_NE(trans.find("vptr") != std::string::npos, nullptr) << "Expected vptr for polymorphic lookup";
    }

    
}

TEST_F(RTTIIntegrationTest, DynamicCastDowncast) {

    // Test: Successful downcast to derived class

    const char* code = R"(
        class Shape {
        public:
            virtual ~Shape() {}
            virtual void draw() = 0;
        };

        class Circle : public Shape {
        public:
            void draw() override {}
            void bounce() {}
        };

        void process_shape(Shape* s) {
            Circle* c = dynamic_cast<Circle*>(s);
            if (c != nullptr) {
                c->bounce();
            }
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator Translator(Context, Analyzer);

    const CXXDynamicCastExpr* castExpr = findDynamicCastExpr(Context);
    ASSERT_NE(castExpr != nullptr, nullptr) << "dynamic_cast expression not found";

    // Translate
    std::string translation = Translator.translateDynamicCast(castExpr);
    ASSERT_NE(!translation.empty(), nullptr) << "Translation is empty";
    ASSERT_NE(translation.find("cxx_dynamic_cast") != std::string::npos, nullptr) << "Expected cxx_dynamic_cast call";
    ASSERT_NE(translation.find("__ti_Shape") != std::string::npos, nullptr) << "Expected source type __ti_Shape";
    ASSERT_NE(translation.find("__ti_Circle") != std::string::npos, nullptr) << "Expected target type __ti_Circle";

    
}

TEST_F(RTTIIntegrationTest, DynamicCastUpcast) {

    // Test: Upcast to base class

    const char* code = R"(
        class Vehicle {
        public:
            virtual ~Vehicle() {}
        };

        class Car : public Vehicle {
        public:
            void drive() {}
        };

        void test() {
            Car* car = new Car();
            Vehicle* v = dynamic_cast<Vehicle*>(car);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator Translator(Context, Analyzer);

    const CXXDynamicCastExpr* castExpr = findDynamicCastExpr(Context);
    ASSERT_NE(castExpr != nullptr, nullptr) << "dynamic_cast expression not found";

    // Translate (upcast still generates dynamic_cast for uniformity)
    std::string translation = Translator.translateDynamicCast(castExpr);
    ASSERT_NE(!translation.empty(), nullptr) << "Translation is empty";

    
}

TEST_F(RTTIIntegrationTest, DynamicCastWrongType) {

    // Test: Cast to unrelated type

    const char* code = R"(
        class Vehicle {
        public:
            virtual ~Vehicle() {}
        };

        class Car : public Vehicle {};
        class Boat : public Vehicle {};

        void test() {
            Vehicle* v = new Car();
            Boat* b = dynamic_cast<Boat*>(v);
            if (b == nullptr) {
                // Not a boat
            }
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator Translator(Context, Analyzer);

    const CXXDynamicCastExpr* castExpr = findDynamicCastExpr(Context);
    ASSERT_NE(castExpr != nullptr, nullptr) << "dynamic_cast expression not found";

    // Translate
    std::string translation = Translator.translateDynamicCast(castExpr);
    ASSERT_NE(translation.find("cxx_dynamic_cast") != std::string::npos, nullptr) << "Expected runtime cast function";
    ASSERT_NE(translation.find("__ti_Boat") != std::string::npos, nullptr) << "Expected target type __ti_Boat";

    
}

TEST_F(RTTIIntegrationTest, DynamicCastCrossHierarchy) {

    // Test: Cross-cast between unrelated hierarchies

    const char* code = R"(
        class A { public: virtual ~A() {} };
        class B { public: virtual ~B() {} };

        void test() {
            A* a = new A();
            B* b = dynamic_cast<B*>(a);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator Translator(Context, Analyzer);

    const CXXDynamicCastExpr* castExpr = findDynamicCastExpr(Context);
    ASSERT_NE(castExpr != nullptr, nullptr) << "dynamic_cast expression not found";

    // Translate
    std::string translation = Translator.translateDynamicCast(castExpr);
    ASSERT_NE(translation.find("cxx_dynamic_cast") != std::string::npos, nullptr) << "Expected runtime cast";
    ASSERT_NE(translation.find("__ti_A") != std::string::npos, nullptr) << "Expected source type";
    ASSERT_NE(translation.find("__ti_B") != std::string::npos, nullptr) << "Expected target type";

    
}

TEST_F(RTTIIntegrationTest, DynamicCastNullPtr) {

    // Test: dynamic_cast on NULL pointer

    const char* code = R"(
        class Base { public: virtual ~Base() {} };
        class Derived : public Base {};

        void test() {
            Base* b = nullptr;
            Derived* d = dynamic_cast<Derived*>(b);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator Translator(Context, Analyzer);

    const CXXDynamicCastExpr* castExpr = findDynamicCastExpr(Context);
    ASSERT_NE(castExpr != nullptr, nullptr) << "dynamic_cast expression not found";

    // Translate (runtime will handle null check)
    std::string translation = Translator.translateDynamicCast(castExpr);
    ASSERT_NE(!translation.empty(), nullptr) << "Translation is empty";

    
}

TEST_F(RTTIIntegrationTest, DynamicCastSameType) {

    // Test: dynamic_cast to same type

    const char* code = R"(
        class MyClass { public: virtual ~MyClass() {} };

        void test() {
            MyClass* obj = new MyClass();
            MyClass* same = dynamic_cast<MyClass*>(obj);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator Translator(Context, Analyzer);

    const CXXDynamicCastExpr* castExpr = findDynamicCastExpr(Context);
    ASSERT_NE(castExpr != nullptr, nullptr) << "dynamic_cast expression not found";

    // Translate
    std::string translation = Translator.translateDynamicCast(castExpr);
    ASSERT_NE(!translation.empty(), nullptr) << "Translation is empty";

    
}

TEST_F(RTTIIntegrationTest, MultipleInheritanceRTTI) {

    // Test: RTTI with multiple inheritance

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class A { public: virtual ~A() {} };
        class B { public: virtual ~B() {} };
        class D : public A, public B { public: void foo() {} };

        void test_mi_cast() {
            A* a = new D();
            D* d = dynamic_cast<D*>(a);
            const std::type_info& ti = typeid(*a);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator DCTranslator(Context, Analyzer);
    TypeidTranslator TITranslator(Context, Analyzer);

    const CXXDynamicCastExpr* castExpr = findDynamicCastExpr(Context);
    ASSERT_NE(castExpr != nullptr, nullptr) << "dynamic_cast expression not found";

    const CXXTypeidExpr* typeidExpr = findTypeidExpr(Context);
    ASSERT_NE(typeidExpr != nullptr, nullptr) << "typeid expression not found";

    // Test both translations
    std::string castTrans = DCTranslator.translateDynamicCast(castExpr);
    std::string typeidTrans = TITranslator.translateTypeid(typeidExpr);

    ASSERT_NE(castTrans.find("cxx_dynamic_cast") != std::string::npos, nullptr) << "Expected dynamic_cast";
    ASSERT_NE(typeidTrans.find("vptr") != std::string::npos, nullptr) << "Expected polymorphic typeid";

    
}

TEST_F(RTTIIntegrationTest, VirtualMethodsWithRTTI) {

    // Test: Virtual methods with RTTI

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Animal {
        public:
            virtual ~Animal() {}
            virtual void speak() = 0;
        };

        class Cat : public Animal {
        public:
            void speak() override {}
        };

        void identify_animal(Animal* a) {
            const std::type_info& ti = typeid(*a);
            Cat* c = dynamic_cast<Cat*>(a);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);

    // Verify polymorphism detected
    class ClassFinder : public RecursiveASTVisitor<ClassFinder> {
    public:
        CXXRecordDecl* AnimalClass = nullptr;
        bool VisitCXXRecordDecl(CXXRecordDecl* D) {
            if (D->getNameAsString() == "Animal" && D->isCompleteDefinition()) {
                AnimalClass = D;
            }
            return true;
        }
    };
    ClassFinder Finder;
    Finder.TraverseDecl(Context.getTranslationUnitDecl());
    ASSERT_NE(Finder.AnimalClass != nullptr, nullptr) << "Animal class not found";
    ASSERT_NE(Analyzer.isPolymorphic(Finder.AnimalClass), nullptr) << "Animal should be polymorphic";

    
}

TEST_F(RTTIIntegrationTest, PolymorphicContainers) {

    // Test: Polymorphic containers

    const char* code = R"(
        namespace std { class type_info { public: const char* name() const; }; }

        class Shape {
        public:
            virtual ~Shape() {}
            virtual void draw() = 0;
        };

        class Circle : public Shape {
        public:
            void draw() override {}
        };

        class Square : public Shape {
        public:
            void draw() override {}
        };

        void process(Shape* s) {
            const std::type_info& ti = typeid(*s);
            Circle* c = dynamic_cast<Circle*>(s);
            Square* sq = dynamic_cast<Square*>(s);
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST != nullptr, nullptr) << "Failed to parse C++ code";

    ASTContext& Context = AST->getASTContext();
    VirtualMethodAnalyzer Analyzer(Context);
    DynamicCastTranslator DCTranslator(Context, Analyzer);
    TypeidTranslator TITranslator(Context, Analyzer);

    auto casts = findAllDynamicCastExprs(Context);
    ASSERT_NE(casts.size() >= 2, nullptr) << "Expected at least 2 dynamic_cast expressions";

    const CXXTypeidExpr* typeidExpr = findTypeidExpr(Context);
    ASSERT_NE(typeidExpr != nullptr, nullptr) << "typeid expression not found";

    // Verify all translations work
    for (const auto* cast : casts) {
        std::string trans = DCTranslator.translateDynamicCast(cast);
        ASSERT_NE(!trans.empty(), nullptr) << "dynamic_cast translation failed";
    }

    std::string typeidTrans = TITranslator.translateTypeid(typeidExpr);
    ASSERT_NE(!typeidTrans.empty(), nullptr) << "typeid translation failed";

    
}

