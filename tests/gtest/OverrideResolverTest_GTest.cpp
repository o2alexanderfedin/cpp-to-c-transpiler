// tests/gtest/OverrideResolverTest_GTest.cpp
// Migrated from OverrideResolverTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class OverrideResolverTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(OverrideResolverTest, SingleMethodOverride) {

    // Test: SingleMethodOverride

    const char *code = R"(
        class Base {
        public:
            virtual void foo();
        };

        class Derived : public Base {
        public:
            void foo() override;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    // Resolve overrides for Derived
    auto vtableMethods = resolver.resolveVtableLayout(Derived);

    // Test: Should have 1 method (foo from Derived, not Base)
    // Destructor is implicit, so might be 1 or 2 depending on implementation
    ASSERT_NE(vtableMethods.size() >= 1, nullptr) << "Expected at least 1 method";

    // Find foo in vtable
    CXXMethodDecl* fooMethod = nullptr;
    for (auto* method : vtableMethods) {
        if (!isa<CXXDestructorDecl>(method) && method->getNameAsString() == "foo") {
            fooMethod = method;
            break;
        }
    }

    ASSERT_NE(fooMethod, nullptr) << "foo method not found in vtable";

    // Test: foo should be from Derived, not Base
    ASSERT_NE(fooMethod->getParent()->getNameAsString() == "Derived", nullptr) << "foo should be from Derived class (override)";

    
}

TEST_F(OverrideResolverTest, InheritedMethod) {

    // Test: InheritedMethod

    const char *code = R"(
        class Base {
        public:
            virtual void foo();
            virtual void bar();
        };

        class Derived : public Base {
        public:
            void foo() override;
            // bar is NOT overridden
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    auto vtableMethods = resolver.resolveVtableLayout(Derived);

    // Find foo and bar
    CXXMethodDecl* fooMethod = nullptr;
    CXXMethodDecl* barMethod = nullptr;

    for (auto* method : vtableMethods) {
        if (isa<CXXDestructorDecl>(method)) continue;

        if (method->getNameAsString() == "foo") {
            fooMethod = method;
        } else if (method->getNameAsString() == "bar") {
            barMethod = method;
        }
    }

    ASSERT_NE(fooMethod, nullptr) << "foo not found in vtable";
    ASSERT_NE(barMethod, nullptr) << "bar not found in vtable";

    // Test: foo should be overridden (from Derived)
    ASSERT_NE(fooMethod->getParent()->getNameAsString() == "Derived", nullptr) << "foo should be from Derived (overridden)";

    // Test: bar should be inherited (from Base)
    ASSERT_NE(barMethod->getParent()->getNameAsString() == "Base", nullptr) << "bar should be from Base (inherited)";

    
}

TEST_F(OverrideResolverTest, MultiLevelInheritance) {

    // Test: MultiLevelInheritance

    const char *code = R"(
        class Base {
        public:
            virtual void foo();
        };

        class Middle : public Base {
        public:
            void foo() override;
            virtual void bar();
        };

        class Derived : public Middle {
        public:
            void bar() override;
            // foo inherited from Middle
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    auto vtableMethods = resolver.resolveVtableLayout(Derived);

    // Find foo and bar
    CXXMethodDecl* fooMethod = nullptr;
    CXXMethodDecl* barMethod = nullptr;

    for (auto* method : vtableMethods) {
        if (isa<CXXDestructorDecl>(method)) continue;

        if (method->getNameAsString() == "foo") {
            fooMethod = method;
        } else if (method->getNameAsString() == "bar") {
            barMethod = method;
        }
    }

    ASSERT_NE(fooMethod, nullptr) << "foo not found in vtable";
    ASSERT_NE(barMethod, nullptr) << "bar not found in vtable";

    // Test: foo should be from Middle (overrode Base, inherited by Derived)
    ASSERT_NE(fooMethod->getParent()->getNameAsString() == "Middle", nullptr) << "foo should be from Middle";

    // Test: bar should be from Derived (overrode Middle)
    ASSERT_NE(barMethod->getParent()->getNameAsString() == "Derived", nullptr) << "bar should be from Derived";

    
}

TEST_F(OverrideResolverTest, VtableSlotConsistency) {

    // Test: VtableSlotConsistency

    const char *code = R"(
        class Base {
        public:
            virtual void first();
            virtual void second();
            virtual void third();
        };

        class Derived : public Base {
        public:
            void second() override;  // Override middle method
            // first and third inherited
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Base = findClass(TU, "Base");
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Base, nullptr) << "Base class not found";
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    auto baseMethods = resolver.resolveVtableLayout(Base);
    auto derivedMethods = resolver.resolveVtableLayout(Derived);

    // Test: Both should have same number of methods (slots)
    ASSERT_NE(baseMethods.size() == derivedMethods.size(), nullptr) << "Base and Derived should have same vtable size";

    // Test: Method order should be preserved (first, second, third)
    // Skip destructor (first if present)
    size_t baseStart = 0;
    size_t derivedStart = 0;

    if (!baseMethods.empty() && isa<CXXDestructorDecl>(baseMethods[0])) {
        baseStart = 1;
    }
    if (!derivedMethods.empty() && isa<CXXDestructorDecl>(derivedMethods[0])) {
        derivedStart = 1;
    }

    // Check method names are in same order
    for (size_t i = 0; i < baseMethods.size() - baseStart; ++i) {
        auto* baseMethod = baseMethods[baseStart + i];
        auto* derivedMethod = derivedMethods[derivedStart + i];

        ASSERT(baseMethod->getNameAsString() == derivedMethod->getNameAsString(),
               "Method order must be consistent: " +
               baseMethod->getNameAsString() + " vs " +
               derivedMethod->getNameAsString());
    }

    
}

TEST_F(OverrideResolverTest, MultipleOverrides) {

    // Test: MultipleOverrides

    const char *code = R"(
        class Base {
        public:
            virtual void a();
            virtual void b();
            virtual void c();
        };

        class Derived : public Base {
        public:
            void a() override;
            void b() override;
            void c() override;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    auto vtableMethods = resolver.resolveVtableLayout(Derived);

    // Count methods from Derived
    int derivedMethodCount = 0;
    for (auto* method : vtableMethods) {
        if (!isa<CXXDestructorDecl>(method) &&
            method->getParent()->getNameAsString() == "Derived") {
            derivedMethodCount++;
        }
    }

    // Test: All 3 methods should be from Derived (all overridden)
    ASSERT(derivedMethodCount == 3,
           "Expected 3 methods from Derived, got: " + std::to_string(derivedMethodCount));

    
}

TEST_F(OverrideResolverTest, PartialOverride) {

    // Test: PartialOverride

    const char *code = R"(
        class Base {
        public:
            virtual void a();
            virtual void b();
            virtual void c();
        };

        class Derived : public Base {
        public:
            void b() override;  // Only override b
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    auto vtableMethods = resolver.resolveVtableLayout(Derived);

    // Count methods from each class
    int baseCount = 0;
    int derivedCount = 0;

    for (auto* method : vtableMethods) {
        if (isa<CXXDestructorDecl>(method)) continue;

        if (method->getParent()->getNameAsString() == "Base") {
            baseCount++;
        } else if (method->getParent()->getNameAsString() == "Derived") {
            derivedCount++;
        }
    }

    // Test: 1 from Derived (b), 2 from Base (a, c)
    ASSERT_NE(derivedCount == 1, nullptr) << "Expected 1 method from Derived";
    ASSERT_NE(baseCount == 2, nullptr) << "Expected 2 methods from Base";

    
}

TEST_F(OverrideResolverTest, CovariantReturnTypes) {

    // Test: CovariantReturnTypes

    const char *code = R"(
        class Base {
        public:
            virtual Base* clone();
        };

        class Derived : public Base {
        public:
            Derived* clone() override;  // Covariant return type
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    auto vtableMethods = resolver.resolveVtableLayout(Derived);

    // Find clone method
    CXXMethodDecl* cloneMethod = nullptr;
    for (auto* method : vtableMethods) {
        if (!isa<CXXDestructorDecl>(method) &&
            method->getNameAsString() == "clone") {
            cloneMethod = method;
            break;
        }
    }

    ASSERT_NE(cloneMethod, nullptr) << "clone method not found";

    // Test: clone should be from Derived (covariant override)
    ASSERT_NE(cloneMethod->getParent()->getNameAsString() == "Derived", nullptr) << "clone should be from Derived (covariant override)";

    
}

TEST_F(OverrideResolverTest, MethodWithParameters) {

    // Test: MethodWithParameters

    const char *code = R"(
        class Base {
        public:
            virtual void process(int x, double y);
        };

        class Derived : public Base {
        public:
            void process(int x, double y) override;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    OverrideResolver resolver(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    auto vtableMethods = resolver.resolveVtableLayout(Derived);

    // Find process method
    CXXMethodDecl* processMethod = nullptr;
    for (auto* method : vtableMethods) {
        if (!isa<CXXDestructorDecl>(method) &&
            method->getNameAsString() == "process") {
            processMethod = method;
            break;
        }
    }

    ASSERT_NE(processMethod, nullptr) << "process method not found";

    // Test: process should be from Derived
    ASSERT_NE(processMethod->getParent()->getNameAsString() == "Derived", nullptr) << "process should be from Derived";

    // Test: Should have correct parameter count
    ASSERT_NE(processMethod->getNumParams() == 2, nullptr) << "process should have 2 parameters";

    
}

