// tests/gtest/VptrInjectorTest_GTest.cpp
// Migrated from VptrInjectorTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class VptrInjectorTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(VptrInjectorTest, InjectVptrInPolymorphicClass) {

    // Test: InjectVptrInPolymorphicClass

    const char *code = R"(
        class Shape {
        public:
            virtual void draw();
        private:
            double x;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    CNodeBuilder Builder(Context);
    VirtualMethodAnalyzer analyzer(Context);
    VptrInjector injector(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Shape = findClass(TU, "Shape");
    ASSERT_NE(Shape, nullptr) << "Shape class not found";

    // Test: Class should be polymorphic
    ASSERT_NE(analyzer.isPolymorphic(Shape), nullptr) << "Shape should be polymorphic";

    // Inject vptr field
    std::vector<FieldDecl*> fields;
    bool injected = injector.injectVptrField(Shape, fields);
    ASSERT_NE(injected, nullptr) << "Vptr injection should succeed";

    // Test: Should have exactly 1 field (vptr)
    ASSERT(fields.size() == 1,
           "Expected 1 field (vptr), got: " + std::to_string(fields.size()));

    // Test: First field should be vptr
    ASSERT_NE(fields[0]->getNameAsString() == "vptr", nullptr) << "First field should be named 'vptr'";

    // Test: Vptr should be pointer type
    ASSERT_NE(fields[0]->getType()->isPointerType(), nullptr) << "Vptr should be pointer type";

    // Test: Vptr pointee should be const-qualified (const struct X_vtable*)
    auto pointeeType = fields[0]->getType()->getPointeeType();
    ASSERT_NE(pointeeType.isConstQualified(), nullptr) << "Vptr pointee (vtable struct) should be const-qualified";

    
}

TEST_F(VptrInjectorTest, NoVptrInNonPolymorphicClass) {

    // Test: NoVptrInNonPolymorphicClass

    const char *code = R"(
        class Point {
        private:
            double x, y;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    CNodeBuilder Builder(Context);
    VirtualMethodAnalyzer analyzer(Context);
    VptrInjector injector(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Point = findClass(TU, "Point");
    ASSERT_NE(Point, nullptr) << "Point class not found";

    // Test: Class should NOT be polymorphic
    ASSERT_NE(!analyzer.isPolymorphic(Point), nullptr) << "Point should not be polymorphic";

    // Try to inject vptr field
    std::vector<FieldDecl*> fields;
    bool injected = injector.injectVptrField(Point, fields);

    // Test: Injection should not happen for non-polymorphic class
    ASSERT_NE(!injected, nullptr) << "Vptr should not be injected in non-polymorphic class";
    ASSERT_NE(fields.empty(), nullptr) << "Fields should be empty for non-polymorphic class";

    
}

TEST_F(VptrInjectorTest, VptrAtOffsetZeroInDerivedClass) {

    // Test: VptrAtOffsetZeroInDerivedClass

    const char *code = R"(
        class Base {
        public:
            virtual void foo();
        };

        class Derived : public Base {
        private:
            int value;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    CNodeBuilder Builder(Context);
    VirtualMethodAnalyzer analyzer(Context);
    VptrInjector injector(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    // Test: Derived class should be polymorphic (inherited virtual)
    ASSERT_NE(analyzer.isPolymorphic(Derived), nullptr) << "Derived should be polymorphic";

    // Inject vptr field
    std::vector<FieldDecl*> fields;
    bool injected = injector.injectVptrField(Derived, fields);
    ASSERT_NE(injected, nullptr) << "Vptr injection should succeed in Derived";

    // Test: Vptr should be first field (offset 0)
    ASSERT_NE(fields.size() >= 1, nullptr) << "Should have at least vptr field";
    ASSERT_NE(fields[0]->getNameAsString() == "vptr", nullptr) << "First field must be vptr for proper memory layout";

    
}

TEST_F(VptrInjectorTest, VptrTypeReferencesVtableStruct) {

    // Test: VptrTypeReferencesVtableStruct

    const char *code = R"(
        class Shape {
        public:
            virtual void draw();
            virtual double area();
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    CNodeBuilder Builder(Context);
    VirtualMethodAnalyzer analyzer(Context);
    VptrInjector injector(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Shape = findClass(TU, "Shape");
    ASSERT_NE(Shape, nullptr) << "Shape class not found";

    // Inject vptr field
    std::vector<FieldDecl*> fields;
    bool injected = injector.injectVptrField(Shape, fields);
    ASSERT_NE(injected, nullptr) << "Vptr injection should succeed";

    // Test: Vptr type should reference Shape_vtable
    auto vptrType = fields[0]->getType();
    ASSERT_NE(vptrType->isPointerType(), nullptr) << "Vptr must be pointer type";

    auto pointeeType = vptrType->getPointeeType();
    std::string typeName = pointeeType.getAsString();

    // Should be "const struct Shape_vtable"
    ASSERT(typeName.find("Shape_vtable") != std::string::npos,
           "Vptr should point to Shape_vtable, got: " + typeName);

    
}

TEST_F(VptrInjectorTest, MultiplePolymorphicClassesGetOwnVptr) {

    // Test: MultiplePolymorphicClassesGetOwnVptr

    const char *code = R"(
        class Shape {
        public:
            virtual void draw();
        };

        class Animal {
        public:
            virtual void speak();
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    CNodeBuilder Builder(Context);
    VirtualMethodAnalyzer analyzer(Context);
    VptrInjector injector(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Shape = findClass(TU, "Shape");
    auto *Animal = findClass(TU, "Animal");
    ASSERT_NE(Shape, nullptr) << "Shape class not found";
    ASSERT_NE(Animal, nullptr) << "Animal class not found";

    // Inject vptr in Shape
    std::vector<FieldDecl*> shapeFields;
    bool shapeInjected = injector.injectVptrField(Shape, shapeFields);
    ASSERT_NE(shapeInjected, nullptr) << "Vptr injection should succeed in Shape";

    // Inject vptr in Animal
    std::vector<FieldDecl*> animalFields;
    bool animalInjected = injector.injectVptrField(Animal, animalFields);
    ASSERT_NE(animalInjected, nullptr) << "Vptr injection should succeed in Animal";

    // Test: Both should have vptr
    ASSERT_NE(shapeFields.size() >= 1, nullptr) << "Shape should have vptr";
    ASSERT_NE(animalFields.size() >= 1, nullptr) << "Animal should have vptr";

    // Test: Vptrs should point to different vtable types
    auto shapeVptrType = shapeFields[0]->getType()->getPointeeType().getAsString();
    auto animalVptrType = animalFields[0]->getType()->getPointeeType().getAsString();

    ASSERT_NE(shapeVptrType.find("Shape_vtable") != std::string::npos, nullptr) << "Shape vptr should reference Shape_vtable";
    ASSERT_NE(animalVptrType.find("Animal_vtable") != std::string::npos, nullptr) << "Animal vptr should reference Animal_vtable";

    
}

TEST_F(VptrInjectorTest, VptrCombinedWithExistingFields) {

    // Test: VptrCombinedWithExistingFields

    const char *code = R"(
        class Circle {
        public:
            virtual void draw();
        private:
            double radius;
            int color;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    CNodeBuilder Builder(Context);
    VirtualMethodAnalyzer analyzer(Context);
    VptrInjector injector(Context, analyzer);

    auto *TU = Context.getTranslationUnitDecl();
    auto *Circle = findClass(TU, "Circle");
    ASSERT_NE(Circle, nullptr) << "Circle class not found";

    // Inject vptr and existing fields
    std::vector<FieldDecl*> fields;
    injector.injectVptrField(Circle, fields);

    // Add existing fields
    for (auto *Field : Circle->fields()) {
        FieldDecl *CField = Builder.fieldDecl(Field->getType(), Field->getName());
        fields.push_back(CField);
    }

    // Test: Should have 3 fields: vptr, radius, color
    ASSERT(fields.size() == 3,
           "Expected 3 fields (vptr + radius + color), got: " + std::to_string(fields.size()));

    // Test: Vptr must be first
    ASSERT_NE(fields[0]->getNameAsString() == "vptr", nullptr) << "Vptr must be first field (offset 0)";

    // Test: Original fields after vptr
    ASSERT_NE(fields[1]->getNameAsString() == "radius", nullptr) << "Second field should be radius";
    ASSERT_NE(fields[2]->getNameAsString() == "color", nullptr) << "Third field should be color";

    
}

