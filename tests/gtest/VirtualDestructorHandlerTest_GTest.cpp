// tests/gtest/VirtualDestructorHandlerTest_GTest.cpp
// Migrated from VirtualDestructorHandlerTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class VirtualDestructorHandlerTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(VirtualDestructorHandlerTest, DetectVirtualDestructor) {

    // Test: DetectVirtualDestructor

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualDestructorHandler handler(Context, analyzer);

    // Find the Base class
    CXXRecordDecl* Base = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "Base" && RD->isCompleteDefinition()) {
                Base = RD;
                break;
            }
        }
    }

    ASSERT_NE(Base, nullptr) << "Base class not found";

    // Check that destructor is virtual
    CXXDestructorDecl* Destructor = Base->getDestructor();
    ASSERT_NE(Destructor, nullptr) << "Destructor not found";
    ASSERT_NE(handler.isVirtualDestructor(Destructor), nullptr) << "Destructor should be detected as virtual";

    
}

TEST_F(VirtualDestructorHandlerTest, NonVirtualDestructorNotDetected) {

    // Test: NonVirtualDestructorNotDetected

    const char *code = R"(
        class Simple {
        public:
            ~Simple() {}  // Non-virtual
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualDestructorHandler handler(Context, analyzer);

    // Find the Simple class
    CXXRecordDecl* Simple = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "Simple" && RD->isCompleteDefinition()) {
                Simple = RD;
                break;
            }
        }
    }

    ASSERT_NE(Simple, nullptr) << "Simple class not found";

    CXXDestructorDecl* Destructor = Simple->getDestructor();
    ASSERT_NE(Destructor, nullptr) << "Destructor not found";
    ASSERT_NE(!handler.isVirtualDestructor(Destructor), nullptr) << "Non-virtual destructor should not be detected as virtual";

    
}

TEST_F(VirtualDestructorHandlerTest, VirtualDestructorInVtable) {

    // Test: VirtualDestructorInVtable

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
            virtual void method() {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualDestructorHandler handler(Context, analyzer);

    // Find the Base class
    CXXRecordDecl* Base = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "Base" && RD->isCompleteDefinition()) {
                Base = RD;
                break;
            }
        }
    }

    ASSERT_NE(Base, nullptr) << "Base class not found";

    // Check that destructor is included when getting vtable methods
    bool hasDestructor = handler.hasVirtualDestructor(Base);
    ASSERT_NE(hasDestructor, nullptr) << "Class with virtual destructor should report hasVirtualDestructor()";

    
}

TEST_F(VirtualDestructorHandlerTest, GetDestructorVtableName) {

    // Test: GetDestructorVtableName

    const char *code = R"(
        class MyClass {
        public:
            virtual ~MyClass() {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualDestructorHandler handler(Context, analyzer);

    // Find the MyClass class
    CXXRecordDecl* MyClass = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "MyClass" && RD->isCompleteDefinition()) {
                MyClass = RD;
                break;
            }
        }
    }

    ASSERT_NE(MyClass, nullptr) << "MyClass not found";

    CXXDestructorDecl* Destructor = MyClass->getDestructor();
    ASSERT_NE(Destructor, nullptr) << "Destructor not found";

    std::string vtableName = handler.getDestructorVtableName(Destructor);
    ASSERT_NE(vtableName == "destructor", nullptr) << "Destructor vtable name should be 'destructor'";

    
}

TEST_F(VirtualDestructorHandlerTest, InheritedVirtualDestructor) {

    // Test: InheritedVirtualDestructor

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
        };

        class Derived : public Base {
        public:
            ~Derived() override {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualDestructorHandler handler(Context, analyzer);

    // Find both classes
    CXXRecordDecl* Base = nullptr;
    CXXRecordDecl* Derived = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (!RD->isCompleteDefinition()) continue;
            if (RD->getNameAsString() == "Base") {
                Base = RD;
            } else if (RD->getNameAsString() == "Derived") {
                Derived = RD;
            }
        }
    }

    ASSERT_NE(Base, nullptr) << "Base class not found";
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    // Both should have virtual destructors
    ASSERT_NE(handler.hasVirtualDestructor(Base), nullptr) << "Base should have virtual destructor";
    ASSERT_NE(handler.hasVirtualDestructor(Derived), nullptr) << "Derived should have virtual destructor (inherited)";

    CXXDestructorDecl* DerivedDestructor = Derived->getDestructor();
    ASSERT_NE(DerivedDestructor, nullptr) << "Derived destructor not found";
    ASSERT_NE(handler.isVirtualDestructor(DerivedDestructor), nullptr) << "Derived destructor should be virtual";

    
}

TEST_F(VirtualDestructorHandlerTest, ImplicitVirtualDestructor) {

    // Test: ImplicitVirtualDestructor

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
        };

        class Derived : public Base {
            // Implicit destructor (should be virtual due to base)
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualDestructorHandler handler(Context, analyzer);

    // Find both classes
    CXXRecordDecl* Base = nullptr;
    CXXRecordDecl* Derived = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (!RD->isCompleteDefinition()) continue;
            if (RD->getNameAsString() == "Base") {
                Base = RD;
            } else if (RD->getNameAsString() == "Derived") {
                Derived = RD;
            }
        }
    }

    ASSERT_NE(Base, nullptr) << "Base class not found";
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    // Derived should have virtual destructor even if implicit
    ASSERT_NE(handler.hasVirtualDestructor(Derived), nullptr) << "Derived with implicit destructor should have virtual destructor";

    
}

TEST_F(VirtualDestructorHandlerTest, DestructorChaining) {

    // Test: DestructorChaining

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
        };

        class Middle : public Base {
        public:
            ~Middle() override {}
        };

        class Derived : public Middle {
        public:
            ~Derived() override {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualDestructorHandler handler(Context, analyzer);

    // Find all classes
    CXXRecordDecl* Base = nullptr;
    CXXRecordDecl* Middle = nullptr;
    CXXRecordDecl* Derived = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (!RD->isCompleteDefinition()) continue;
            std::string name = RD->getNameAsString();
            if (name == "Base") {
                Base = RD;
            } else if (name == "Middle") {
                Middle = RD;
            } else if (name == "Derived") {
                Derived = RD;
            }
        }
    }

    ASSERT_NE(Base, nullptr) << "Base class not found";
    ASSERT_NE(Middle, nullptr) << "Middle class not found";
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    // All should have virtual destructors
    ASSERT_NE(handler.hasVirtualDestructor(Base), nullptr) << "Base should have virtual destructor";
    ASSERT_NE(handler.hasVirtualDestructor(Middle), nullptr) << "Middle should have virtual destructor";
    ASSERT_NE(handler.hasVirtualDestructor(Derived), nullptr) << "Derived should have virtual destructor";

    // Check destructor chain exists
    CXXDestructorDecl* DerivedDestructor = Derived->getDestructor();
    ASSERT_NE(DerivedDestructor, nullptr) << "Derived destructor not found";

    // Verify destructor is properly overriding
    ASSERT_NE(DerivedDestructor->size_overridden_methods() > 0, nullptr) << "Derived destructor should override base destructors";

    
}

