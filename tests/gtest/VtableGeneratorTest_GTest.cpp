// tests/gtest/VtableGeneratorTest_GTest.cpp
// Migrated from VtableGeneratorTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class VtableGeneratorTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(VtableGeneratorTest, GenerateSimpleVtable) {

    // Test: GenerateSimpleVtable

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
            virtual void foo() {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Base = findClass(TU, "Base");
    ASSERT_NE(Base, nullptr) << "Base class not found";

    // Generate vtable struct
    std::string vtableCode = generator.generateVtableStruct(Base);

    // Verify vtable struct contains correct elements
    ASSERT_NE(vtableCode.find("struct Base_vtable") != std::string::npos, nullptr) << "Expected 'struct Base_vtable' in output";
    ASSERT_NE(vtableCode.find("void (*destructor)") != std::string::npos ||
           vtableCode.find("void (*__dtor)") != std::string::npos, nullptr) << "Expected destructor function pointer";
    ASSERT_NE(vtableCode.find("void (*foo)") != std::string::npos, nullptr) << "Expected foo function pointer";

    
}

TEST_F(VtableGeneratorTest, VtableMethodOrder) {

    // Test: VtableMethodOrder

    const char *code = R"(
        class Shape {
        public:
            virtual ~Shape() {}
            virtual double area() { return 0.0; }
            virtual void draw() {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Shape = findClass(TU, "Shape");
    ASSERT_NE(Shape, nullptr) << "Shape class not found";

    // Get method order
    auto methods = generator.getVtableMethodOrder(Shape);

    ASSERT_NE(methods.size() >= 2, nullptr) << "Expected at least 2 methods (destructor + virtual methods)";

    // First method should be destructor
    ASSERT_NE(isa<CXXDestructorDecl>(methods[0]) || methods[0]->getNameAsString().find("dtor") != std::string::npos, nullptr) << "First method should be destructor";

    
}

TEST_F(VtableGeneratorTest, MultipleVirtualMethods) {

    // Test: MultipleVirtualMethods

    const char *code = R"(
        class Widget {
        public:
            virtual ~Widget() {}
            virtual void render() {}
            virtual void update() {}
            virtual bool validate() { return true; }
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Widget = findClass(TU, "Widget");
    ASSERT_NE(Widget, nullptr) << "Widget class not found";

    std::string vtableCode = generator.generateVtableStruct(Widget);

    // Verify all methods present
    ASSERT_NE(vtableCode.find("struct Widget_vtable") != std::string::npos, nullptr) << "Expected vtable struct name";
    ASSERT_NE(vtableCode.find("render") != std::string::npos, nullptr) << "Expected render method";
    ASSERT_NE(vtableCode.find("update") != std::string::npos, nullptr) << "Expected update method";
    ASSERT_NE(vtableCode.find("validate") != std::string::npos, nullptr) << "Expected validate method";

    
}

TEST_F(VtableGeneratorTest, InheritedVirtualMethods) {

    // Test: InheritedVirtualMethods

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
            virtual void foo() {}
        };

        class Derived : public Base {
        public:
            void foo() override {}
            virtual void bar() {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    std::string vtableCode = generator.generateVtableStruct(Derived);

    // Verify derived vtable includes both inherited and new methods
    ASSERT_NE(vtableCode.find("struct Derived_vtable") != std::string::npos, nullptr) << "Expected Derived_vtable struct";
    ASSERT_NE(vtableCode.find("foo") != std::string::npos, nullptr) << "Expected foo (overridden) method";
    ASSERT_NE(vtableCode.find("bar") != std::string::npos, nullptr) << "Expected bar (new) method";

    
}

TEST_F(VtableGeneratorTest, FunctionPointerTypes) {

    // Test: FunctionPointerTypes

    const char *code = R"(
        class Calculator {
        public:
            virtual ~Calculator() {}
            virtual int add(int a, int b) { return a + b; }
            virtual double multiply(double x, double y) { return x * y; }
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Calculator = findClass(TU, "Calculator");
    ASSERT_NE(Calculator, nullptr) << "Calculator class not found";

    std::string vtableCode = generator.generateVtableStruct(Calculator);

    // Verify function pointer signatures
    ASSERT_NE(vtableCode.find("int (*add)") != std::string::npos, nullptr) << "Expected 'int (*add)' function pointer";
    ASSERT_NE(vtableCode.find("double (*multiply)") != std::string::npos ||
           vtableCode.find("float (*multiply)") != std::string::npos, nullptr) << "Expected 'double (*multiply)' function pointer";

    
}

TEST_F(VtableGeneratorTest, NonPolymorphicClass) {

    // Test: NonPolymorphicClass

    const char *code = R"(
        class Regular {
        public:
            void foo() {}
            int bar() { return 42; }
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Regular = findClass(TU, "Regular");
    ASSERT_NE(Regular, nullptr) << "Regular class not found";

    std::string vtableCode = generator.generateVtableStruct(Regular);

    // Non-polymorphic class should not generate vtable
    ASSERT_NE(vtableCode.empty() || vtableCode.find("// Not polymorphic") != std::string::npos, nullptr) << "Non-polymorphic class should not generate vtable";

    
}

TEST_F(VtableGeneratorTest, PureVirtualMethods) {

    // Test: PureVirtualMethods

    const char *code = R"(
        class Abstract {
        public:
            virtual ~Abstract() {}
            virtual void foo() = 0;
            virtual int bar() = 0;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Abstract = findClass(TU, "Abstract");
    ASSERT_NE(Abstract, nullptr) << "Abstract class not found";

    std::string vtableCode = generator.generateVtableStruct(Abstract);

    // Abstract class should still generate vtable struct
    ASSERT_NE(vtableCode.find("struct Abstract_vtable") != std::string::npos, nullptr) << "Expected vtable struct for abstract class";
    ASSERT_NE(vtableCode.find("foo") != std::string::npos, nullptr) << "Expected pure virtual foo";
    ASSERT_NE(vtableCode.find("bar") != std::string::npos, nullptr) << "Expected pure virtual bar";

    
}

TEST_F(VtableGeneratorTest, ComplexInheritance) {

    // Test: ComplexInheritance

    const char *code = R"(
        class Base {
        public:
            virtual ~Base() {}
            virtual void foo() {}
        };

        class Middle : public Base {
        public:
            void foo() override {}
            virtual void bar() {}
        };

        class Derived : public Middle {
        public:
            void bar() override {}
            virtual void baz() {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    VtableGenerator generator(AST->getASTContext(), analyzer);

    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    std::string vtableCode = generator.generateVtableStruct(Derived);

    // Verify all methods in hierarchy
    ASSERT_NE(vtableCode.find("struct Derived_vtable") != std::string::npos, nullptr) << "Expected Derived_vtable";
    ASSERT_NE(vtableCode.find("foo") != std::string::npos, nullptr) << "Expected inherited foo";
    ASSERT_NE(vtableCode.find("bar") != std::string::npos, nullptr) << "Expected overridden bar";
    ASSERT_NE(vtableCode.find("baz") != std::string::npos, nullptr) << "Expected new baz";

    
}

