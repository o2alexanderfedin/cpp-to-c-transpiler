// tests/gtest/VirtualCallTranslatorTest_GTest.cpp
// Migrated from VirtualCallTranslatorTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class VirtualCallTranslatorTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(VirtualCallTranslatorTest, DetectVirtualCall) {

    // Test: DetectVirtualCall

    const char *code = R"(
        class Shape {
        public:
            virtual void draw() {}
        };

        void test(Shape* s) {
            s->draw();
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualCallTranslator translator(Context, analyzer);

    // Find all method calls
    CallFinder finder;
    finder.TraverseDecl(Context.getTranslationUnitDecl());

    ASSERT_NE(!finder.Calls.empty(), nullptr) << "Should find method call";

    // Check if it's virtual
    bool foundVirtualCall = false;
    for (auto* call : finder.Calls) {
        if (translator.isVirtualCall(call)) {
            foundVirtualCall = true;
            break;
        }
    }

    ASSERT_NE(foundVirtualCall, nullptr) << "Should detect virtual call";

    
}

TEST_F(VirtualCallTranslatorTest, NonVirtualCallNotDetected) {

    // Test: NonVirtualCallNotDetected

    const char *code = R"(
        class Point {
        public:
            void move() {}  // Non-virtual
        };

        void test(Point* p) {
            p->move();
        }
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualCallTranslator translator(Context, analyzer);

    CallFinder finder;
    finder.TraverseDecl(Context.getTranslationUnitDecl());

    ASSERT_NE(!finder.Calls.empty(), nullptr) << "Should find method call";

    // Check that it's NOT virtual
    for (auto* call : finder.Calls) {
        ASSERT_NE(!translator.isVirtualCall(call), nullptr) << "Non-virtual call should not be detected as virtual";
    }

    
}

TEST_F(VirtualCallTranslatorTest, GetVtableMethodName) {

    // Test: GetVtableMethodName

    const char *code = R"(
        class Shape {
        public:
            virtual void draw() {}
            virtual void setColor(int r) {}
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    VirtualCallTranslator translator(Context, analyzer);

    // Find the Shape class
    CXXRecordDecl* Shape = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "Shape" && RD->isCompleteDefinition()) {
                Shape = RD;
                break;
            }
        }
    }

    ASSERT_NE(Shape, nullptr) << "Shape class not found";

    // Check method names
    for (auto* method : Shape->methods()) {
        if (!method->isVirtual()) continue;

        std::string name = translator.getVtableMethodName(method);
        std::string methodName = method->getNameAsString();

        ASSERT(name == methodName,
               "Vtable method name should match: expected " + methodName + ", got " + name);
    }

    
}

