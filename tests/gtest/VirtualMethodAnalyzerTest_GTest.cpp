// tests/gtest/VirtualMethodAnalyzerTest_GTest.cpp
// Migrated from VirtualMethodAnalyzerTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class VirtualMethodAnalyzerTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(VirtualMethodAnalyzerTest, DetectSingleVirtualMethod) {

    // Test: DetectSingleVirtualMethod

    const char *code = R"(
        class Base {
        public:
            virtual void foo();
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Base = findClass(TU, "Base");
    ASSERT_NE(Base, nullptr) << "Base class not found";

    // Test: Class should be polymorphic
    ASSERT_NE(analyzer.isPolymorphic(Base), nullptr) << "Base should be polymorphic";

    // Test: Should have exactly 1 virtual method
    auto virtualMethods = analyzer.getVirtualMethods(Base);
    ASSERT(virtualMethods.size() == 1,
           "Expected 1 virtual method, got: " + std::to_string(virtualMethods.size()));

    // Test: Should not be abstract (no pure virtual)
    ASSERT_NE(!analyzer.isAbstractClass(Base), nullptr) << "Base should not be abstract";

    
}

TEST_F(VirtualMethodAnalyzerTest, DetectPureVirtualMethod) {

    // Test: DetectPureVirtualMethod

    const char *code = R"(
        class Abstract {
        public:
            virtual void foo() = 0;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Abstract = findClass(TU, "Abstract");
    ASSERT_NE(Abstract, nullptr) << "Abstract class not found";

    // Test: Class should be polymorphic
    ASSERT_NE(analyzer.isPolymorphic(Abstract), nullptr) << "Abstract should be polymorphic";

    // Test: Class should be abstract
    ASSERT_NE(analyzer.isAbstractClass(Abstract), nullptr) << "Abstract should be abstract class";

    // Test: Method should be pure virtual
    auto virtualMethods = analyzer.getVirtualMethods(Abstract);
    ASSERT_NE(virtualMethods.size() == 1, nullptr) << "Expected 1 virtual method";
    ASSERT_NE(analyzer.isPureVirtual(virtualMethods[0]), nullptr) << "foo() should be pure virtual";

    
}

TEST_F(VirtualMethodAnalyzerTest, DetectMultipleVirtualMethods) {

    // Test: DetectMultipleVirtualMethods

    const char *code = R"(
        class Shape {
        public:
            virtual void draw();
            virtual double area();
            virtual void setColor(int c);
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Shape = findClass(TU, "Shape");
    ASSERT_NE(Shape, nullptr) << "Shape class not found";

    // Test: Class should be polymorphic
    ASSERT_NE(analyzer.isPolymorphic(Shape), nullptr) << "Shape should be polymorphic";

    // Test: Should have 3 virtual methods
    auto virtualMethods = analyzer.getVirtualMethods(Shape);
    ASSERT(virtualMethods.size() == 3,
           "Expected 3 virtual methods, got: " + std::to_string(virtualMethods.size()));

    
}

TEST_F(VirtualMethodAnalyzerTest, DetectInheritedVirtualMethods) {

    // Test: DetectInheritedVirtualMethods

    const char *code = R"(
        class Base {
        public:
            virtual void foo();
        };

        class Derived : public Base {
        public:
            void foo() override;
            virtual void bar();
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Base = findClass(TU, "Base");
    auto *Derived = findClass(TU, "Derived");
    ASSERT_NE(Base, nullptr) << "Base class not found";
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    // Test: Both should be polymorphic
    ASSERT_NE(analyzer.isPolymorphic(Base), nullptr) << "Base should be polymorphic";
    ASSERT_NE(analyzer.isPolymorphic(Derived), nullptr) << "Derived should be polymorphic";

    // Test: Base has 1 virtual method
    auto baseMethods = analyzer.getVirtualMethods(Base);
    ASSERT_NE(baseMethods.size() == 1, nullptr) << "Base should have 1 virtual method";

    // Test: Derived has 2 virtual methods (foo override + bar)
    auto derivedMethods = analyzer.getVirtualMethods(Derived);
    ASSERT(derivedMethods.size() == 2,
           "Expected 2 virtual methods in Derived, got: " + std::to_string(derivedMethods.size()));

    
}

TEST_F(VirtualMethodAnalyzerTest, NonPolymorphicClass) {

    // Test: NonPolymorphicClass

    const char *code = R"(
        class Regular {
        public:
            void foo();
            int bar();
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Regular = findClass(TU, "Regular");
    ASSERT_NE(Regular, nullptr) << "Regular class not found";

    // Test: Class should NOT be polymorphic
    ASSERT_NE(!analyzer.isPolymorphic(Regular), nullptr) << "Regular should not be polymorphic";

    // Test: Should have 0 virtual methods
    auto virtualMethods = analyzer.getVirtualMethods(Regular);
    ASSERT(virtualMethods.size() == 0,
           "Expected 0 virtual methods, got: " + std::to_string(virtualMethods.size()));

    // Test: Should not be abstract
    ASSERT_NE(!analyzer.isAbstractClass(Regular), nullptr) << "Regular should not be abstract";

    
}

TEST_F(VirtualMethodAnalyzerTest, MixedVirtualMethods) {

    // Test: MixedVirtualMethods

    const char *code = R"(
        class Mixed {
        public:
            void normalMethod();
            virtual void virtualMethod1();
            int anotherNormal();
            virtual void virtualMethod2();
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *Mixed = findClass(TU, "Mixed");
    ASSERT_NE(Mixed, nullptr) << "Mixed class not found";

    // Test: Class should be polymorphic
    ASSERT_NE(analyzer.isPolymorphic(Mixed), nullptr) << "Mixed should be polymorphic";

    // Test: Should have exactly 2 virtual methods
    auto virtualMethods = analyzer.getVirtualMethods(Mixed);
    ASSERT(virtualMethods.size() == 2,
           "Expected 2 virtual methods, got: " + std::to_string(virtualMethods.size()));

    
}

TEST_F(VirtualMethodAnalyzerTest, VirtualDestructor) {

    // Test: VirtualDestructor

    const char *code = R"(
        class WithVirtualDestructor {
        public:
            virtual ~WithVirtualDestructor();
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    VirtualMethodAnalyzer analyzer(AST->getASTContext());
    auto *TU = AST->getASTContext().getTranslationUnitDecl();
    auto *WithVirtualDestructor = findClass(TU, "WithVirtualDestructor");
    ASSERT_NE(WithVirtualDestructor, nullptr) << "WithVirtualDestructor class not found";

    // Test: Class should be polymorphic (virtual destructor counts)
    ASSERT_NE(analyzer.isPolymorphic(WithVirtualDestructor), nullptr) << "Class with virtual destructor should be polymorphic";

    // Test: Should have virtual methods (destructor is a virtual method)
    auto virtualMethods = analyzer.getVirtualMethods(WithVirtualDestructor);
    ASSERT_NE(virtualMethods.size() >= 1, nullptr) << "Expected at least 1 virtual method (destructor)";

    
}

