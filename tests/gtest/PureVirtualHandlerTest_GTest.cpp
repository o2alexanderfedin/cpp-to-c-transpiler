// tests/gtest/PureVirtualHandlerTest_GTest.cpp
// Migrated from PureVirtualHandlerTest.cpp
// Auto-generated by migrate_virtual_tests.py

#include <gtest/gtest.h>
#include "VirtualFunctionTestFixtures.h"

using namespace std;

// Test fixture
class PureVirtualHandlerTest : public VirtualFunctionTestBase {
protected:
    void SetUp() override {
        // Base setup handles AST initialization
    }
};

TEST_F(PureVirtualHandlerTest, DetectPureVirtualMethod) {

    // Test: DetectPureVirtualMethod

    const char *code = R"(
        class Shape {
        public:
            virtual void draw() = 0;  // Pure virtual
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    PureVirtualHandler handler(Context, analyzer);

    // Find the Shape class
    CXXRecordDecl* Shape = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "Shape" && RD->isCompleteDefinition()) {
                Shape = RD;
                break;
            }
        }
    }

    ASSERT_NE(Shape, nullptr) << "Shape class not found";

    // Check that draw() is pure virtual
    bool foundPureVirtual = false;
    for (auto* method : Shape->methods()) {
        if (method->getNameAsString() == "draw") {
            foundPureVirtual = handler.isPureVirtual(method);
            break;
        }
    }

    ASSERT_NE(foundPureVirtual, nullptr) << "draw() should be detected as pure virtual";

    
}

TEST_F(PureVirtualHandlerTest, DetectAbstractClass) {

    // Test: DetectAbstractClass

    const char *code = R"(
        class AbstractShape {
        public:
            virtual void draw() = 0;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    PureVirtualHandler handler(Context, analyzer);

    // Find the AbstractShape class
    CXXRecordDecl* AbstractShape = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "AbstractShape" && RD->isCompleteDefinition()) {
                AbstractShape = RD;
                break;
            }
        }
    }

    ASSERT_NE(AbstractShape, nullptr) << "AbstractShape class not found";
    ASSERT_NE(handler.isAbstractClass(AbstractShape), nullptr) << "AbstractShape should be detected as abstract";

    
}

TEST_F(PureVirtualHandlerTest, NonAbstractClassNotDetected) {

    // Test: NonAbstractClassNotDetected

    const char *code = R"(
        class ConcreteShape {
        public:
            virtual void draw() {}  // Not pure virtual
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    PureVirtualHandler handler(Context, analyzer);

    // Find the ConcreteShape class
    CXXRecordDecl* ConcreteShape = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "ConcreteShape" && RD->isCompleteDefinition()) {
                ConcreteShape = RD;
                break;
            }
        }
    }

    ASSERT_NE(ConcreteShape, nullptr) << "ConcreteShape class not found";
    ASSERT_NE(!handler.isAbstractClass(ConcreteShape), nullptr) << "ConcreteShape should NOT be detected as abstract";

    
}

TEST_F(PureVirtualHandlerTest, MultiplePureVirtualMethods) {

    // Test: MultiplePureVirtualMethods

    const char *code = R"(
        class Interface {
        public:
            virtual void method1() = 0;
            virtual void method2() = 0;
            virtual int method3() = 0;
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    PureVirtualHandler handler(Context, analyzer);

    // Find the Interface class
    CXXRecordDecl* Interface = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "Interface" && RD->isCompleteDefinition()) {
                Interface = RD;
                break;
            }
        }
    }

    ASSERT_NE(Interface, nullptr) << "Interface class not found";

    auto pureVirtualMethods = handler.getPureVirtualMethods(Interface);
    ASSERT_NE(pureVirtualMethods.size() == 3, nullptr) << "Should detect 3 pure virtual methods";

    
}

TEST_F(PureVirtualHandlerTest, MixedVirtualAndPureVirtual) {

    // Test: MixedVirtualAndPureVirtual

    const char *code = R"(
        class MixedClass {
        public:
            virtual void concrete() {}    // Regular virtual
            virtual void abstract() = 0;  // Pure virtual
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    PureVirtualHandler handler(Context, analyzer);

    // Find the MixedClass class
    CXXRecordDecl* MixedClass = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (RD->getNameAsString() == "MixedClass" && RD->isCompleteDefinition()) {
                MixedClass = RD;
                break;
            }
        }
    }

    ASSERT_NE(MixedClass, nullptr) << "MixedClass class not found";
    ASSERT_NE(handler.isAbstractClass(MixedClass), nullptr) << "Class with any pure virtual should be abstract";

    auto pureVirtualMethods = handler.getPureVirtualMethods(MixedClass);
    ASSERT_NE(pureVirtualMethods.size() == 1, nullptr) << "Should detect 1 pure virtual method";

    
}

TEST_F(PureVirtualHandlerTest, DerivedConcreteClass) {

    // Test: DerivedConcreteClass

    const char *code = R"(
        class Abstract {
        public:
            virtual void method() = 0;
        };

        class Concrete : public Abstract {
        public:
            void method() override {}  // Provides implementation
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    PureVirtualHandler handler(Context, analyzer);

    // Find both classes
    CXXRecordDecl* Abstract = nullptr;
    CXXRecordDecl* Concrete = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (!RD->isCompleteDefinition()) continue;
            if (RD->getNameAsString() == "Abstract") {
                Abstract = RD;
            } else if (RD->getNameAsString() == "Concrete") {
                Concrete = RD;
            }
        }
    }

    ASSERT_NE(Abstract, nullptr) << "Abstract class not found";
    ASSERT_NE(Concrete, nullptr) << "Concrete class not found";

    ASSERT_NE(handler.isAbstractClass(Abstract), nullptr) << "Base class should be abstract";
    ASSERT_NE(!handler.isAbstractClass(Concrete), nullptr) << "Derived class overriding all pure virtuals should be concrete";

    
}

TEST_F(PureVirtualHandlerTest, DerivedAbstractClass) {

    // Test: DerivedAbstractClass

    const char *code = R"(
        class Base {
        public:
            virtual void method1() = 0;
            virtual void method2() = 0;
        };

        class Derived : public Base {
        public:
            void method1() override {}  // Overrides method1 only
            // method2 remains pure virtual
        };
    )";

    AST = buildAST(code);
    ASSERT_NE(AST, nullptr) << "Failed to parse C++ code";

    auto& Context = AST->getASTContext();
    VirtualMethodAnalyzer analyzer(Context);
    PureVirtualHandler handler(Context, analyzer);

    // Find both classes
    CXXRecordDecl* Base = nullptr;
    CXXRecordDecl* Derived = nullptr;
    for (auto *D : Context.getTranslationUnitDecl()->decls()) {
        if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {
            if (!RD->isCompleteDefinition()) continue;
            if (RD->getNameAsString() == "Base") {
                Base = RD;
            } else if (RD->getNameAsString() == "Derived") {
                Derived = RD;
            }
        }
    }

    ASSERT_NE(Base, nullptr) << "Base class not found";
    ASSERT_NE(Derived, nullptr) << "Derived class not found";

    ASSERT_NE(handler.isAbstractClass(Base), nullptr) << "Base class should be abstract";
    ASSERT_NE(handler.isAbstractClass(Derived), nullptr) << "Derived class not overriding all pure virtuals should remain abstract";

    
}

